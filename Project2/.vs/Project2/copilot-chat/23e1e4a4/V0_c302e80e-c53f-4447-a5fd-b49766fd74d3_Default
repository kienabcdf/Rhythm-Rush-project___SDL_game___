…¨DateTime×ÿ™àeôş™ªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$8183a7d7-d5e7-4692-88b3-208d43afd357Ù$47c1b48d-f1bb-4481-a328-7cb12c7ed206‘†¯ProviderMoniker‚¤NameÙ6Microsoft.VisualStudio.Copilot.DocumentContextProvider§Version£0.1¦Member¤file©CanReduceÃ©RequestIdÙ$8183a7d7-d5e7-4692-88b3-208d43afd357©Reference²#file:'Source.cpp'¥ValueÈ|dÙ‘Microsoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a…§ContentÚzí#include <SDL.h>
#include <stdio.h>
#include <SDL_image.h>
#include <iostream>
#include <ctime>
#include<vector>
#include<algorithm>
#include<random>
#include<SDL_mixer.h>
#include<SDL_ttf.h>
#include<thread>

using namespace std;


//creat a funtion to generate random number from seed time
int generateRandomNumber(int min, int max) {
	static bool first = true;
    if (first) {
		srand(time(NULL));
		first = false;
	}
	return min + rand() % ((max + 1) - min);
}
//creat a funtion to generate n random numbers from seed time
vector<int> generateRandomNumbers(int min, int max, int n) {
	vector<int> result;
    for (int i = 0; i < n; i++) {
		result.push_back(generateRandomNumber(min, max));
	}
	return result;
}

const int positionnood[] = { 59,205,331,605,751,876 };//position of nood
const int numbernood[]={1,1,1,1,1,1,2,2,2,2,2,3,3,1,3,4,1,4,6,2};//rate of random number of nood
//funtion to random number of nood
int creatnumberofnood() {
	int numberofnood = generateRandomNumber(1,20);
	return numbernood[numberofnood];
}
//funtion to random position of nood with number of nood
vector<int> creatpositionofnood(int numbernood) {
    vector<int> result;
    if (numbernood % 2 == 0) {
        
        result= generateRandomNumbers(1, 3, numbernood/2);
        for (int i = 0; i < numbernood / 2; i++) { result.push_back(6 - result[i] + 1); }
        return result;
    }
    else {
        int th=generateRandomNumber(1,2);
        if (th == 1) {
           
            return generateRandomNumbers(1, 3, numbernood);
        }
        else {
            return generateRandomNumbers(4, 6, numbernood);
		}
    }
    return result;
}
//struct of nood
struct Noods {
    SDL_Texture* a;
    int x=0, y=0;
    bool check = false;
};
  

int main(int argc, char* args[]) {
    bool gameplay = false;

    // Khá»Ÿi táº¡o SDL
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        printf("SDL could not initialize! SDL_Error: %s\n", SDL_GetError());
        return 1;
    }

    SDL_Window* window = SDL_CreateWindow("SDL 2.0 Basic Example", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 1080, 810, SDL_WINDOW_SHOWN);
    if (window == NULL) {
        printf("Window could not be created! SDL_Error: %s\n", SDL_GetError());
        return 1;
    }

    // Táº¡o renderer
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    if (renderer == NULL) {
        printf("Renderer could not be created! SDL_Error: %s\n", SDL_GetError());
        return 1;
    }
    SDL_Surface* noodSurface = IMG_Load("Image/nood.png");
    if (noodSurface == NULL) {
        printf("SDL could not load image! SDL Error: %s\n", SDL_GetError());
        return 1;
    }
    SDL_Surface* longnoodSurface = IMG_Load("Image/longnood.png");
    if (longnoodSurface == NULL) {
		printf("SDL could not load image! SDL Error: %s\n", SDL_GetError());
		return 1;
	}
    SDL_Texture* noodTexture = SDL_CreateTextureFromSurface(renderer, noodSurface);
    SDL_FreeSurface(noodSurface);
    SDL_Rect noodRect = { 100,1.1, 100, 100 };
    SDL_Texture* longnoodTexture = SDL_CreateTextureFromSurface(renderer, longnoodSurface);
    SDL_FreeSurface(longnoodSurface);
    //create longnoodreact with full image of longnood
    SDL_Rect longnoodRect = { 205,50, 22, 883 };

    SDL_Surface* openSurface = IMG_Load("Image/open.png");
    SDL_Texture* openTexture = SDL_CreateTextureFromSurface(renderer, openSurface);
    SDL_FreeSurface(openSurface);

   
    SDL_Texture* texture = openTexture;
    
    SDL_Rect destinationRect = { 0,0, 1080, 810 };
    SDL_RenderCopyEx(renderer, texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
    
    
    Noods nood;
    nood.a = noodTexture;
    nood.x = 59;
    nood.y = 0;
    nood.check = true;
    //creat vector nood for gameplay
    vector<Noods> noods;
    noods.push_back(nood);
    Noods longnood;
    longnood.a = longnoodTexture;
    longnood.x = 205;
    longnood.y = 0;
    longnood.check = true;
    //display longnood
    SDL_RenderCopyEx(renderer, longnood.a, NULL, &longnoodRect, 0.0, NULL, SDL_FLIP_NONE);
    vector<Noods> longnoods;
    SDL_RenderPresent(renderer);

    //loop of opentexture go to game if mouse click
    while (true) {
        //if mouse click
        SDL_Event e;
        SDL_PollEvent(&e);
        if (e.type == SDL_MOUSEBUTTONDOWN) {
            break;
        }
    }
    SDL_DestroyTexture(openTexture);
    bool quit = false;
    SDL_Event e;
    // variable to control speed and number of nood
    float demSpeed = 0;
    float demWave = 0;
    int demNood = 0;
    int speed = 14;
    int demsp = 0;
    if (SDL_Init(SDL_INIT_AUDIO) < 0) {
        printf("SDL could not initialize! SDL_Error: %s\n", SDL_GetError());
        return 1;
    }
    if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048) < 0) {
        printf("SDL_mixer could not initialize! SDL_mixer Error: %s\n", Mix_GetError());
        return 1;
    }

    // load menu music
    Mix_Music* music = Mix_LoadMUS("music/menu.mp3");
    if (music == NULL) {
        printf("Failed to load music! SDL_mixer Error: %s\n", Mix_GetError());
        return 1;
    }
    //main loop start menu 
    while (!quit) {
        SDL_Surface* menuSurface = IMG_Load("Image/Menu.png");
        SDL_Texture* menuTexture = SDL_CreateTextureFromSurface(renderer, menuSurface);
        SDL_FreeSurface(menuSurface);
        SDL_Surface* menu1Surface = IMG_Load("Image/Menu1.png");
        SDL_Texture* menu1Texture = SDL_CreateTextureFromSurface(renderer, menu1Surface);
        SDL_FreeSurface(menu1Surface);

        SDL_Surface* menu2Surface = IMG_Load("Image/Menu2.png");
        SDL_Texture* menu2Texture = SDL_CreateTextureFromSurface(renderer, menu2Surface);
        SDL_FreeSurface(menu2Surface);

        SDL_Surface* menu3Surface = IMG_Load("Image/Menu3.png");
        SDL_Texture* menu3Texture = SDL_CreateTextureFromSurface(renderer, menu3Surface);
        SDL_FreeSurface(menu3Surface);
        texture = menuTexture;
        //thread to play menu music and play again if music menu end
        std::thread t1([&music]() {
            Mix_PlayMusic(music, -1);
            if (music == NULL) Mix_PlayMusic(music, -1);

            });
        t1.join();
        //menu loop
        while (true) {

            while (SDL_PollEvent(&e) != 0) {
                if (e.type == SDL_QUIT) {
                    quit = true;
                }
            }

            SDL_Rect destinationRect = { 0,0.0, 1080, 810 };
            SDL_RenderCopyEx(renderer, texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
            SDL_RenderPresent(renderer);
   //get mouse position
            int x, y;
            SDL_GetMouseState(&x, &y);
            //action with each button of menu be clicked
            //play button
            if (x > 400 && x < 700) {
                if (y > 350 && y < 475) {
                    texture = menu1Texture;
                    //go to gameplay if mouse click in play button
                    SDL_PollEvent(&e);
                    if (e.type == SDL_MOUSEBUTTONDOWN) {
                        gameplay = true;

                        break;
                    }
                }
                //how to play button
                else if (y > 490 && y < 600) {
                    texture = menu2Texture;
                    SDL_PollEvent(&e);
                    if (e.type == SDL_MOUSEBUTTONDOWN) {
						//pause music and display how to play texture
                        Mix_PauseMusic();
						SDL_Surface* howtoplaySurface = IMG_Load("Image/how to play.png");
						SDL_Texture* howtoplayTexture = SDL_CreateTextureFromSurface(renderer, howtoplaySurface);
						SDL_FreeSurface(howtoplaySurface);
						destinationRect = { 0,0, 1080, 810 };
						SDL_RenderCopyEx(renderer, howtoplayTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
						SDL_RenderPresent(renderer);
                        SDL_Delay(500);
						//how to play loop
                        while (true) {
							SDL_PollEvent(&e);
                            //go back to menu if mouse click
                            if (e.type == SDL_MOUSEBUTTONDOWN) {
								SDL_DestroyTexture(howtoplayTexture);
								break;
                            }
						}
						SDL_DestroyTexture(howtoplayTexture);
                        //music resume
                        Mix_ResumeMusic();
					}
                    
                }
                //exit button
                else if (y > 600 && y < 700) {

                    texture = menu3Texture;
                    //program quif if mouse click

                    SDL_PollEvent(&e);
                    if (e.type == SDL_MOUSEBUTTONDOWN) {

                        return 0;

                    }

                }
				//if mouse not in button
                else {
                    texture = menuTexture;
                }
            }
			//if mouse not in button
            else {
                texture = menuTexture;
            }
        }
        // Load gameplay music
        Mix_Music* music = Mix_LoadMUS("music/AdhesiveWombat - 8 Bit Adventure.mp3");
        if (music == NULL) {
            printf("Failed to load music! SDL_mixer Error: %s\n", Mix_GetError());
            return 1;
        }
        //setup for gameplay
        if (gameplay == true) {
            //delete menu texture
            SDL_DestroyTexture(menuTexture);
            SDL_DestroyTexture(menu1Texture);
            SDL_DestroyTexture(menu2Texture);
            SDL_DestroyTexture(menu3Texture);
            SDL_Surface* backgroundSurface = IMG_Load("Image/gameplay.png");
            if (backgroundSurface == NULL) {
                printf("SDL could not load image! SDL Error: %s\n", SDL_GetError());
                return 1;
            }
            SDL_Texture* backgroundTexture = SDL_CreateTextureFromSurface(renderer, backgroundSurface);
            SDL_FreeSurface(backgroundSurface);
            texture = backgroundTexture;
            SDL_Surface* goodSurface = IMG_Load("Image/good.png");
            SDL_Texture* goodTexture = SDL_CreateTextureFromSurface(renderer, goodSurface);
            SDL_FreeSurface(goodSurface);
            SDL_Surface* missSurface = IMG_Load("Image/miss.png");
            SDL_Texture* missTexture = SDL_CreateTextureFromSurface(renderer, missSurface);
            SDL_FreeSurface(missSurface);
            SDL_Surface* perfectSurface = IMG_Load("Image/perfect.png");
            SDL_Texture* perfectTexture = SDL_CreateTextureFromSurface(renderer, perfectSurface);
            SDL_FreeSurface(perfectSurface);    
            SDL_Surface* tooearlySurface = IMG_Load("Image/too early.png");
            SDL_Texture* tooearlyTexture = SDL_CreateTextureFromSurface(renderer, tooearlySurface);
            SDL_FreeSurface(tooearlySurface);
            
            //thread to play gameplay music
            t1 = std::thread([&music]() {
                Mix_PlayMusic(music, -1);
                });
            t1.join();
            //variable for gameplay
            time_t startTime = std::time(nullptr);
            int demkey = 0;
            int demperfect = 0;
            int choice;
            int perfect = 0;
            int good = 0;
            int miss = 0;
            int tooearly = 0;
            speed = 14;
            //gameplay loop
            while (gameplay) {
                // check time after each loop
                time_t currentTime = std::time(nullptr);
                time_t elapsedTime = currentTime - startTime;
                while (SDL_PollEvent(&e) != 0) {
                    if (e.type == SDL_QUIT) {
                        quit = true;
                    }
                }
                destinationRect = { 0,0, 1080, 810 };
                SDL_RenderCopyEx(renderer, texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
                demSpeed += 1;
                //control speed, create wave nood
                if (demSpeed >= 1) {
                    demSpeed = 0;
                    for (Noods& x : noods) {
                        if (x.check == true) {
                            if (x.y >= 810) {
                                x.check = false;
                                choice = 0;
                                demperfect = 20;
                                miss++;
                            }
                            x.y += 5;//move nood
                            SDL_Rect mouseRect = { x.x,x.y, 100, 100 };
                            SDL_RenderCopyEx(renderer, x.a, NULL, &mouseRect, 0.0, NULL, SDL_FLIP_NONE);
                        }
                      
                      
                    }
                    demWave +=2;
                    // wave of nood
                    if (demWave >= 125) {
                        demWave = 0;
                        //create new wave nood
                        vector<int> position = creatpositionofnood(creatnumberofnood());
                        
                        if (elapsedTime <= 268 && !(elapsedTime >= 206 && elapsedTime <= 210)) {
                            for (int y : position) {

                                noods.push_back(nood);
                                noods.back().x = positionnood[y - 1];

                            }
                        }
                        // increase speecd of nood follow time
                        demsp++;
                        if (demsp >= 15) {
                            if (speed > 7) {
                                speed -= 1;
                            }
                            demsp = 0;
                        }
                    }
                }
                if (noods.size() > 50) noods.erase(noods.begin(), noods.begin() + 30);
                if (demkey == 0) {//demkey to reduce stick key
                    //main gameplay get point and check correct nood be pressed
                    for (Noods& x : noods) {
                        if (x.check == true && x.y >= 525 && x.y <= 800) {
                            if (x.x == 59 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_S]) {
                                x.check = false;
                                if (x.y >= 525 && x.y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x.y >= 575 && x.y < 630) || (x.y >= 740 && x.y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x.y >= 630 && x.y < 740) { choice = 3; demperfect = 20; perfect++; }
                                demkey = 10;
                            }
                            else if (x.x == 205 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_D]) {
                                x.check = false;
                                
                                if (x.y >= 525 && x.y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x.y >= 575 && x.y < 630) || (x.y >= 740 && x.y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x.y >= 630 && x.y < 740) { choice = 3; demperfect = 20; perfect++; }
                               
                                demkey = 10;
                            }
                            else if (x.x == 331 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_F]) {
                                x.check = false;
                               
                                if (x.y >= 525 && x.y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x.y >= 575 && x.y < 630) || (x.y >= 740 && x.y < 800)) { choice = 2; demperfect = 20;good++; }
                                else if (x.y >= 630 && x.y < 740) { choice = 3; demperfect = 20; perfect++; }
                                
                                    demkey = 10;
                            }
                            else if (x.x == 605 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_J]) {
                                x.check = false;
                                
                                if (x.y >= 525 && x.y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x.y >= 575 && x.y < 630) || (x.y >= 740 && x.y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x.y >= 630 && x.y < 740) { choice = 3; demperfect = 20; perfect++; }
								
									
                                
                                demkey = 10;
                            }
                            else if (x.x == 751 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_K]) {
                                x.check = false;

                                if (x.y >= 525 && x.y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x.y >= 575 && x.y < 630) || (x.y >= 740 && x.y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x.y >= 630 && x.y < 740) { choice = 3; demperfect = 20; perfect++; }
								
								
                             
                                demkey = 10;
                            }
                            else if (x.x == 876 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_L]) {
                                x.check = false;
                               
                                if (x.y >= 525 && x.y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x.y >= 575 && x.y < 630) || (x.y >= 740 && x.y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x.y >= 630 && x.y < 740) { choice = 3; demperfect = 20; perfect++; }
                               
                                demkey = 10;
                            }
                            else continue;
                        }
                        else if (x.check == true && x.y < 575) { break; }
                    }
                }
                else demkey--;
                //pause game if esc press
                if (demkey == 0) {
                    if (SDL_GetKeyboardState(NULL)[SDL_SCANCODE_ESCAPE]) {
                        Mix_PauseMusic();
                        SDL_Surface* pauseSurface = IMG_Load("Image/pause.png");
                        SDL_Texture* pauseTexture = SDL_CreateTextureFromSurface(renderer, pauseSurface);
                        SDL_FreeSurface(pauseSurface);
                        destinationRect = {230,200, 600, 450};
                        SDL_RenderCopyEx(renderer, pauseTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
                        SDL_RenderPresent(renderer);
                        while (true) {
                            //if mouse click
                            SDL_PollEvent(&e);
                            if (e.type == SDL_MOUSEBUTTONDOWN) {
                                int x, y;
                                SDL_GetMouseState(&x, &y);
                                //check button be clicked
                                if (x > 450 && x < 600 && y > 350 && y < 500) {
                                    // Resume button clicked
                                    Mix_ResumeMusic();
                                    break;
                                }
                                else if (x > 320 && x < 440 && y > 510 && y < 580) {
                                    // Quit button clicked
                                    noods.resize(0);
                                    std::thread t1([&music]() {
                                        Mix_PlayMusic(music, -1);
                                        if (music == NULL) Mix_PlayMusic(music, -1);
                                        });
                                    t1.join();
                                    perfect = 0;
                                    good = 0;
                                    miss = 0;
                                    tooearly = 0;
                                    startTime = std::time(nullptr);
                                    break;
                                }
                                else if (y > 510 && y < 580&&x>610&&x<730) {
									gameplay = false;
                                    noods.resize(0);
                                    break;
								}
							}
                        }
                        SDL_DestroyTexture(pauseTexture);
                        demkey = 10;
                    }

                }
                else demkey--;
                //code for display result of nood be pressed
                if (demperfect > 0) {
                    demperfect--;
                    //thread to display result
                    thread t2([&renderer, perfectTexture,goodTexture,missTexture,tooearlyTexture,choice]() {
                        SDL_Rect destinationRect = { 430,550,200,250 };
                        if (choice == 0) SDL_RenderCopyEx(renderer, missTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
						else if (choice == 1) SDL_RenderCopyEx(renderer, tooearlyTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
						else if (choice == 2) SDL_RenderCopyEx(renderer, goodTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
						else if (choice == 3)
                        SDL_RenderCopyEx(renderer, perfectTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
                        });

                    t2.join();
                }
                //renderer gameplay
                SDL_RenderPresent(renderer);
              //control fps by and speed by variable speed
                SDL_Delay(speed);
               //check to end game
                if ((size(noods) == 0 || noods.back().check == false) && elapsedTime >= 271) {
                    Mix_HaltMusic();
                    //end music
                    Mix_Music* end = Mix_LoadMUS("music/end.mp3");
                    if (end == NULL) {
						printf("Failed to load music! SDL_mixer Error: %s\n", Mix_GetError());
						return 1;
					}
                    Mix_PlayMusic(end, 1);
                    SDL_Delay(400);
                    gameplay = false;
                    noods.resize(0);
                    //complete game and caculate point and display
                    SDL_Surface* complete0Surface = IMG_Load("Image/complete0.png");
                    SDL_Texture* complete0Texture = SDL_CreateTextureFromSurface(renderer, complete0Surface);
                    SDL_FreeSurface(complete0Surface);
                    SDL_Surface* complete1Surface = IMG_Load("Image/complete1.png");
                    SDL_Texture* complete1Texture = SDL_CreateTextureFromSurface(renderer, complete1Surface);
                    SDL_FreeSurface(complete1Surface);
                    SDL_Surface* complete2Surface = IMG_Load("Image/complete2.png");
                    SDL_Texture* complete2Texture = SDL_CreateTextureFromSurface(renderer, complete2Surface);
                    SDL_FreeSurface(complete2Surface);
                    SDL_Surface* complete3Surface = IMG_Load("Image/complete3.png");
                    SDL_Texture* complete3Texture = SDL_CreateTextureFromSurface(renderer, complete3Surface);
                    SDL_FreeSurface(complete3Surface);
                   int point=perfect*5+good*3;
                   float completionRate = (perfect*1.0 * 2 + good) / ((perfect + good + miss + tooearly) * 2);
                   destinationRect = {-10,0,1200,810 };
                   if (completionRate>0.8) {
						destinationRect = { -80,0,1200,810 };
						SDL_RenderCopyEx(renderer, complete3Texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
                       
					}
                   else if (completionRate>0.6) {
						
						SDL_RenderCopyEx(renderer, complete2Texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
					}
                   else if (completionRate>0.4) {
						
						SDL_RenderCopyEx(renderer, complete1Texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
					}
                   else {
						
						SDL_RenderCopyEx(renderer, complete0Texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
					}
                   //use ttf to write completed art
                   thread t3([&renderer, point, perfect, good, miss, tooearly]() {
                   TTF_Init();
                   TTF_Font* font = TTF_OpenFont("Front/font.ttf", 24);
                   SDL_Color color = { 255, 255, 0 };
                   SDL_Surface* surface;
                   SDL_Texture* texture;
                   SDL_Rect textRect;
                   if (miss + tooearly == 0 && good == 0) {
                       surface = TTF_RenderText_Solid(font, "So Amazing, You are perfect", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 210,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                   else if (miss + tooearly<0.05*(perfect+good+miss+tooearly) && good > 0 && good<0.2 * perfect) {
                       surface = TTF_RenderText_Solid(font, "Great,you're almost perfect", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 220,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                   else if ((good + perfect*2) > 0.8* (miss + tooearly + good + perfect)*2) {
                       surface = TTF_RenderText_Solid(font, "Good", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 450,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                   else if ( (good + perfect*2)> 0.6* (miss + tooearly + good + perfect)*2) {
                       surface = TTF_RenderText_Solid(font, "Not bad but you can better", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 240,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                   else {
                       surface = TTF_RenderText_Solid(font, "You need to practice more", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 230,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                    surface = TTF_RenderText_Solid(font, ("Your point is: " + to_string(point)).c_str(), color);
                    texture = SDL_CreateTextureFromSurface(renderer, surface);
                    textRect = { 325,400, surface->w, surface->h };
                   SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   surface = TTF_RenderText_Solid(font, ("Perfect: " + to_string(perfect)).c_str(), color);
                   texture = SDL_CreateTextureFromSurface(renderer, surface);
                   textRect = { 325,450, surface->w, surface->h };
                   SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   surface = TTF_RenderText_Solid(font, ("Good: " + to_string(good)).c_str(), color);
                   texture = SDL_CreateTextureFromSurface(renderer, surface);
                   textRect = { 325,500, surface->w, surface->h };
                   SDL_RenderCopy(renderer, texture, NULL, &textRect);  
                   surface = TTF_RenderText_Solid(font, ("Error: " + to_string(miss+tooearly)).c_str(), color);
                   texture = SDL_CreateTextureFromSurface(renderer, surface);
                    textRect = { 325,550, surface->w, surface->h };
                    SDL_RenderCopy(renderer, texture, NULL, &textRect);
					SDL_DestroyTexture(texture);
					SDL_FreeSurface(surface);
					TTF_CloseFont(font);
					TTF_Quit();
					});
					t3.join();
					SDL_RenderPresent(renderer);
                    //completed loop
                    while (true) {
						//check button be clicked
						SDL_PollEvent(&e);
                        if (e.type == SDL_MOUSEBUTTONDOWN) {
                            int x, y;
							SDL_GetMouseState(&x, &y);
							//replay button
                            if (x > 230&& x <400 && y > 620 && y < 800) {
                                gameplay = true;
                                noods.resize(0);
                                std::thread t1([&music]() {
                                    Mix_PlayMusic(music, -1);
                                    if (music == NULL) Mix_PlayMusic(music, -1);
                                    });
                                t1.join();
                                //time reset
                                startTime = std::time(nullptr);
                                perfect = 0;
                                good = 0;
                                miss = 0;
                                tooearly = 0;
                                break;
							}
                            //quit button
                            else if (x > 680 && x < 860 && y > 610 && y < 780) {
								noods.resize(0);
                                std::thread t1([&music]() {
									Mix_PlayMusic(music, -1);
									if (music == NULL) Mix_PlayMusic(music, -1);
									});
								t1.join();
								perfect = 0;
								good = 0;
								miss = 0;
								tooearly = 0;
                                SDL_DestroyTexture(backgroundTexture);
                                SDL_DestroyTexture(goodTexture);
                                SDL_DestroyTexture(missTexture);
                                SDL_DestroyTexture(perfectTexture);
                                SDL_DestroyTexture(tooearlyTexture);
								break;
							}
                           
						}
					}
                    SDL_DestroyTexture(complete0Texture);
                    SDL_DestroyTexture(complete1Texture);
                    SDL_DestroyTexture(complete2Texture);
                    SDL_DestroyTexture(complete3Texture);
                    Mix_FreeMusic(end);
                    
                }
                //check time
                cout << elapsedTime<< endl;
               
            }
            startTime = std::time(nullptr);
        }
        //close music
        Mix_FreeMusic(music);
       
    }

   
    // endgame
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();
    return 0;
}
¯OriginalContentÀªSelections¨FilePathÙMC:\Users\ttk08\OneDrive\Documents\GitHub\project\Project2\Project2\Source.cpp¨Language£C++‘’“¥Value ÙA#file:'Source.cpp'  tÃ´i muá»‘n báº¡n há»— trá»£ má»™t sá»‘ thá»©À¨Response…§ContentÙxTáº¥t nhiÃªn, tÃ´i sáº½ ráº¥t vui lÃ²ng giÃºp Ä‘á»¡. Báº¡n cáº§n há»— trá»£ vá» Ä‘iá»u gÃ¬ trong mÃ£ nguá»“n C++ nÃ y?¤Type ¦Status¯FollowUpPrompts’ÙBBáº¡n cáº§n giáº£i thÃ­ch vá» pháº§n nÃ o trong mÃ£ nguá»“n nÃ y?Ù@Báº¡n muá»‘n tÃ´i giÃºp sá»­a lá»—i nÃ o trong mÃ£ nguá»“n nÃ y?³CodeVulnerabilities…¨DateTime×ÿTCÇ eôÿ€ªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$27bc7c49-e4de-4a84-bf88-ec385e28f8c7Ù$3ab11e4f-8e50-4887-991f-406af6a77041‘†¯ProviderMoniker‚¤NameÙ6Microsoft.VisualStudio.Copilot.DocumentContextProvider§Version£0.1¦Member¤file©CanReduceÃ©RequestIdÙ$27bc7c49-e4de-4a84-bf88-ec385e28f8c7©Reference´#file:'longnood.png'¥ValueÈ~èdÙ‘Microsoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a…§ContentÚ}Âï¿½PNG

   IHDR     s   ï¿½eï¿½O    IDATxï¿½ï¿½}[ï¿½,Irï¿½ï¿½Gï¿½{{fHï¿½ï¿½B`vï¿½ï¿½Sï¿½Ú•ï¿½$@ï¿½ï¿½	ï¿½G 8ï¿½Pï¿½tßª7!ï¿½ï¿½ï¿½Ìª&ï¿½ï¿½lTï¿½zdFxï¿½ï¿½ï¿½ï¿½ï¿½ï¿½7ï¿½ï¿½ï¿½|ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½wï¿½7*ï¿½ï¿½ï¿½ï¿½_ï¿½Zï¿½ï¿½ï¿½ï¿½oï¿½ï¿½ï¿½o~ï¿½Kï¿½ï¿½ï¿½ï¿½Wï¿½Ë¶oï¿½ï¿½Mï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½wï¿½ï¿½"ï¿½ï¿½ï¿½oï¿½ï¿½`ï¿½ï¿½ï¿½ï¿½Ï¿{ï¿½×·ï¿½ï¿½ï¿½ï¿½Uï¿½mï¿½ï¿½ï¿½}ï¿½ï¿½ï¿½/ï¿½ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Cï¿½ï¿½ ï¿½ï¿½K7ï¿½fï¿½ï¿½4ï¿½ï¿½ï¿½m{ï¿½m3ï¿½z~ï¿½/TŞ¾oï¿½ï¿½O"?ï¿½ï¿½ï¿½ï¿½ï¿½!ï¿½~ï¿½ï¿½ï¿½ï¿½ï¿½}Sï¿½ï¿½/ï¿½ï¿½:ï¿½?/ï¿½Z1;ï¿½Åï¿½*ï¿½ï¿½ï¿½619ï¿½ï¿½ï¿½ï¿½ï¿½6Ù¿|ï¿½~ï¿½*ï¿½ï¿½Uï¿½ï¿½ï¿½ï¿½Û›ï¿½ï¿½}ï¿½ï¿½ï¿½}ï¿½ï¿½ï¿½ï¿½*_ï¿½ï¿½l[ï¿½f]ï¿½LTDï¿½Oï¿½ï¿½lMï¿½ï¿½ï¿½B]Dï¿½ï¿½ï¿½Oï¿½ï¿½yÓ·qÃ¯_|a_ï¿½ï¿½}ï¿½ï¿½Uï¿½×¶ï¿½4=ï¿½wï¿½Õnï¿½ï¿½ï¿½Mï¿½ï¿½ï¿½ï¿½sï¿½ï¿½5ï¿½.[{ï¿½ï¿½/]ï¿½|9ï¿½ï¿½ï¿½_Tï¿½~Sï¿½}ï¿½"ï¿½jï¿½Ojï¿½+<?ï¿½&me7<ï¿½ï¿½Î¯ï¿½:ï¿½Eï¿½Ë¶ï¿½ï¿½ï¿½ß¾ï¿½|ï¿½ï¿½ï¿½ï¿½Eï¿½mï¿½ï¿½gï¿½ï¿½aï¿½ï¿½ï¿½kï¿½ï¿½ï¿½zï¿½ï¿½ï¿½ï¿½Qï¿½ï¿½ï¿½ï¿½sï¿½ï¿½ï¿½"ï¿½ï¿½|ï¿½bï¿½ï¿½Iï¿½ï¿½ï¿½ILï¿½n]ï¿½ï¿½ï¿½_ï¿½ï¿½ï¿½ï¿½J?Tï¿½oï¿½ï¿½ï¿½ï¿½ï¿½=8?7.ï¿½Dï¿½/'IUÚ¾ï¿½ï¿½{ï¿½uï¿½ï¿½ï¿½ï¿½ï¿½ï¿½mï¿½ï¿½8ï¿½ï¿½qï¿½ï¿½Uï¿½pÊœï¿½sï¿½ï¿½uï¿½Î•ï¿½ï¿½ï¿½7ï¿½ï¿½mï¿½zï¿½E5ï¿½f<ï¿½ï¿½bv^tï¿½ï¿½\ï¿½ï¿½ï¿½ï¿½m|ï¿½ï¿½ï¿½9ï¿½ï¿½ï¿½xÛ¶&ï¿½ ï¿½dï¿½ï¿½ßŸï¿½ï¿½t|ï¿½tï¿½ï¿½8/ï¿½ï¿½ï¿½ï¿½"ï¿½ï¿½Çª'ï¿½ï¿½ï¿½ï¿½sï¿½~ï¿½ï¿½ï¿½ï¿½56ï¿½ï¿½7cuï¿½ï¿½rRaï¿½Ïœï¿½ï¿½Uï¿½ï¿½<ï¿½|ï¿½ï¿½ï¿½ï¿½>W86jï¿½È¼g<q^ï¿½Oï¿½<Yï¿½ï¿½ï¿½ï¿½c%s5ï¿½M,gï¿½ï¿½Iï¿½Mï¿½aï¿½ï¿½kï¿½ï¿½ï¿½ï¿½ï¿½xÄï¿½ï¿½ï¿½Mï¿½ï¿½aï¿½7v:ï¿½yï¿½ï¿½ ~aï¿½ï¿½9ï¿½æªœï¿½ï¿½ï¿½G$ï¿½Ú­iï¿½ï¿½wJï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½uVï¿½ï¿½kï¿½ï¿½ï¿½6ï¿½ï¿½V:hï¿½ï¿½uRÃœsï¿½qCï¿½pï¿½_ï¿½Ü¯ï¿½	ï¿½ï¿½ÆŸhï¿½'ï¿½ï¿½Yï¿½}mln2ï¿½ï¿½'ï¿½sï¿½ï¿½ï¿½ï¿½ï¿½Pï¿½có´¹†ï¿½*ï¿½ï¿½MÆ·ï¿½\ï¿½ï¿½ï¿½ï¿½]çµšJo[(oï¿½ï¿½Ñ·fï¿½RX!ï¿½@|ï¿½ï¿½gï¿½Xï¿½bï¿½*Wï¿½~ï¿½ï¿½ï¿½ï¿½ï¿½iï¿½_jï¿½ï¿½ï¿½Pï¿½Ø´Iï¿½ï¿½ï¿½ysï¿½7ï¿½Ó¹Bï¿½'ï¿½ï¿½ï¿½Sï¿½Lï¿½Bgï¿½ï¿½ofï¿½g'ï¿½oï¿½\È¨ï¿½ï¿½zÙ±ï¿½ï¿½ï¿½\ï¿½		ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½(ï¿½ï¿½uï¿½ï¿½ï¿½ï¿½)Tï¿½ï¿½kï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½e5ï¿½_SamNÎ¶ï¿½Qï¿½ï¿½Tï¿½ï¿½É¥Kï¿½ï¿½ï¿½]yï¿½ï¿½ï¿½ï¿½*}ï¿½qPPï¿½Ö¹ï¿½nï¿½ï¿½bï¿½ï¿½'ï¿½<N!ï¿½ï¿½ï¿½/Ş¸a1ï¿½ï¿½ï¿½Kï¿½Yï¿½ï¿½+t;ï¿½ï¿½Kï¿½ï¿½kX_>ï¿½=ï¿½W ï¿½~ï¿½]ï¿½4M>-:%ï¿½ï¿½\Zï¿½F~oï¿½ï¿½ï¿½/ï¿½ï¿½oï¿½ï¿½ï¿½ï¿½xï¿½.ï¿½|ï¿½.Û—ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½q<ï¿½ï¿½Oï¿½ï¿½?ï¿½É¿ï¿½Ë›ï¿½ï¿½ï¿½ï¿½ï¿½'ï¿½ï¿½ï¿½]ï¿½ ï¿½\ï¿½ï¿½eï¿½5hs&ï¿½Ğ²ï¿½ï¿½ï¿½$ï¿½ï¿½"ï¿½Tdï¿½?ï¿½ï¿½ï¿½ï¿½iï¿½ï¿½ï¿½ )ï¿½ï¿½ï¿½rï¿½Gï¿½ï¿½v{ï¿½zï¿½Am>ï¿½ï¿½ï¿½ï¿½wTiï¿½ï¿½Z#ï¿½ï¿½6ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä¾ï¿½3ï¿½ï¿½rï¿½ï¿½ï¿½Zï¿½EwgÚ™ï¿½ï¿½ï¿½ï¿½ï¿½6ï¿½ï¿½ï¿½Dï¿½ï¿½ï¿½ï¿½ï¿½'ï¿½@ï¿½&ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½~ï¿½Lï¿½vrï¿½ï¿½a:ï¿½ï¿½ï¿½nzMVï¿½ï¿½sï¿½0ï¿½ï¿½,9hï¿½Ö¶ï¿½Øœï¿½,ZÍ¥ï¿½ï¿½Ms%-Dï¿½Qï¿½_XÂ¼oï¿½ï¿½ï¿½W&ï¿½ï¿½'@rï¿½ï¿½:Mï¿½ï¿½jAï¿½ï¿½Hï¿½ï¿½ï¿½`ï¿½ï¿½H7ï¿½ï¿½ï¿½)ï¿½ï¿½6vï¿½Ô³ï¿½ï¿½ï¿½ï¿½{ï¿½ï¿½Nï¿½ï¿½ï¿½ï¿½Dï¿½ï¿½9oï¿½ï¿½vï¿½ï¿½ï¿½=ï¿½#ï¿½Dï¿½ï¿½$Uï¿½Oï¿½`Hï¿½ï¿½ï¿½sJ^ï¿½Cï¿½1]ï¿½ï¿½ï¿½ï¿½yï¿½Ç¿
ÈŠLm@\ï¿½Lbï¿½_ï¿½ï¿½Fn/={
ï¿½ITD\<ï¿½qï¿½%ï¿½ï¿½ï¿½(ï¿½Äªï¿½ï¿½S@ï¿½|lC@,Lï¿½ï¿½$ï¿½Ô…ï¿½bï¿½ï¿½$ï¿½U@6ï¿½ï¿½Ç›ï¿½Zï¿½ï¿½;! ï¿½ï¿½ï¿½"WQPï¿½XÙ»VDï¿½ï¿½(Lï¿½ï¿½ï¿½Rï¿½ï¿½Ê—ï¿½ï¿½ï¿½ï¿½{ï¿½qï¿½4ï¿½ï¿½{î¶³Zaï¿½ï¿½È‡ï¿½9g0ï¿½'ï¿½#bÒ¥ï¿½>Bï¿½0ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Cï¿½k
ï¿½ï¿½iï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Tï¿½2ï¿½ï¿½ï¿½$Ynï¿½ï¿½Kï¿½
ï¿½hï¿½ï¿½Aï¿½É†Wï¿½gï¿½ï¿½kï¿½]ï¿½ï¿½ï¿½+Tï¿½ï¿½; ï¿½Oï¿½ï¿½ï¿½
ï¿½:ï¿½ï¿½iRQï¿½<2&ï¿½ï¿½ï¿½(>ï¿½ï¿½ï¿½ï¿½4ï¿½ï¿½iï¿½Ue4ï¿½ï¿½ï¿½+\ï¿½gï¿½
ï¿½ï¿½ï¿½Iï¿½6ï¿½ï¿½ï¿½Uï¿½ï¿½@"ï¿½xlRV-;F"}Ò™Å—Eï¿½uvÚ¼0ï¿½ï¿½Ë©ï¿½Hï¿½X[ï¿½]6ï¿½z*ï¿½ï¿½ï¿½Uï¿½ï¿½ï¿½ï¿½b>6Eï¿½ï¿½bï¿½ï¿½Ü¯\ï¿½Ş¦ï¿½è–¼ï¿½lï¿½ï¿½ï¿½ï¿½qï¿½ï¿½ï¿½A
ï¿½*ï¿½ï¿½587ï¿½R
ï¿½Xï¿½;ï¿½sï¿½9Dï¿½ï¿½uï¿½ï¿½ï¿½cèŒ°yï¿½ï¿½ï¿½}ï¿½6NVï¿½SAHï¿½ï¿½:ï¿½{ï¿½)i$C7-;ï¿½ï¿½{ï¿½ğ«‘µ9H@ï¿½ï¿½pï¿½ï¿½ï¿½zï¿½ï¿½Xc>ï¿½Mï¿½^SAï¿½Wï¿½iï¿½Jï¿½49ï¿½&|ï¿½7],ï¿½Ê·ï¿½tï¿½ï¿½ï¿½.ï¿½ï¿½Nï¿½ï¿½ï¿½ï¿½ï¿½6Yï¿½
ï¿½,ï¿½g.ycï¿½Ó˜6ï¿½M%ï¿½Jï¿½6ï¿½	h#ï¿½]ß‚Fï¿½O7Zï¿½iï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½~ï¿½ï¿½ï¿½<ï¿½Sï¿½ï¿½W+ï¿½ï¿½$orï¿½ï¿½ï¿½(âˆï¿½ï¿½ï¿½mï¿½ï¿½ï¿½ï¿½ï¿½ï¿½7ï¿½ï¿½Cï¿½Cï¿½Tï¿½LWï¿½t@ï¿½$0ï¿½ï¿½,ï¿½Ú´ï¿½tï¿½ï¿½Sï¿½Dï¿½pï¿½sï¿½kï¿½ï¿½iLOï¿½ï¿½ï¿½ Nï¿½l^ï¿½ï¿½ï¿½ï¿½Ü£ï¿½"6Å»ï¿½ï¿½jmï¿½ï¿½m(o2LÎ¨ï¿½ï¿½ï¿½gï¿½&ï¿½ï¿½Û¼Tï¿½rï¿½ï¿½eï¿½Ü±ï¿½cÔ½&lï¿½ï¿½)?ï¿½Cï¿½ï¿½&ï¿½22ï¿½)2ï¿½Yï¿½ï¿½,Iï¿½Xï¿½Ê–<ï¿½ï¿½'dï¿½ï¿½ï¿½ï¿½tï¿½:ï¿½}ï¿½ï¿½eï¿½n"ï¿½ ï¿½|')4"ï¿½ï¿½Û‚ï¿½ï¿½ï¿½"Lï¿½ÄŸOï¿½ï¿½/ï¿½fï¿½+ï¿½ÌŠï¿½>ï¿½@.ï¿½
ï¿½jjï¿½ï¿½ï¿½ï¿½yï¿½]ï¿½Çƒï¿½ï¿½X=ï¿½ï¿½DYÕ’ï¿½dï¿½ï¿½Pï¿½Ü¤ï¿½ï¿½J/0ï¿½ï¿½(b 'ï¿½>Jï¿½Bï¿½ï¿½/ï¿½ï¿½Nï¿½ï¿½ï¿½4Iï¿½Zï¿½ï¿½ï¿½ï¿½`/ï¿½ï¿½\ï¿½ï¿½B1ï¿½ï¿½ï¿½fï¿½8ï¿½ï¿½}ï¿½ï¿½-ï¿½ï¿½kxWï¿½Sï¿½ï¿½pf&Qï¿½ï¿½n$/W<Hï¿½ÔBï¿½S	99ï¿½ï¿½ï¿½3!Pï¿½$ï¿½ï¿½ï¿½:.vï¿½ï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½ï¿½Wï¿½ï¿½[fï¿½ï¿½ï¿½ï¿½ï¿½\ï¿½bgï¿½È­	Iß¤s3A^t"ï¿½
ï¿½S~F
)ï¿½ï¿½>cBeï¿½ï¿½ï¿½ï¿½ï¿½sï¿½@ï¿½ï¿½ê€¯ï¿½ï¿½ï¿½ï¿½Úwhï¿½bï¿½ï¿½ï¿½3ï¿½ï¿½Aï¿½<ï¿½ï¿½"yï¿½vASï¿½z
|ï¿½ï¿½ï¿½1ï¿½-ï¿½_|ï¿½IÃ¥zxï¿½Û´}H@+Dï¿½"dï¿½ÒŸ_-ï¿½ï¿½F"ï¿½ï¿½8!h=ï¿½ï¿½fAï¿½PBï¿½ï¿½bL[Cï¿½ï¿½Y>ï¿½ï¿½ï¿½ï¿½Rï¿½qï¿½ï¿½ï¿½ÅTï¿½zqï¿½Lï¿½2ï¿½ï¿½ï¿½NJï¿½ï¿½Î„}ï¿½gJ1ï¿½`!RÃ˜ï¿½F(!ï¿½4Gï¿½gï¿½+Fï¿½Q\?YßŠÌ¢ï¿½çï¿½=ï¿½=pï¿½;<gï¿½&Wï¿½fQï¿½2ï¿½6ï¿½ï¿½l
ï¿½1ï¿½ï¿½0ï¿½Ø†ï¿½ï¿½ *ï¿½Pï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½h7ï¿½ï¿½yLï¿½Tï¿½ï¿½ï¿½ï¿½Cï¿½ï¿½;ï¿½ï¿½ï¿½ã»>ï¿½@uï¿½{ï¿½ï¿½-ï¿½Ùï¿½ï¿½ï¿½AS)ï¿½ï¿½ï¿½ï¿½1ï¿½S1ï¿½ï¿½ï¿½
ï¿½<ï¿½"yï¿½ï¿½ï¿½Úšoï¿½ï¿½ï¿½Tï¿½ï¿½Rï¿½ Eï¿½b7#ï¿½iï¿½ï¿½?Uï¿½|&&ï¿½ï¿½Í©ï¿½ï¿½ï¿½-ï¿½ï¿½Èƒï¿½eï¿½ï¿½ï¿½$ï¿½]Aï¿½ï¿½yï¿½bBUï¿½ï¿½iï¿½Dï¿½mzï¿½ï¿½ï¿½/bï¿½	ï¿½hï¿½yï¿½Â¼r#yï¿½ï¿½ï¿½ï¿½ï¿½(-ï¿½W^ï¿½ï¿½o)qï¿½ï¿½GcOï¿½ï¿½gï¿½Eï¿½[ï¿½aï¿½İ›ï¿½ï¿½6oï¿½<l"ï¿½Oï¿½ï¿½"ï¿½Ğ˜ï¿½($ï¿½'Ä¼ï¿½@ï¿½ï¿½ï¿½ï¿½ï¿½/Aï¿½ï¿½J^ï¿½ï¿½kï¿½ï¿½iFï¿½.ï¿½+ï¿½6]Avï¿½|ï¿½ï¿½é¬¹ï¿½ï¿½Ü¥+ï¿½ï¿½ï¿½+Òï¿½ï¿½ï¿½@:^.|ï¿½ï¿½ï¿½:ï¿½F6ï¿½cï¿½Bï¿½~ï¿½c#>NSï¿½'ï¿½ï¿½Dbï¿½ï¿½bAï¿½ï¿½ï¿½t+ï¿½ï¿½A6ï¿½ï¿½~ï¿½ï¿½ï¿½X0ï¿½Dï¿½ï¿½bï¿½N
ï¿½ï¿½8ï¿½áŠ‡fï¿½ï¿½ï¿½ï¿½ï¿½.jï¿½ï¿½]nÓ´ï¿½ï¿½R,ï¿½ßŸï¿½6!yï¿½btJï¿½ï¿½ï¿½Bï¿½òšˆ®ï¿½fï¿½.ï¿½Oï¿½_ï¿½a`ï¿½ï¿½ @*mï¿½g qï¿½ï¿½ï¿½pï¿½bqï¿½ï¿½ï¿½ï¿½ï¿½gï¿½gï¿½?ï¿½ï¿½ï¿½ï¿½B~Y@!ï¿½ï¿½ï¿½<ï¿½ï¿½ï¿½bï¿½ï¿½Vï¿½ï¿½ï¿½Äï¿½ï¿½"ï¿½R@aï¿½ï¿½ï¿½P(ï¿½Bï¿½ï¿½ç»ºï¿½Ì¨Uï¿½'(ï¿½ibPï¿½:Oï¿½"ï¿½ï¿½IDï¿½ï¿½ï¿½6ï¿½ï¿½+qxLï¿½ï¿½!hï¿½)z<ï¿½Û¼ï¿½rï¿½ï¿½İ±!sï¿½ï¿½		.ï¿½ï¿½Xn.ï¿½ï¿½ï¿½{ï¿½Gï¿½ï¿½ï¿½ï¿½ï¿½{r@{ï¿½Icï¿½p:d\`dï¿½ï¿½ï¿½zï¿½ï¿½ï¿½	cï¿½alÍ³ï¿½Nï¿½ï¿½ï¿½|ï¿½yï¿½ï¿½vï¿½6a=ï¿½F@ï¿½ï¿½cï¿½\*ï¿½v&jï¿½ yï¿½#.Û¬,KR#ï¿½ï¿½Rï¿½ï¿½ï¿½dï¿½;~ï¿½z>ï¿½H/ï¿½ï¿½ï¿½ï¿½$ï¿½hï¿½@ÆµCï¿½:Å™WPï¿½Dï¿½zï¿½Ö‹1Mï¿½.ï¿½1ï¿½ï¿½Hï¿½k~%ï¿½ï¿½ï¿½"y"7ï¿½Xï¿½+vï¿½ï¿½ï¿½U0ï¿½Ğï¿½ï¿½Fï¿½0ï¿½QJï¿½(Cï¿½â¸7&ï¿½ï¿½ï¿½qw,.fWÉ›ï¿½ï¿½LWXï¿½İ¼ï¿½]Ö ï¿½dï¿½ï¿½ï¿½lŞ©#Î¸ï¿½ï¿½ï¿½ï¿½ï¿½tï¿½%ï¿½ï¿½Rï¿½x'
|<+Ç†ï¿½hï¿½Q<ï¿½ï¿½ï¿½=ï¿½ï¿½
Fï¿½Eï¿½Rï¿½lzï¿½ï¿½W(ï¿½ZDï¿½mIï¿½ï¿½jï¿½ï¿½ï¿½ï¿½dLï¿½'ï¿½ï¿½A
ï¿½dï¿½ï¿½Ê¾4v4}eï¿½ï¿½ï¿½x}N#ï¿½ï¿½w.ï¿½ï¿½ï¿½kï¿½Jï¿½-6oï¿½0ï¿½r3ï¿½ANï¿½!ï¿½	ï¿½ï¿½ï¿½Haï¿½ì²‰Zï¿½ï¿½ï¿½ï¿½/Pï¿½dZİ±ï¿½ypJï¿½ ï¿½ï¿½ `pÎƒï¿½ï¿½.ï¿½ï¿½Vï¿½ï¿½ï¿½]ï¿½;,ï¿½ï¿½ï¿½fZï¿½jPï¿½lï¿½ï¿½-{ï¿½ï¿½ï¿½ï¿½ß–ï¿½	ï¿½0D:İ«ï¿½ï¿½Ñˆiï¿½ï¿½xï¿½W'+%ï¿½	bï¿½ï¿½ï¿½Vbï¿½z8ï¿½ï¿½ï¿½h/ŞŠï¿½ï¿½ï¿½0Ó¾ï¿½ ï¿½+vcï¿½ï¿½cZï¿½ï¿½=4ï¿½9ï¿½'ï¿½ï¿½ï¿½ï¿½ï¿½!ï¿½ï¿½l:ï¿½m<WPï¿½'ï¿½ï¿½ï¿½$ï¿½ï¿½ï¿½~ ï¿½caï¿½UYï¿½ï¿½
Hvï¿½<ï¿½ï¿½z"ï¿½<_ï¿½Û¢ï¿½ï¿½5Ê¦ï¿½ï¿½hï¿½ï¿½Tj8ï¿½`hï¿½ï¿½X'ï¿½ï¿½3R%j$@aï¿½jï¿½0ï¿½!ï¿½pï¿½ï¿½ï¿½}7kï¿½|ï¿½_ï¿½ï¿½_ï¿½ï¿½KN:<ï¿½v/5ï¿½4ï¿½1ï¿½ï¿½zO;6Xï¿½ï¿½`ï¿½ï¿½dqfï¿½iï¿½a2,Ã‚,yï¿½"ï¿½ï¿½5Qï¿½r^ï¿½
bï¿½$r&=8ï¿½ï¿½tï¿½ï¿½Bï¿½l $/ï¿½EÜ¤ï¿½ï¿½ï¿½B/ï¿½Xï¿½ï¿½ï¿½Tï¿½L%É‹\4ï¿½hï¿½ï¿½=ï¿½ï¿½Vï¿½ï¿½rï¿½*ï¿½ï¿½zORï¿½ï¿½ï¿½ï¿½(&wï¿½]pï¿½rÚ¼ï¿½ï¿½Ï™Ïƒï¿½ï¿½ï¿½nwï¿½ï¿½ï¿½ï¿½!#ï¿½ï¿½Qï¿½Iï¿½uï¿½ï¿½ï¿½U012=ï¿½ï¿½,{V(2ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä^ï¿½Sï¿½ï¿½ï¿½ÅÛ‚oQï¿½7ï¿½ï¿½!ï¿½KFï¿½!zï¿½ï¿½4<7ï¿½ï¿½ï¿½PcÌ®ï¿½ï¿½ï¿½&~ï¿½ï¿½aï¿½%ï¿½mX Ë‹ï¿½ï¿½ï¿½ZĞ”:3U$ï¿½ï¿½Xï¿½sï¿½ï¿½ï¿½ï¿½ï¿½[`,ï¿½H_BKï¿½ï¿½ï¿½ï¿½|^UBï¿½Fï¿½Vï¿½5ï¿½Iwï¿½!-d&Kdï¿½ï¿½D7:ï¿½Ï”Pï¿½Ø‰z&P1ï¿½?ï¿½w3cï¿½*ï¿½Xï¿½Ewï¿½dCVï¿½ï¿½Ğ’ï¿½Óµï¿½ï¿½ï¿½tï¿½ï¿½Qï¿½ï¿½8kXï¿½ï¿½ï¿½.ï¿½ï¿½<ï¿½*t#Tï¿½-0ï¿½#ï¿½ï¿½f7ï¿½gÓ•ï¿½"Jï¿½dï¿½ï¿½ï¿½ï¿½ï¿½sï¿½@{ï¿½ï¿½'ï¿½ï¿½ï¿½ï¿½Ypï¿½Ù¯drï¿½bLï¿½ï¿½ï¿½Ñ½Qï¿½gï¿½6>ï¿½\_ï¿½xFAï¿½[+=ï¿½<ï¿½5Ş¤,"ï¿½rÂ„Rwï¿½, ï¿½yaï¿½ï¿½ )#,ï¿½&ï¿½K%ï¿½ï¿½ ]K]ï¿½ï¿½'ï¿½+ï¿½ï¿½hYjmYï¿½ï¿½ï¿½aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ú¥ï¿½(ï¿½vï¿½ï¿½ï¿½ lï¿½.Ä˜)hï¿½ï¿½&ï¿½6ï¿½ï¿½JSgP3jï¿½ï¿½æ¤–ï¿½$H)ï¿½Û·ï¿½ï¿½ï¿½Iï¿½3ï¿½í…¡]cCï¿½ï¿½ï¿½ï¿½<ï¿½è®€ï¿½ï¿½ï¿½mï¿½ï¿½Bï¿½Ewï¿½vkï¿½	ï¿½ï¿½ï¿½ï¿½>6ï¿½?EÂ»ï¿½aï¿½
ï¿½)ï¿½Mï¿½%Oï¿½DXï¿½rï¿½ï¿½ï¿½ï¿½'yï¿½eA ï¿½ï¿½.yï¿½zOï¿½WAXï¿½zï¿½<ß¼)yÛœï¿½ï¿½ï¿½ï¿½ï¿½\Waï¿½ï¿½4m7ï¿½gï¿½ï¿½ï¿½ï¿½ï¿½ï¿½yï¿½ï¿½ï¿½Ø¯$Oï¿½ï¿½xeï¿½Nï¿½(iOï¿½ï¿½ï¿½Inï¿½wï¿½Kï¿½dï¿½ï¿½cXï¿½×‹bï¿½ï¿½Zjï¿½ï¿½ï¿½+ï¿½<ï¿½0Mï¿½ï¿½gfwï¿½ï¿½ï¿½v?ï¿½ï¿½ï¿½cï¿½ï¿½5ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½>Bï¿½ï¿½Qï¿½1ï¿½D"ï¿½ï¿½mï¿½<ï¿½n)ï¿½@|9EGï¿½ï¿½È…tg.vf|ï¿½Ê¼Cï¿½U"ï¿½ï¿½o*ï¿½ï¿½ï¿½	*\ï¿½{)y=ï¿½ï¿½*yï¿½^ï¿½v'y^+ï¿½gï¿½ï¿½Ä£ï¿½ï¿½kï¿½ï¿½ï¿½Pï¿½ï¿½ï¿½ï¿½tï¿½%[<SL*ï¿½-ï¿½ï¿½ï¿½Zï¿½ï¿½o-k3ï¿½ï¿½2.Ô¶ï¿½ï¿½A\w\ï¿½eeï¿½,2&Tï¿½~Ì·ï¿½e&ï¿½ï¿½`~ï¿½ï¿½@ï¿½=ï¿½Vï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½^ï¿½*Wè–ï¿½ï¿½ï¿½&]fï¿½ï¿½mï¿½6ï¿½ï¿½ï¿½jFYKrQï¿½~$ï¿½ï¿½Qï¿½ï¿½ï¿½0ï¿½(xYFï¿½ï¿½H,c&ï¿½Ï™qï¿½ï¿½ï¿½×‰gï¿½ï¿½ï¿½ï¿½X4ï¿½	96uï¿½ï¿½Kï¿½)ï¿½$-ï¿½%"'ï¿½lE0ï¿½_!qï¿½Ä…ï¿½Uï¿½xï¿½)ï¿½Y2ï¿½Í’ï¿½0ï¿½|<ï¿½ï¿½ï¿½ï¿½ï¿½'ï¿½TÆ„ï¿½ï¿½MZï¿½uï¿½fLï¿½4ï¿½ï¿½ï¿½ï¿½7ï¿½yï¿½'ï¿½8Æ„(ï¿½Ion@ï¿½Ú¦ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½/G<A~ï¿½rï¿½"-tï¿½ï¿½Kï¿½FSï¿½(lï¿½ï¿½5!ï¿½>k)2É’ï¿½ï¿½zï¿½uï¿½ï¿½4Mï¿½Sï¿½oï¿½ï¿½-W4:eï¿½ï¿½ï¿½,J\Aï¿½ï¿½Ù±Lï¿½Fï¿½.C4ï¿½rï¿½ï¿½5ï¿½ï¿½" ï¿½,å•¢ï¿½È)%sï¿½bA(ï¿½Yï¿½Õ“ï¿½tXï¿½6ï¿½â¬·ï¿½Wzï¿½ï¿½ï¿½rï¿½bAï¿½Yï¿½vï¿½"ï¿½f9ï¿½ï¿½ï¿½ï¿½4ï¿½ï¿½zEÖ¬ï¿½Kï¿½ï¿½ï¿½ï¿½7ï¿½ï¿½ï¿½ï¿½tnXï¿½Q#Ù¨ï¿½ï¿½jï¿½ï¿½tï¿½Ô¦zï¿½yï¿½Xï¿½ï¿½.ï¿½ï¿½ï¿½ï¿½ï¿½%ï¿½ï¿½(æ´¹ï¿½@$ï¿½ï¿½mYï¿½ï¿½ï¿½;ï¿½ï¿½&ï¿½ï¿½!yV?ï¿½Ø$o+ï¿½ï¿½Iï¿½bï¿½ï¿½ï¿½Í³
Emï¿½~ï¿½ï¿½uï¿½n g.bï¿½ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½5ï¿½ï¿½<RB!yï¿½ï¿½ï¿½ï¿½xï¿½W5,ï¿½ï¿½Yï¿½ï¿½F'7ï¿½7Ù
ï¿½Yï¿½ï¿½ï¿½ï¿½Iï¿½ ï¿½THï¿½#ï¿½kï¿½ï¿½ï¿½cï¿½ï¿½ETï¿½-zï¿½pYï¿½ï¿½+ï¿½ï¿½1ï¿½Nï¿½Ibï¿½	ï¿½[ï¿½çƒŠï¿½Wzï¿½ï¿½ï¿½ï¿½fï¿½GÌ-ï¿½1ï¿½ï¿½qXï¿½1ï¿½$Dï¿½]ï¿½ ï¿½ï¿½Ò”ï¿½8ï¿½ï¿½Mï¿½ï¿½ï¿½D]ï¿½<ï¿½ï¿½D@ï¿½tKï¿½:Ş»[T}ï¿½|Şœï¿½ï¿½fï¿½ï¿½Rï¿½aIï¿½\Z
ï¿½Í›ï¿½<ï¿½nï¿½ï¿½Cï¿½2ï¿½:ï¿½(ï¿½E4Xï¿½Ù§ï¿½ï¿½Haï¿½BÓ²ï¿½ï¿½ï¿½lG)ï¿½ï¿½ï¿½SxMï¿½cLï¿½Qï¿½ï¿½iz)tï¿½Gouï¿½cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½c7-ï¿½Ğzï¿½ï¿½bï¿½ÜŒVï¿½'#ï¿½ï¿½xyï¿½#ï¿½iï¿½ï¿½ï¿½ï¿½ï¿½ï¿½{ï¿½ï¿½Oï¿½ï¿½Tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½yÜšï¿½tnï¿½ï¿½ï¿½ï¿½|ï¿½R Ë˜ï¿½ï¿½ï¿½ï¿½5ï¿½:ï¿½Qï¿½ï¿½TJQï¿½ixÌ„,uï¿½?Eï¿½\ï¿½ï¿½ï¿½ï¿½Û‚ï¿½2ï¿½ï¿½4ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½h:h ï¿½ï¿½ï¿½ï¿½ï¿½$ï¿½0ï¿½"ï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½tAï¿½s(ï¿½
8cï¿½ï¿½Eï¿½<%oï¿½_ï¿½ï¿½J3>vsKï¿½ï¿½ï¿½ï¿½ï©•Æ“8)Ì‹\L1ï¿½b2ï¿½Uï¿½ï¿½R:ï¿½2ï¿½ï¿½ï¿½RF`oKnhï¿½ï¿½kï¿½`ï¿½!:Í£-XB/G_Sï¿½0ï¿½ï¿½Uxï¿½Å›ï¿½ï¿½ï¿½ï¿½ï¿½0/ï¿½kï¿½%ï¿½*ï¿½ï¿½Uï¿½ï¿½"/=ï¿½ï¿½eï¿½E	ï¿½ï¿½yYvÒ•ï¿½ï¿½ï¿½?ï¿½ï¿½*W'*Uï¿½(!Xï¿½&ï¿½6k$ï¿½ï¿½`|ï¿½ï¿½<'"ï¿½ ï¿½ï¿½jSï¿½wï¿½mRï¿½}ï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½	sï¿½{ï¿½eï¿½ï¿½ï¿½p.	dE{ï¿½Gï¿½u3Cï¿½ï¿½zï¿½i<4ï¿½~X	:,9Ó‘Lï¿½ï¿½Ù‰ï¿½|^ï¿½Y/ï¿½%*ï¿½ï¿½hZ,.ï¿½feï¿½}ï¿½ï¿½rwoï¿½)ï¿½\ï¿½^ï¿½ï¿½D:A?ï¿½ï¿½t)wï¿½ï¿½ï¿½Eï¿½ï¿½)-1ï¿½BtWï¿½ï¿½ï¿½ï¿½hï¿½+`ï¿½ï¿½ï¿½ï¿½\tï¿½ t sjsÖ´ï¿½UWï¿½_ï¿½+ï¿½nï¿½ï¿½ï¿½Ü¤ï¿½ï¿½ï¿½ï¿½T+Xï¿½-ï¿½ï¿½ï¿½ä‘®ï¿½ï¿½ï¿½hï¿½ï¿½ï¿½viï¿½ï¿½W#ï¿½|ï¿½aï¿½g)!Ê™F`ï¿½ï¿½ï¿½5ï¿½ï¿½\ï¿½1ï¿½ï¿½224_T+dï¿½Dï¿½ï¿½ï¿½"ï¿½ï¿½ï¿½ï¿½,ï¿½ï¿½ï¿½ï¿½Ì™ï¿½ï¿½Ù†Fï¿½Ã¿wï¿½3Mï¿½Zï¿½ï¿½ï¿½ZMVÉƒoï¿½
:Wrï¿½ï¿½ï¿½@ï¿½ï¿½ï¿½<zï¿½h2ï¿½ï¿½pï¿½ï¿½&	Cï¿½Ê¸ï¿½ï¿½E,yWï¿½ï¿½ï¿½ï¿½wdjSr?ï¿½ï¿½#ï¿½Ol^J#_ï¿½Ç½ï¿½`i4a\ï¿½ï¿½cWï¿½ï¿½Aï¿½=ï¿½tLï¿½ï¿½d É»ï¿½l\ï¿½wï¿½ï¿½Iwï¿½ï¿½3^Xï¿½oï¿½ï¿½*ï¿½\Jï¿½ï¿½ï¿½xaï¿½ï¿½odï¿½tï¿½<ï¿½ï¿½ï¿½ ï¿½bï¿½ï¿½U8ï¿½ï¿½[ï¿½rï¿½bï¿½cï¿½yF8ï¿½ .ï¿½\æ»~ï¿½fiï¿½ï¿½Cï¿½`ï¿½fï¿½Rï¿½ï¿½$ï¿½ï¿½iï¿½ï¿½ï¿½sï¿½ï¿½ï¿½ï¿½ï¿½wï¿½tï¿½ï¿½dpï¿½ï¿½ï¿½/ï¿½ï¿½ï¿½ï¿½pï¿½7{ï¿½ï¿½Ä×ï¿½6ï¿½ï¿½ï¿½<zï¿½ï¿½[É“ï¿½<ï¿½ï¿½ï¿½O$ï¿½
ï¿½g$Oï¿½ï¿½ï¿½}ï¿½Eï¿½ï¿½ï¿½ï¿½iï¿½O$Oï¿½ï¿½]lï¿½*yï¿½H^ï¿½yï¿½Zï¿½yï¿½ï¿½ï¿½bï¿½ï¿½ï¿½Ú¼;ï¿½ï¿½ï¿½<Dï¿½Mï¿½ï¿½ï¿½ï¿½ï¿½rï¿½ï¿½ï¿½ï¿½Iï¿½ï¿½Fï¿½Pï¿½4Eï¿½9ï¿½YAYï¿½ï¿½ï¿½ï¿½aï¿½ï¿½"yï¿½ÉŠfï¿½ï¿½	ï¿½+oï¿½ï¿½r(ï¿½ï¿½ÌŠï¿½ï¿½%yyï¿½ï¿½ï¿½<ï¿½oï¿½<ï¿½SJŞ½ï¿½ï¿½ï¿½ï¿½ï¿½[ï¿½ï¿½~ï¿½Ï•ï¿½Hï¿½Tï¿½ï¿½
ï¿½~ï¿½æ‘ŸG\ï¿½ï¿½Mï¿½~^aï¿½{ï¿½ï¿½Ï¶ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½W6O
+ï¿½/ï¿½@ï¿½ï¿½Cï¿½ï¿½ï¿½yï¿½ï¿½^Mxï¿½Zï¿½9ï¿½Fï¿½ï¿½9ï¿½<ï¿½mï¿½jï¿½ï¿½
ï¿½ï¿½eÅ6ï¿½ï¿½gï¿½A?o	ï¿½ï¿½ï¿½ï¿½ï¿½qï¿½ï¿½Zï¿½ï¿½vï¿½ï¿½ÙŸï¿½Ï£ï¿½È¿ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½~ï¿½ï¿½ï¿½ï¿½ï¿½#Ï”ï¿½ï¿½ï¿½ï¿½Jï¿½ï¿½0Z5ï¿½GH`ï¿½W~ï¿½|,(ï¿½Lï¿½E ï¿½gï¿½iHï¿½ï¿½ï¿½ï¿½ï¿½ç¥¹rP~dï¿½~ï¿½eFÈï¿½WoZPï¿½C3%D~Şï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ò¼zFXÚƒÎ®ï¿½HQï¿½2ï¿½~^ï¿½Cï¿½ï¿½ï¿½qï¿½Ã€ï¿½	Yç¬›ï¿½cï¿½@ï¿½nï¿½4kï¿½ï¿½U?oï¿½4ï¿½~ï¿½y4,Uï¿½ï¿½ï¿½2ï¿½ï¿½~^ï¿½ï¿½ï¿½ï¿½gï¿½ï¿½ï¿½K?ï¦„ï¿½Vï¿½ï¿½ï¿½Ù¼ï¿½ï¿½ï¿½ï¿½6ï¿½ï¿½y&ï¿½.ï¿½nï¿½3ï¿½n,ï¿½ï¿½Â’ï¿½q	ï¿½\ï¿½ï¿½ï¿½"ï¿½xï¿½ï¿½]ï¿½.$[ï¿½azï¿½ï¿½aï¿½_
ï¿½(`ï¿½}ï¿½ï¿½63ï¿½ï¿½3?Xï¿½8ï¿½Qï¿½Vï¿½Ú¡goï¿½:ï¿½ß¹ï¿½ï¿½7+ï¿½`kÍ·%ï¿½gï¿½Fï¿½ï¿½ï¿½Lï¿½+ï¿½Aï¿½Zï¿½rï¿½%ï¿½ï¿½"fï¿½ï¿½ï¿½Hï¿½uï¿½ï¿½ï¿½ï¿½ï¿½+ï¿½ï¿½ï¿½2ØŸMx|KQlï¿½fY_ï¿½ï¿½ï¿½ï¿½ï¿½iï¿½ï¿½7nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Vï¿½ï¿½4d>[bf-F{.ï¿½sï¿½s!kï¿½=,ï¿½>ï¿½ï¿½ï¿½|ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½^yï¿½ï¿½ï¿½ï¿½`mË‚{ï¿½+Ü§Kï¿½ï¿½Bï¿½ï¿½_ï¿½mï¿½ï¿½
Rï¿½Ì¦ï¿½84ï¿½ï¿½(Õ¼+Ï”yï¿½ï¿½(ï¿½;ï¿½9ï¿½Iï¿½bï¿½Yï¿½ï¿½.ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½ï¿½sÃ¹!ï¿½ï¿½wà¶£}ï¿½:)ï¿½ï¿½ï¿½g0@ï¿½ï¿½bEï¿½ï¿½ï¿½wï¿½ITMï¿½wï¿½
ï¿½Mï¿½Jï¿½Xï¿½%ï¿½ï¿½<ï¿½ï¿½@ï¿½Pï¿½jï¿½ï¿½Sï¿½'+]ï¿½E9IDÕ¼pï¿½9quQï¿½Q^%ï¿½Eï¿½6ï¿½7Uï¿½ï¿½hbï¿½iî¥‘ï¿½ï¿½1#ï¿½ï¿½ï¿½ï¿½,C=ï¿½Xyï¿½izOï¿½ï¿½ï¿½ï¿½ï¿½\+K\8+f%ï¿½ï¿½9>ï¿½*ï¿½ï¿½ï¿½uï¿½ÉŠmï¿½aEï¿½+ï¿½@;YFï¿½dï¿½ï¿½ß¤ï¿½ï¿½ï¿½ï¿½Aï¿½&ï¿½ËSAï¿½<ï¿½ï¿½vï¿½ï¿½ï¿½<Lï¿½ï¿½[ï¿½ï¿½ï¿½ï¿½(\ï¿½ï¿½ï¿½ï¿½8ï¿½ï¿½ï¿½w3.o-ï¿½=rï¿½1Aï¿½ï¿½ï¿½ï¿½+Xqï¿½\ï¿½3ï¿½tï¿½Fï¿½Tpzï¿½ï¿½Mbï¿½xï¿½UM#tCï¿½Ğï¿½Lï¿½Sï¿½ï¿½_$/\ï¿½ï¿½ï¿½ï¿½Ñ¤ï¿½/15ï¿½058ï¿½Gï¿½ï¿½ï¿½ï¿½BÍ•ï¿½ï¿½${ï¿½/1ï¿½ï¿½ï¿½ï¿½ï¿½Pï¿½ï¿½ï¿½Å„Tï¿½bÅ—GWï¿½Mï¿½Dï¿½=ï¿½ï¿½Óï¿½Ãï¿½ï¿½+ï¿½*yï¿½ï¿½
>ï¿½ï¿½mp8ï¿½ï¿½Iï¿½:ï¿½Fï¿½ï¿½Gï¿½jï¿½ï¿½maYZï¿½ï¿½ï¿½ï¿½ï¿½sï¿½eï¿½7~^DQï¿½ 	ï¿½ï¿½ï¿½ï¿½ï¿½WÛ“ï¿½Dï¿½İ‘nï¿½:Çï¿½>ï¿½[0ï¿½;ï¿½ï¿½sï¿½oVï¿½ï¿½ï¿½8!ï¿½ï¿½ï¿½qï¿½%ï¿½gQï¿½ï¿½ï¿½gï¿½rCï¿½)Hï¿½ï¿½>Cï¿½ZMï¿½ï¿½>(VCï¿½ï¿½YÃ¨ï¿½ï¿½*ï¿½1`$]edcï¿½ï¿½ï¿½ï¿½ï¿½pï¿½gï¿½LB@xï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½GV/ï¿½
\W",ï¿½ï¿½ï¿½ï¿½.ï¿½Ç­@(ÅŸÎ¤ï¿½&gslsÍ¤ï¿½ï¿½O#,Eï¿½`ï¿½ï¿½Akï¿½^ï¿½ï¿½ï¿½5Â²FcIï¿½Jlsï¿½ï¿½JKï¿½ï¿½b--ï¿½xwï¿½<[mŞ”ï¿½ï¿½mvï¿½xÉ¤gï¿½#ï¿½^ï¿½<Ê¤ï¿½ï¿½ï¿½yï¿½ï¿½5yÔï¿½6ï¿½cï¿½ï¿½2ï¿½{ï¿½ï¿½)eï¿½ï¿½$/1ï¿½ï¿½GÚŠeï¿½ï¿½-ï¿½ï¿½^ï¿½ï¿½6WhTï¿½R$ORï¿½hï¿½Iï¿½nï¿½ï¿½uï¿½ï¿½ï¿½i2jHï¿½ ,ï¿½<=ï¿½ï¿½Eï¿½nï¿½5&$Ol^
vï¿½Bï¿½ï¿½,ï¿½ï¿½ï¿½"yï¿½ï¿½ï¿½Uï¿½Ê°ÔŸ+yï¿½%ï¿½<ï¿½ï¿½J\Ş¨aï¿½6ï¿½Nï¿½.Vï¿½ï¿½Mï¿½yï¿½ï¿½eï¿½5ï¿½ï¿½aï¿½ï¿½Mï¿½ï¿½ï¿½6ï¿½ï¿½ï¿½Eï¿½ï¿½tï¿½mï¿½ï¿½ï¿½Ó‘ï¿½ï¿½ï¿½ï¿½]ï¿½%uï¿½ï¿½ï¿½wuï¿½ï¿½yï¿½ï¿½1.%KŞ«ï¿½ï¿½#<ï¿½aï¿½ï¿½ï¿½ÓŒ    IDATï¿½^ï¿½ï¿½"9ï¿½D"ï¿½\(aï¿½ï¿½ï¿½aï¿½
ï¿½ï¿½ï¿½ï¿½Uï¿½ï¿½ï¿½ï¿½rï¿½_ï¿½ï¿½8ï¿½Cï¿½D&fuW
! ï¿½%ï¿½T:ï¿½ï¿½ï¿½I&]ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½e7Ş“7ï¿½Lï¿½ß–ï¿½ï¿½Ì²?ï¿½İ£ï¿½ï¿½1ï¿½^É¤ï¿½×´(ï¿½ï¿½ï¿½uï¿½ï¿½ï¿½ï¿½ï¿½$ ï¿½ï¿½ï¿½t>vï¿½c@/3ÚŒï¿½ï¿½ï¿½tï¿½[rï¿½ï¿½ï¿½ï¿½ï¿½5mï¿½9Eï¿½ÈŸï¿½ï¿½eï¿½*P4ï¿½%ï¿½7ï¿½ï¿½ï¿½ï¿½ï¿½Kï¿½ï¿½Y&ï¿½ï¿½kï¿½ï¿½ï¿½dEVï¿½ï¿½ï¿½ï¿½Bï¿½HQCï¿½ï¿½cvï¿½>ï¿½,ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½,5Eï¿½$yÙ¢q'yï¿½ï¿½L:#ï¿½æ¸ï¿½Tï¿½ï¿½Pï¿½ï¿½.5,ï¿½ï¿½ï¿½Ï®ï¿½)ï¿½Dï¿½iï¿½Yï¿½RrTï¿½ï¿½ï¿½ï¿½ï¿½}
ï¿½ï¿½&Lcï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
ï¿½KŞ¥ï¿½ï¿½ï¿½xcï¿½Gï¿½ï¿½ï¿½rï¿½ï¿½4ï¿½2ï¿½ï¿½kï¿½Rï¿½ï¿½*ï¿½)ï¿½ï¿½ï¿½ï¿½0ï¿½ï¿½IYuï¿½nï¿½ï¿½ï¿½xï¿½nï¿½ï¿½hï¿½ï¿½Qï¿½\ï¿½/ï¿½ï¿½ï¿½ï¿½ï¿½"yÏ«nJ`z}W~ï¿½ï¿½/ï¿½ï¿½+ï¿½3+ï¿½ï¿½$ï¿½b]ï¿½}8ï¿½8uï¿½\NÛ[]ï¿½ï¿½L,^ï¿½ï¿½9Dï¿½}ï¿½)xï¿½ï¿½9ï¿½ï¿½ï¿½ï¿½6ï¿½<Dï¿½8ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½mjï¿½ï¿½ï¿½hï¿½ï¿½6ï¿½	vï¿½|ï¿½ï¿½ oï¿½^ï¿½~^J^TAï¿½ï¿½<qï¿½Sï¿½
ï¿½n\ï¿½%avbï¿½ï¿½ï¿½{dmï¿½ï¿½ï¿½ï¿½Wjï¿½ï¿½;ï¿½ï¿½t@xï¿½ï¿½3ï¿½,ï¿½ï¿½yÍ¨ï¿½ï¿½ï¿½É½)ï¿½zï¿½9Ü¦ï¿½ï¿½nï¿½ï¿½^Xï¿½ï¿½#Ûš[ï¿½-*ï¿½ï¿½.N|ï¿½ï¿½ï¿½cuï¿½<ï¿½Gï¿½Z,NfÚ“IgQ;;_=nï¿½  Q=Vï¿½XHï¿½P9JI@ï¿½Jï¿½lï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½;>/ï¿½[>ï¿½ï¿½ï¿½Ç“LxÃºï¿½t8ï¿½È±zï¿½di7×¦ï¿½ï¿½GM&i-"ï¿½ï¿½Lï¿½ï¿½bï¿½ï¿½fï¿½0Oï¿½c*ï¿½ï¿½Aï¿½Í˜ï¿½Gï¿½ï¿½pv,ï¿½)ï¿½)ï¿½Zaï¿½lsï¿½ï¿½ï¿½ï¿½Î¾ï¿½P.ï¿½ï¿½;brIï¿½K'ï¿½]ï¿½ï¿½_>ï¿½Oï¿½ï¿½ï¿½ï¿½%)Nï¿½ï¿½M"IE^lï¿½i ï¿½Kï¿½1.@Ê¼4A,|ï¿½ï¿½	;$Qï¿½ï¿½Cï¿½ï¿½hï¿½%Pï¿½ï¿½wï¿½ï¿½Xï¿½Ë›ï¿½}ï¿½ï¿½ï¿½0+@ï¿½&ï¿½ï¿½Yï¿½8k8ï¿½bï¿½_ï¿½0Ï±ï¿½ï¿½6ï¿½ï¿½\×©ê³ï¿½É]ï¿½ï¿½ï¿½+[j.*3ï¿½ï¿½ï¿½{"TRï¿½ï¿½GJï¿½R2E}ï¿½Rï¿½ ä£¶ï¿½ï¿½ï¿½#ï¿½eï¿½R^ï¿½ï¿½ï¿½Rp=ï¿½R2ï¿½*%ï¿½ï¿½ï¿½Rï¿½G'ï¿½86Aï¿½ï¿½\Kï¿½$SB5ï¿½ ï¿½*ï¿½ßœ=ï¿½ï¿½ï¿½ï¿½ï¿½#%ï¿½}ï¿½ï¿½Rï¿½+X3ï¿½&ï¿½hï¿½ï¿½Q*ï¿½ï¿½nï¿½rRï¿½lPï¿½Ê¾l]ì’‘qï¿½vPÇ¡ï¿½wï¿½ï¿½ï¿½K ×…ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½9rL+ï¿½ï¿½ï¿½ï¿½H×¦ï¿½ï¿½ï¿½ï¿½$Pï¿½weÅ£Tï¿½ï¿½=ï¿½
ï¿½2Eßï¿½pnï¿½ï¿½9ï¿½ï¿½ï¿½
ï¿½ï¿½@ï¿½oï¿½Aï¿½%c[ ï¿½ï¿½&*ï¿½ï¿½ï¿½%?ï¿½ï¿½Mvï¿½)Jï¿½$ï¿½ï¿½(h@,ï¿½ï¿½tÂ„ï¿½,ï¿½ï¿½ï¿½9ï¿½
ï¿½ï¿½|VĞ§aH^ï¿½ï¿½ï¿½-ï¿½ï¿½ï¿½Zï¿½A\
ï¿½ï¿½ï¿½JÚŒï¿½Øï¿½Oï¿½ï¿½Hï¿½{WtKï¿½ï¿½ï¿½yPŞ¾ï¿½d(ï¿½ï¿½ï¿½!ï¿½bï¿½}YorSï¿½6kwÉ£ï¿½ï¿½ï¿½ï¿½vFï¿½z0{ï¿½qï¿½ï¿½<!Vï¿½'Wï¿½jï¿½!ï¿½-ï¿½ï¿½fï¿½g
HDï¿½ï¿½ï¿½ï¿½gï¿½ï¿½7ï¿½ï¿½ï¿½9ï¿½/B'Wï¿½ï¿½ï¿½ï¿½ÏŒxk\ï¿½hï¿½ï¿½_ï¿½ï¿½ï¿½&ï¿½*ï¿½Mï¿½ï¿½(hï¿½1
z+e9e\ï¿½ï¿½	Hï¿½ï¿½Li,f
HØ€ï¿½ï¿½ar?
Zï¿½ï¿½ï¿½]Cy[ï¿½Kï¿½B5ï¿½ï¿½ï¿½4Qï¿½ï¿½ï¿½ï¿½ï¿½ï¿½nï¿½Eï¿½ï¿½ï¿½)T`Qï¿½ï¿½Dï¿½ï¿½sï¿½@ï¿½rï¿½qï¿½Ã«p"ï¿½hï¿½ï¿½_ï¿½ï¿½Qï¿½ï¿½ï¿½ï¿½A_ï¿½ï¿½ï¿½ï¿½ï¿½uBï¿½ï¿½:zï¿½xlï¿½zï¿½$%ï¿½p^,k@0ï¿½M+ï¿½ï¿½!ï¿½4|${q(ï¿½Aï¿½ï¿½jï¿½ï¿½ï¿½ï¿½ï¿½
rGï¿½W NV|ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½4ï¿½ï¿½"Ğ¦|tï¿½×ŒbI#ï¿½&/ADhSï¿½"ï¿½ï¿½'^1ï¿½4ï¿½ï¿½Rï¿½ï¿½ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½K(ï¿½`ï¿½"Mcï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½Hc-eï¿½Ö¸gï¿½ï¿½ï¿½8ï¿½ï¿½ï¿½Ü ï¿½<ï¿½ï¿½Vï¿½f ï¿½ï¿½ï¿½ï¿½mï¿½/hï¿½1ï¿½5ï¿½h^ï¿½ï¿½ï¿½ï¿½Dï¿½ï¿½ që…ŸWï¿½ï¿½ï¿½ï¿½v*Vï¿½ ï¿½~Ğ¦ï¿½ï¿½Ü´Hï¿½!ï¿½uï¿½Äšï¿½ï¿½ Yï¿½
ï¿½ï¿½QĞ¬+ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½gï¿½giï¿½1ï¿½*R
ï¿½9~zvï¿½Ï˜vmï¿½gï¿½ï¿½y)L7ï¿½ï¿½ï¿½Fï¿½-ï¿½ï¿½ï¿½Uï¿½ï¿½ï¿½9wï¿½ï¿½fï¿½ï¿½=ï¿½Æ´ï¿½L,ï¿½Pï¿½ï¿½Qï¿½`$Ó¢ï¿½[ï¿½aï¿½cï¿½Eï¿½ï¿½Scï¿½ï¿½ï¿½?H^ï¿½ï¿½#x1uï¿½Eivï¿½ZÏ§ï¿½ï¿½ï¿½ï¿½b<ï¿½ï¿½Hwzï¿½ï¿½ï¿½ï¿½)ï¿½P$ï¿½ï¿½ï¿½Gï¿½Fï¿½ï¿½Gï¿½$Jï¿½Æ„6Aï¿½|ï¿½ï¿½ï¿½ `x;ï¿½ï¿½rï¿½dï¿½Ô¸fï¿½,Bï¿½\yï¿½å‰ï¿½7hï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@ï¿½ï¿½xï¿½ï¿½ï¿½MBï¿½3hJï¿½aï¿½ï¿½TLï¿½ï¿½Bï¿½Ü±8ï¿½Ï²Zï¿½ï¿½ï¿½ï¿½"ï¿½		ï¿½nï¿½;ï¿½GYÜ¦ï¿½5Ù©ï¿½ï¿½ï¿½ï¿½ï¿½Z7!ï¿½Bï¿½ï¿½ï¿½ï¿½h`ï¿½ï¿½Üï¿½ï¿½ï¿½+ï¿½7ï¿½ï¿½Fï¿½ï¿½ï¿½ï¿½8Iï¿½Ş¥ï¿½rR0ï¿½ï¿½"ï¿½0>ï¿½ï¿½pï¿½9F ï¿½ï¿½ï¿½F-ï¿½\,ï¿½ï¿½|Sï¿½Âï¿½B~Ì¢Eï¿½ï¿½ÇƒÍ‹G)ï¿½ï¿½"ï¿½ï¿½dï¿½ï¿½ï¿½Iï¿½ï¿½ï¿½<xvï¿½ï¿½%ï¿½@ï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½ï¿½H^ ï¿½;É£ï¿½$ï¿½D(yï¿½ï¿½*ï¿½sï¿½[ï¿½ï¿½A!\(fï¿½ï¿½R"qcï¿½/ï¿½ï¿½~ï¿½4
1Mï¿½zY'A!~gï¿½tv#yï¿½b?3-u$ï¿½ï¿½ï¿½)kkï¿½3Yï¿½jï¿½ï¿½Pï¿½İ–&3Mï¿½Yï¿½"ï¿½ï¿½pLÉƒ-+#ï¿½ï¿½qÒ¹QkÂï¿½bï¿½5ï¿½dï¿½ï¿½hï¿½ï¿½Qï¿½ï¿½Vï¿½~ï¿½	ï¿½=ï¿½ï¿½ï¿½ï¿½Î#ï¿½G!Zï¿½[ï¿½;Î—ï¿½ï¿½ï¿½,rï¿½ï¿½ï¿½ÃŒeï¿½@ï¿½gï¿½Ù¢5HM .=j+Lï¿½ï¿½@ï¿½-ï¿½_|ï¿½IÃ¥zxÈ›ï¿½ï¿½ï¿½rï¿½	ï¿½sï¿½@ï¿½ï¿½ï¿½MV!ï¿½W9<ï¿½WG y×¬ï¿½ï¿½ï¿½^Wï¿½ï¿½Zï¿½=.ï¿½ï¿½ï¿½+ï¿½ï¿½Iï¿½zqï¿½Lï¿½2ï¿½ï¿½ï¿½@ï¿½5iï¿½ï¿½ï¿½ï¿½Rï¿½(ï¿½Dï¿½8ï¿½ï¿½Hï¿½f	aï¿½ï¿½~ï¿½Dï¿½gï¿½+X[ï¿½OVï¿½wï¿½W6nï¿½ï¿½{ï¿½tï¿½Oï¿½ï¿½?p.ï¿½R?\ï¿½q9ï¿½Hï¿½ï¿½ELï¿½=ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½+#ï¿½ÂÚ‰Uï¿½Lï¿½ï¿½;/ï¿½}ï¿½ï¿½ï¿½ï¿½$IÅªlï¿½ï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½!w\ï¿½ï¿½ï¿½f* ï¿½*ï¿½'ï¿½ï¿½%ï¿½ï¿½Y0)ï¿½ï¿½ï¿½ï¿½1ï¿½r./ï¿½ &jï¿½ï¿½Ãªï¿½ï¿½ï¿½k*$tï¿½Tï¿½pXï¿½bï¿½ï¿½pCï¿½Ô…ï¿½Pï¿½HŞ³ï¿½Pï¿½7ï¿½"ï¿½ï¿½ï¿½oï¿½nï¿½ï¿½6ï¿½djï¿½)a^ï¿½mï¿½iï¿½ï¿½'ï¿½@ï¿½Aï¿½ï¿½ï¿½Kï¿½ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½X12ï¿½=I@vG~Kï¿½[%ï¿½$[côŒ°œuï¿½cï¿½ï¿½ï¿½bE;ï¿½XÑ¢#ï¿½ï¿½ï¿½ï¿½ï¿½>ï¿½Sï¿½Gï¿½b:ï¿½ï¿½ï¿½;'
ï¿½*ï¿½2ï¿½{ï¿½ï¿½ï¿½S#ï¿½%ï¿½`ï¿½ï¿½<j_[cï¿½fï¿½Bï¿½ï¿½nï¿½dï¿½ ï¿½ï¿½lH?ï¿½DË•ï¿½|ï¿½tï¿½5ï¿½ï¿½ï¿½ï¿½ï¿½Õtï¿½|ï¿½\iw0ï¿½ï¿½X6ï¿½y{Z2ï¿½Í•VjXï¿½ï¿½c?ï¿½ï¿½xr~^ï¿½q9ï¿½ï¿½{ï¿½Pï¿½ï¿½ï¿½%,ï¿½`ï¿½<ï¿½ï¿½6ï¿½ï¿½qï¿½ï¿½	ï¿½@ï¿½ï¿½ï¿½]ï¿½ï¿½uï¿½3Kï¿½ï¿½ ï¿½ï¿½Û„ä™‹ï¿½)ï¿½bï¿½G
	Jï¿½"ï¿½ï¿½ï¿½Jï¿½ï¿½ï¿½ï¿½Gï¿½ï¿½<ï¿½LQï¿½ï¿½"};ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½mï¿½!ï¿½ï¿½Ú¼zï¿½ï¿½0s7ï¿½ï¿½ï¿½Yeï¿½ï¿½ï¿½*ï¿½ï¿½6K|Vcï¿½* Õ¸Uï¿½2ï¿½Nï¿½ ï¿½ï¿½ï¿½2<R@ï¿½D8Xï¿½ÒÏ‚Pï¿½ï¿½ï¿½ï¿½Bï¿½ï¿½[qï¿½ï¿½1\ï¿½6ï¿½ï¿½ï¿½Sï¿½ï¿½cjqï¿½ï¿½-ï¿½ï¿½KYZyï¿½ï¿½ï¿½f/ÙŒï¿½ï¿½Bï¿½s 0ï¿½Hï¿½ï¿½ï¿½ï¿½2ï¿½ï¿½r"]ï¿½c
ï¿½ï¿½ï¿½]Nk.]ï¿½ï¿½/Mï¿½ï¿½ï¿½=Î‰tï¿½ï¿½ï¿½ÇœCÄ‹;v?ï¿½ï¿½ï¿½ï¿½a=ï¿½Fï¿½=ï¿½Ò³ï¿½ï¿½ï¿½4:Ú•".Û¬ï¿½ï¿½4D47$ï¿½X%oï¿½ï¿½ï¿½ï¿½&|^!hï¿½""ï¿½H^:ï¿½ï¿½Ì£ï¿½ï¿½0ï¿½ï¿½"ï¿½3É‹"ï¿½ï¿½IOï¿½.ï¿½1ï¿½Ø¬ï¿½oï¿½ï¿½\#Rï¿½6ï¿½&Çœï¿½TVï¿½ï¿½CCï¿½ï¿½aï¿½ï¿½ï¿½Rï¿½@ï¿½ï¿½;oLRO#ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½Mwlï¿½+ï¿½ï¿½Eï¿½Mï¿½;ï¿½e&ï¿½Mï¿½ï¿½Pï¿½b?ï¿½9/vï¿½nfË–ï¿½lï¿½ï¿½ï¿½ï¿½ï¿½.ï¿½Ò¶H,È´ï¿½Gtï¿½m}vï¿½{ï¿½	ï¿½ï¿½ï¿½ï¿½@ï¿½Qï¿½sï¿½Tï¿½Hï¿½-)zXmï¿½ï¿½ï¿½ï¿½)ï¿½a9ï¿½ï¿½uKjï¿½ï¿½`ï¿½Tï¿½[+ï¿½
(Í¿ï¿½ï¿½w.}z>È“<ï¿½Mï¿½ï¿½Iï¿½gï¿½=ï¿½Uï¿½>mï¿½ï¿½Eï¿½ï¿½0Lï¿½ï¿½+ï¿½ï¿½tYï¿½1ï¿½ï¿½ï¿½ ï¿½;6Nï¿½@ï¿½7 ,ï¿½yï¿½ï¿½Eï¿½ï¿½
Qï¿½Ã¸Kï¿½ï¿½|ï¿½ï¿½ï¿½ï¿½b|ï¿½ï¿½ï¿½-uï¿½eï¿½ï¿½,ï¿½_:ï¿½ï¿½0D:İ«ï¿½ï¿½Ñˆiï¿½É§Hï¿½ï¿½Eï¿½ï¿½ï¿½ï¿½ï¿½Wnï¿½]ï¿½o[ï¿½]ï¿½ï¿½ï¿½ï¿½S3Hï¿½ï¿½Hxï¿½ï¿½,ï¿½ï¿½ï¿½ï¿½kbï¿½b7ï¿½n:Pï¿½ï¿½Hs;ï¿½%ï¿½ï¿½ï¿½ï¿½ï¿½	ï¿½ï¿½ï¿½mï¿½ï¿½

ï¿½wï¿½ï¿½dUï¿½ï¿½z,,ï¿½*+ï¿½Zï¿½ï¿½bï¿½ï¿½Å…ï¿½ï¿½ï¿½\ï¿½ï¿½xï¿½Rï¿½iA<ï¿½ï¿½İ¼_zD	ï¿½ï¿½ï¿½9ï¿½ï¿½Gï¿½	Pï¿½ï¿½Z"ï¿½=ï¿½tï¿½vï£¸Yï¿½ï¿½ï¿½ï¿½"ï¿½ï¿½ï¿½ï¿½|^rï¿½ï¿½ï¿½Ü°ï¿½zï¿½ï¿½@Fï¿½ï¿½Ztï¿½ï¿½Ogï¿½ï¿½ï¿½ï¿½ï¿½@ï¿½rï¿½Ô’w+ï¿½^ï¿½(ç…¹Gï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½qï¿½ï¿½'Ë¹ä…³ï¿½ï¿½Tï¿½ï¿½ï¿½F`ï¿½ï¿½y-5á–‚ï¿½E3ï¿½&ï¿½ï¿½ï¿½:lï¿½qï¿½-ï¿½â¬wï¿½uCie ï¿½ ï¿½ï¿½qï¿½UNï¿½ï¿½Vï¿½yí—¶ï¿½ï¿½ï¿½vï¿½ï¿½ï¿½ï¿½1ï¿½xï¿½ï¿½[ï¿½ZZ^sï¿½ï¿½
ï¿½@82ï¿½Nï¿½	ï¿½ï¿½Ã‰!ï¿½ï¿½ï¿½(ï¿½3bï¿½Iï¿½-Dï¿½ï¿½Jï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æ‡"/ï¿½ï¿½ï¿½>ï¿½ï¿½kï¿½5ï¿½|ï¿½Oï¿½9Ì¿Ü dyQBï¿½ ï¿½Wï¿½ï¿½!ï¿½*ï¿½ï¿½L,ï¿½ï¿½ï¿½TB9_ï¿½`,ï¿½H_BKï¿½ï¿½ï¿½ï¿½|^UBï¿½Fï¿½Vï¿½5ï¿½Iwï¿½!-d&ï¿½a~ï¿½ï¿½ï¿½ï¿½ï¿½@>SBcï¿½ï¿½Mï¿½ï¿½ï¿½?Fï¿½ï¿½U	ÅŠï¿½ï¿½ï¿½B'ï¿½sï¿½ï¿½ï¿½xo;
ï¿½ï¿½-vï¿½ï¿½ï¿½ï¿½ï¿½ï¿½kï¿½ï¿½ï¿½ï¿½ï¿½& 0ï¿½#ï¿½ï¿½F$ï¿½ï¿½lï¿½rSï¿½ï¿½ï¿½Õbzï¿½n{N5)ï¿½ï¿½ï¿½~ï¿½% 78ï¿½ï¿½ï¿½@&w.ï¿½~ï¿½<>ï¿½rï¿½&ï¿½qï¿½yï¿½ï¿½ï¿½3
ï¿½<ï¿½T0=)-ï¿½ï¿½*ï¿½ï¿½hï¿½Û¹'/ï¿½ï¿½Zï¿½ï¿½ï¿½ï¿½Yï¿½ï¿½ï¿½#[nï¿½ï¿½ ]K]ï¿½ï¿½'ï¿½+$Gï¿½ 4ï¿½ï¿½" ï¿½ï¿½/ï¿½lï¿½gï¿½{ï¿½Æˆï¿½ï¿½?ï¿½Kï¿½Qï¿½%ï¿½V#,ï¿½Cï¿½ï¿½+K	ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Cï¿½ï¿½3(Æï¿½ï¿½?ï¿½?ï¿½ï¿½ï¿½Qï¿½ï¿½Û·ï¿½ï¿½Dï¿½uï¿½{ahWï¿½ï¿½#,Q[lï¿½ï¿½ï¿½,!ï¿½ï¿½-ï¿½+ yï¿½~ï¿½ï¿½ï¿½a"a1)ï¿½ï¿½]ï¿½mpnï¿½ï¿½ï¿½<ï¿½	ï¿½&Kï¿½ï¿½9ï¿½ï¿½ï¿½ï¿½>ï¿½<yaï¿½ï¿½=Tï¿½ï¿½Ò2Oï¿½ï¿½kï¿½ï¿½v=ï¿½ï¿½ï¿½+xï¿½ï¿½)Ø¼)ys6È†LZï¿½ï¿½ï¿½ï¿½bï¿½ï¿½|BEï¿½ï¿½iï¿½ï¿½yï¿½ï¿½ï¿½Ø¯$Oï¿½ï¿½vï¿½Dï¿½Ò‘ï¿½4Qï¿½ï¿½Ñï¿½ï¿½{Gï¿½ï¿½Oï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½Eï¿½ï¿½v-5Aï¿½`ï¿½fï¿½mï¿½ï¿½ï¿½ï¿½3ï¿½;Sï¿½sï¿½Efï¿½q$ ï¿½4ï¿½ï¿½5ï¿½|ï¿½ï¿½Tï¿½F9ï¿½uï¿½%&y!ï¿½ï¿½mï¿½<ï¿½n)ï¿½@|9EGï¿½ï¿½È…tg.vf|ï¿½Ê¼Cï¿½U"ï¿½ï¿½Ç8ï¿½ï¿½'Ù²c/%3Ctï¿½<U/Kï¿½ï¿½ï¿½ï¿½É³Hwï¿½Q^ï¿½5Qï¿½ï¿½(LÉƒ:MÊ˜-ï¿½iï¿½ï¿½ï¿½ï¿½å¶‘ï¿½^ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`ï¿½uÜ¯xï¿½@ï¿½uï¿½%\Vï¿½.;Ó©ï¿½ï¿½ï¿½oYï¿½Lï¿½ï¿½ï¿½xï¿½ï¿½:{ï¿½ï¿½xï¿½ï¿½ï¿½ï¿½Bï¿½ï¿½HUï¿½ï¿½-!=>ï¿½Mï¿½:Ì¤ï¿½ï¿½m*Ş£ï¿½ÕŒGŞ±vËŸ{ï¿½7ï¿½ï¿½5ï¿½ï¿½+1`;ï¿½ï¿½%e4?yï¿½sï¿½zzï¿½ï¿½ï¿½Ä³ï¿½ï¿½ï¿½qv,ï¿½Ò„ï¿½ï¿½ï¿½ì¥‚å”Tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ñ¯ï¿½ï¿½ï¿½mï¿½ï¿½ï¿½9$|ï¿½ï¿½S"ï¿½d*
ï¿½%ï¿½aï¿½ï¿½X}ï¿½ovOF,ï¿½1ï¿½ï¿½ï¿½ï¿½zï¿½ï¿½ï¿½ÓŒÑ±ï¿½Gï¿½ï¿½Î»?iGï¿½1&Dï¿½Lzï¿½pCb$mï¿½ï¿½ï¿½& ï¿½&ï¿½|9ï¿½	ï¿½/cï¿½rï¿½w.tï¿½Sï¿½Æ°Tï¿½mï¿½OĞï¿½ï¿½ï¿½M*gÇ¨Ô„Mï¿½huï¿½ï¿½ï¿½)ï¿½7tï¿½+ï¿½ï¿½ï¿½Qbï¿½Xï¿½Eï¿½>Ëeï¿½5ï¿½ï¿½pï¿½ï¿½nï¿½	5>ï¿½n#ï¿½y?ï¿½ï¿½"%/ï¿½#6ï¿½ï¿½lï¿½ï¿½ï¿½^ï¿½wï¿½ï¿½qï¿½[ï¿½+iï¿½Iï¿½ï¿½rï¿½bAï¿½Yï¿½vï¿½"Zï¿½#ï¿½ï¿½Vpï¿½ï¿½FÙ™Tï¿½KVï¿½%ï¬,ï¿½ï¿½'ï¿½ï¿½+ï¿½ï¿½!ï¿½aeFï¿½dï¿½6:ï¿½!bï¿½URï¿½ï¿½}ï¿½;b1ï¿½(	|ï¿½ï¿½ï¿½ï¿½ï¿½C]Wï¿½
ï¿½ï¿½IÅ¶,ï¿½L[9ï¿½bvï¿½y>ï¿½gï¿½ï¿½ï¿½ï¿½ï¿½aï¿½9ï¿½Sï¿½y
ï¿½Dï¿½ï¿½ï¿½ï¿½pï¿½<ï¿½3ï¿½ï¿½Oï¿½+È€ï¿½BUkï¿½ï¿½ï¿½zH)ï¿½ï¿½ï¿½yï¿½ï¿½}<ï¿½kï¿½"zï¿½Uï¿½mtr#yï¿½ï¿½ï¿½@ï¿½ï¿½Uï¿½]^ï¿½Dï¿½Hï¿½ï¿½ï¿½8ï¿½ï¿½ï¿½1Y=ï¿½[ï¿½@[Dï¿½Ø¢ï¿½ï¿½Å.yï¿½bï¿½ï¿½ï¿½ï¿½ï¿½$&ï¿½ï¿½ï¿½ï¿½yï¿½^Sï¿½ï¿½Vï¿½ï¿½éœHØï¿½!ï¿½ï¿½ï¿½$aï¿½=4ï¿½DewÉƒHï¿½dï¿½ï¿½2ï¿½ 'ï¿½ï¿½)yï¿½ï¿½+ï¿½ï¿½H4Lgï¿½dï¿½ã½»Eï¿½ï¿½ï¿½ï¿½ï¿½)(lï¿½Kï¿½)%ï¿½ï¿½oï¿½mï¿½ï¿½ï¿½Ú¼ï¿½ï¿½ï¿½aï¿½Æ¿=$/#/ï¿½ï¿½ï¿½2ï¿½\Dï¿½ï¿½ï¿½}zï¿½ï¿½ï¿½ï¿½Zv]ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½H Eï¿½<ï¿½y
ï¿½ï¿½|ï¿½ï¿½)8ï¿½r1MO#ï¿½nï¿½è¡ï¿½}ï¿½ï¿½ï¿½cì¦¥ï¿½ï¿½ ï¿½9tï¿½_Lï¿½ï¿½ï¿½Jï¿½dï¿½6S/ï¿½y$<mï¿½Ò•ï¿½ï¿½yï¿½ï¿½ï¿½ï¿½6ï¿½jï¿½4İ€ï¿½ï¿½[?ï¿½[ï¿½ï¿½ï¿½M8ï¿½ï¿½Rï¿½ï¿½Z
d3ï¿½ï¿½ï¿½ï¿½fXÇ½6ï¿½ï¿½Ï¨ï¿½ï¿½ğ˜‰›ï¿½ï¿½$ï¿½-ï¿½ï¿½:Wï¿½$ï¿½ï¿½Ê•Í£ï¿½ï¿½ï¿½ï¿½.ï¿½ï¿½fmï¿½T@ï¿½)uRï¿½ $F_ï¿½ï¿½ I6Ç¼tï¿½So{[ï¿½ï¿½ï¿½ï¿½;]Ğ¦iï¿½a	ï¿½uï¿½ĞŒï¿½ï¿½"`ï¿½ï¿½ï¿½ï¿½ï¿½Ô¯ÈŠï¿½aï¿½;ï¿½ï¿½ï¿½ï¿½ï¿½3}ï¿½ï¿½ï¿½ï¿½Jï¿½Iï¿½dÎ”ï¿½33){ï¿½ï¿½kï¿½&ï¿½ï¿½ï¿½sØ¼Xï¿½sï¿½d×ï¿½mï¿½ï¿½ï¿½Kuï¿½ï¿½ï¿½gï¿½ï¿½ocï¿½ï¿½ï¿½iï¿½ï¿½q+İ Saï¿½ï¿½ï¿½I E4ï¿½ï¿½sn8ï¿½ï¿½#ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½z+yï¿½_ï¿½nï¿½:~ï¿½+ï¿½Sï¿½tï¿½Ô¢ï¿½Rï¿½Jï¿½Ë³ï¿½ï¿½M	ï¿½K+ï¿½ofï¿½ï¿½snï¿½ï¿½mï¿½p
Aï¿½ï¿½Sï¿½,,Ãï¿½à´¤ï¿½'ï¿½ï¿½rï¿½7ï¿½ï¿½ï¿½ï¿½9ï¿½Ö°ï¿½ï¿½<ï¿½)É£rï¿½ï¿½ï¿½8ICc\J"Nï¿½ï¿½^Ö»Aï¿½@ï¿½ï¿½cu='ï¿½Lï¿½ ï¿½ï¿½cï¿½Û™g>ï¿½Wï¿½ï¿½ï¿½ï¿½)ï¿½ï¿½2ï¿½ÅŸï¿½bï¿½ï¿½q9ï¿½ 1!1,Ó®ï¿½ï¿½=ï¿½ï¿½Qï¿½ï¿½ï¿½sï¿½ï¿½3ï¿½^ï¿½eï¿½1}tï¿½Mï¿½Qï¿½1ï¿½Ğ¯ï¿½ï¿½ï¿½Pï¿½ï¿½ï¿½9cï¿½cï¿½mï¿½Æ¿kV!aï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½|?ï¿½ï¿½ï¿½ï¿½Pï¿½ï¿½ï¿½cï¿½g1ï¿½ï¿½ï¿½ï¿½Uï¿½ï¿½Aï¿½ï¿½ï¿½aï¿½iN!ï¿½cï¿½ï¿½	ï¿½ï¿½ï¿½ï¿½å„©ï¿½ï¿½ï¿½ÇŸï¿½Sxï¿½6ï¿½$/*Bï¿½ï¿½A@ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½4ï¿½ï¿½dï¿½ï¿½Mï¿½ï¿½ï¿½P@ï¿½ï¿½Ğ©ï¿½å­™t!ï¿½ï¿½Cï¿½$Oï¿½È‹ï¿½ï¿½bsRï¿½`ï¿½%QVï¿½ï¿½ï¿½lï¿½ï¿½ï¿½Ó°sï¿½7ï¿½gM|'ï¿½ï¿½Ğ†ï¿½,ï¿½ï¿½ï¿½scï¿½U#,ï¿½ï¿½Õ¦T1ï¿½}ï¿½ï¿½1ï¿½ï¿½lï¿½É¼TROï¿½ï¿½ï¿½(ï¿½Bï¿½ï¿½yvï¿½=ï¿½L1/ï¿½Û¢ï¿½jOThï¿½8ï¿½ï¿½ï¿½TOÏ‡ï¿½È¬ï¿½Å©ï¿½qï¿½Mï¿½ï¿½ï¿½hï¿½ï¿½ï¿½ï¿½
ï¿½ ï¿½wï¿½ï¿½Mï¿½ï¿½7ï¿½9'F6[",OÏ¹ï¿½ï¿½Nï¿½wxï¿½ï¿½ï¿½}ï¿½ï¿½z&Eï¿½W(Nï¿½YG ï¿½ï¿½fï¿½cDï¿½ï¿½$ï¿½ï¿½ï¿½x/=7ï¿½\ï¿½MÖ£=7%ï¿½ï¿½ï¿½lHË¬6~ï¿½ï¿½'ï¿½P>)K4ï¿½ï¿½ï¿½cï¿½ï¿½m-:ï¿½ï¿½bï¿½Æ‚ï¿½bAï¿½ï¿½ï¿½o,ï¿½Å©&ï¿½ï¿½*,ï¿½
CNï¿½vï¿½FXï¿½|ï¿½=ï¿½ï¿½Ô‚HAï¿½y2
ï¿½ï¿½ï¿½bï¿½ï¿½nï¿½ï¿½I"ï¿½ï¿½Ú•ï¿½ï¿½A<fï¿½ï¿½ï¿½ï¿½ï¿½kï¿½ï¿½mï¿½ï¿½ï¿½ï¿½Ò€R|ï¿½ï¿½!ï¿½oMï¿½ï¿½(ï¿½aï¿½aï¿½fï¿½ï¿½Uï¿½ï¿½ï¿½wï¿½hï¿½Jï¿½ï¿½Wï¿½Wï¿½ï¿½~ï¿½ï¿½Qï¿½ï¿½ï¿½ï¿½7È“oï¿½Hï¿½y"v6Oï¿½ï¿½ï¿½Pï¿½ï¿½@f4Lï¿½4=ï¿½<?ï¿½ ï¿½ï¿½ï¿½!ï¿½jFXï¿½ï¿½ï¿½,ï¿½
Z.Aï¿½ï¿½Iw~ï¿½6ï¿½>'cï¿½^ï¿½ï¿½yï¿½ï¿½ï¿½>[8,E4ï¿½sÓ’YtÉ‚ï¿½ï¿½a)x9pï¿½ï¿½ï¿½zï¿½ï¿½iVhï¿½ï¿½7ï¿½+ï¿½FWÄŠ%h$8ï¿½hï¿½ï¿½-J7ï¿½ï¿½g~ï¿½ï¿½ï¿½ï¿½ï¿½cpYï¿½ï¿½uï¿½ï¿½Oï¿½ï¿½Fï¿½E=ï¿½ Bï¿½Í²Xiï¿½ï¿½.Â’ï¿½3ï¿½ï¿½ï¿½Jï¿½yï¿½{s!-bï¿½ï¿½gxKï¿½ï¿½ï¿½8ï¿½ï¿½gx'ï¿½/ï¿½<ï¿½~ï¿½Ğˆ/ï¿½ï¿½ï¿½<ï¿½!ywY!iï¿½ï¿½ï¿½zï¿½Jï¿½ï¿½ï¿½vèƒ¬tJ	]ï¿½ï¿½$-ï¿½ï¿½ï¿½<,Eï¿½jï¿½9%SMï¿½jï¿½ï¿½ï¿½ï¿½kjï¿½ï¿½(u?ï¿½ï¿½qï¿½F%hh%ï¿½*Plï¿½3ï¿½GXï¿½ï¿½YHï¿½Hfï¿½:ï¿½$ï¿½ï¿½âŸ“ï¿½èŒ…ï¿½Iï¿½<ï¿½ïŒµï¿½Kï¿½8Eï¿½ï¿½É»vÆ¾ï¿½<r4ï¿½>!yï¿½/wï¿½ï¿½ï¿½N#}>ï¿½<}ï¿½dï¿½qÌ™ï¿½ï¿½ï¿½ï¿½=ï¿½ï¿½ï¿½Qï¿½4ï¿½=$O?'yaï¿½pï¿½Lbï¿½oï¿½$O_Iï¿½ï¿½+6/ï¿½ï¿½ï¿½ï¿½ï¿½3ï¿½ï¿½ï¿½Yzï¿½ï¿½{É‹|ï¿½ï¿½Wï¿½ï¿½ï¿½fï¿½6o%oï¿½y7ï¿½klSc1feï¿½Ùï¿½ï¿½bï¿½4%oï¿½ï¿½ï¿½h%ï¿½1ï¿½Wï¿½'9ï¿½Bo%6ï¿½ï¿½)ï¿½ï¿½ï¿½ï¿½"y$#\?B=ï¿½ï¿½Ø™ï¿½M?ï¿½ï¿½Nï¿½:gï¿½;r;ï¿½ï¿½ï¿½emï¿½cÉ³ï¿½<ï¿½$ï¿½e0ï¿½ï¿½Uï¿½[2ï¿½ï¿½<ï¿½mï¿½3ï¿½ï¿½ï¿½3rï¿½ANï¿½ï¿½-f7hsï¿½ZÛ+ï¿½/G"ï¿½ï¿½ï¿½7Eï¿½ï¿½ï¿½#ï¿½ï¿½ï¿½ï¿½$ï¿½$yï¿½,ï¿½RH"KÖï¿½*Ã‚ï¿½/oï¿½ï¿½EIï¿½ vï¿½xï¿½
ï¿½^ï¿½ï¿½`ï¿½dï¿½$ï¿½ï¿½Cï¿½ï¿½ Y=ï¿½BbEï¿½qï¿½ï¿½Aï¿½ï¿½ï¿½8ï¿½w>ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½x9ï¿½ï¿½Vï¿½-%Ä›ï¿½ï¿½cï¿½rKï¿½Aï¿½ï¿½ï¿½*ï¿½Aï¿½:J06yLï¿½ï¿½ï¿½}ï¿½Np6ï¿½ã˜”)ï¿½[Jï¿½Xï¿½ï¿½Dï¿½/ï¿½ï¿½ï¿½j (.ï¿½ï¿½IjGï¿½hyï¿½8*ï¿½Î˜ï¿½uï¿½ï¿½[[veM]ï¿½ï¿½qï¿½ï¿½ï¿½ï¿½#ï¿½"/ï¿½ï¿½ê¨“ï¿½ï¿½zï¿½1ï¿½ï¿½Rï¿½Snyï¿½mï¿½{eï¿½%Ù‚h.ï¿½mÎ‚Ltï¿½ï¿½ï¿½ï¿½	ï¿½ ï¿½;oÏŠï¿½ï¿½yï¿½>ï¿½wï¿½$ï¿½zï¿½Kï¿½Ğšß¥qï¿½mï¿½ï¿½n3ï¿½ï¿½ï¿½ï¿½tï¿½mï¿½wkï¿½&ï¿½ ï¿½'|ï¿½\ï¿½ï¿½XPYï¿½ï¿½a7ï¿½*ï¿½ï¿½fsï¿½6ï¿½ï¿½ï¿½%Oï¿½ï¿½$OJcï¿½)ï¿½ï¿½ï¿½ï¿½lyï¿½ï¿½K
ï¿½S?oDXÆ›{ï¿½ï¿½ï¿½qï¿½hï¿½.=zp"ï¿½ï¿½ï¿½Ì´yï¿½ï¿½ï¿½(dï¿½ï¿½ï¿½
ï¿½ï¿½gh)ï¿½ï¿½Ø‚6M ï¿½ï¿½K(ï¿½`ï¿½Rrï¿½ï¿½iï¿½mNbï¿½Oï¿½6ï¿½uEÍƒï¿½ï¿½ï¿½ï¿½Ò·ï¿½ï¿½Ú­ï¿½ÇŸ2ï¿½ï¿½ï¿½ï¿½1Vuï¿½aï¿½ï¿½	HDï¿½hï¿½ï¿½ï¿½@ï¿½ï¿½H'Ú[~_ï¿½"aï¿½oï¿½<-5,ï¿½N8",ï¿½z~ï¿½Hnï¿½ï¿½ï¿½hï¿½S3ï¿½ï¿½:Wï¿½ï¿½"ï¿½Ym^Zï¿½ï¿½ï¿½ï¿½ï¿½ë«Ÿï¿½QÃ’ï¿½ï¿½8ï¿½ï¿½ï¿½Nï¿½ï¿½vï¿½ï¿½DXï¿½JsJnï¿½'Oï¿½ï¿½É 4ï¿½ï¿½ï¿½Ø¦ï¿½-ï¿½xï¿½Wï¿½{=+B$ï¿½ï¿½}\ï¿½<ï¿½Sï¿½Kï¿½ï¿½	>fï¿½iiï¿½ï¿½6ï¿½Lï¿½ï¿½vCï¿½ï¿½Õ‘?ï¿½5ï¿½ï¿½3yï¿½ï¿½ï¿½MYï¿½XdY\ï¿½<ï¿½ï¿½ï¿½zï¿½diNI*ï¿½ï¿½ï¿½*ï¿½ï¿½Û³ï¿½ï¿½nï¿½!İ‘M5ï¿½4ï¿½rï¿½Ò®vï¿½ï¿½ï¿½ï¿½aï¿½ï¿½8HYOï¿½`ï¿½hï¿½ï¿½fï¿½ï¿½ï¿½}Ôˆaï¿½Bï¿½6ï¿½ï¿½ï¿½ï¿½Yï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½Qï¿½ï¿½Vï¿½ ï¿½ï¿½ï¿½ï¿½Eï¿½ï¿½ï¿½aï¿½aï¿½^ï¿½ï¿½ï¿½Ã©tÖŠï¿½Rï¿½'XŞ¤ï¿½ï¿½ï¿½Bï¿½5ï¿½ï¿½Bï¿½ï¿½M	ï¿½ï¿½ï¿½4ï¿½9ï¿½ï¿½ï¿½hï¿½cï¿½ï¿½Wï¿½ï¿½:c$ï¿½
	ï¿½ï¿½z[ï¿½ï¿½F7ï¿½ï¿½ï¿½4G @@|j%wï¿½	éŠ° ï¿½wxï¿½ï¿½)D ï¿½<gsï¿½Ä§ï¿½Vï¿½ï¿½ï¿½6Sò†·i=Tï¿½1Oï¿½\WLï¿½ï¿½^ï¿½áª€ï¿½D"ï¿½#;ï¿½ï¿½\É¥ï¿½ ï¿½,sï¿½Ô»-?[H ï¿½ï¿½rï¿½ï¿½i#yï¿½ ï¿½ï¿½;ï¿½KÄ™ï¿½pÍ–ï¿½ï¿½1L@ï¿½Dï¿½ï¿½ï¿½í¦aï¿½ï¿½7	ï¿½vxï¿½ï¿½8sï¿½ï¿½ï¿½gï¿½ï¿½r0{ï¿½z.ï¿½cF*S ï¿½
Æ¯=ï¿½ï¿½ï¿½ï¿½b:Hï¿½ä€±ï¿½Zsï¿½iï¿½ï¿½ï¿½yï¿½Øºï¿½ï¿½LUï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½J|Bï¿½	&ï¿½ï¿½}wEÄ„ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½iï¿½ï¿½Ê±ï¿½ï¿½ï¿½Ãeï¿½TH5J(ï¿½ï¿½iï¿½ï¿½cï¿½ï¿½`ï¿½ï¿½ï¿½ï¿½6ï¿½ï¿½JgFAï¿½gzï¿½+ï¿½JGï¿½ï¿½ï¿½8ï¿½xï¿½ï¿½uï¿½s$Eï¿½Cï¿½ï¿½F<
ï¿½dQï¿½+@ï¿½ï¿½ï¿½ï¿½EF46j6ï¿½ï¿½ï¿½ï¿½fSï¿½ï¿½ï¿½"cEtï¿½ï¿½ï¿½Ø¾ï¿½ï¿½w;6ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½f9hï¿½ï¿½>ï¿½xMï¿½ï¿½!ï¿½ï¿½^iï¿½}ï¿½5ï¿½ï¿½2ï¿½Îlï¿½:ï¿½;
MÉ°jï¿½ï¿½ï¿½ï¿½[ï¿½ï¿½ï¿½Ë»ï¿½mï¿½ï¿½ï¿½ï¿½ï¿½ï¿½]ï¿½jï¿½&Dï¿½ï¿½|i]ï¿½hï¿½ï¿½ï¿½ï¿½Uï¿½ï¿½,3ï¿½Cï¿½6ï¿½ï¿½Jï¿½Hï¿½Wï¿½f<%ï¿½ï¿½ï¿½Qï¿½@pgHï¿½ï¿½ï¿½=ï¿½Û„{ï¿½ï¿½ï¿½ï¿½ï¿½nï¿½7p+yï¿½ï¿½ï¿½ï¿½wEï¿½ï¿½ï¿½YUï¿½ï¿½ï¿½ï¿½ï¿½  ï¿½IDATï¿½ï¿½ï¿½U}ï¿½4Tï¿½}D3ï¿½C=ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½E=ï¿½|Yï¿½ï¿½ï¿½Kï¿½ï¿½Jï¿½@ï¿½ï¿½ï¿½ï¿½sï¿½Xdï¿½Rï¿½ï¿½Fï¿½ï¿½Nï¿½@ï¿½ï¿½;c}ï¿½~1tÉ“OJï¿½mï¿½Mï¿½ï¿½Ê›ï¿½Tï¿½Wï¿½ç’—ï¿½ï¿½Xï¿½tï¿½<ï¿½Ö»ï¿½ï¿½ï¿½ï¿½5~\%ï¿½g*ï¿½kWÉ‹	Hrï¿½<aï¿½Sï¿½ï¿½4ï¿½ï¿½ï¿½ï¿½qï¿½;mHï¿½ï¿½_ï¿½ï¿½ï¿½mï¿½ï¿½ï¿½%/Pxï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½eï¿½ï¿½zï¿½Ç‹ï¿½ï¿½(lï¿½)5+ï¿½7ï¿½Fï¿½Sn%oï¿½ï¿½hSmï¿½ï¿½-ï¿½E'ï¿½Kï¿½tï¿½Ï£8ï¿½ï¿½ï¿½mï¿½nï¿½ï¿½ï¿½ï¿½k\9Sï¿½7>'ï¿½*ï¿½oÍ§5gï¿½ï¿½ï¿½Vï¿½Bï¿½ï¿½ï¿½$ï¿½ï¿½_' qï¿½D.dÍ¤ï¿½eï¿½ï¿½ï¿½mVï¿½4ï¿½ï¿½ï¿½lï¿½ï¿½ï¿½ï¿½Ù¼ï¿½ï¿½ï¿½ï¿½ ï¿½%ï¿½~7{ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½j8ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½vï¿½Yï¿½nï¿½ï¿½ï¿½cU>ï¿½rï¿½ï¿½ï¿½"ï¿½ï¿½ï¿½ï¿½1ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Wï¿½ï¿½ï¿½pï¿½#ï¿½"ï¿½hÄ¤ï¿½/Noï¿½ï¿½ï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½8ï¿½ï¿½'ï¿½ï¿½ei1Lï¿½Dï¿½_@ï¿½9gD1ï¿½ï¿½iï¿½&rÍ°ï¿½Jï¿½-Ç™/ï¿½ï¿½tdï¿½×”ï¿½ ï¿½i7ï¿½(ï¿½6ï¿½ï¿½cï¿½ï¿½iw!ï¿½qï¿½ YrÈPB*>6ï¿½hKï¿½Ø¡ï¿½ï¿½ï¿½%#ï¿½T;ï¿½zï¿½6ï¿½{ï¿½ï¿½ï¿½R%mLE|4ï¿½ï¿½<\CiVzï¿½!shï¿½Â­Pï¿½'Vï¿½ï¿½ï¿½{ï¿½ï¿½Lï¿½eo#ï¿½kï¿½ï¿½3ï¿½Õ–xEï¿½ï¿½ï¿½vï¿½n-ï¿½ï¿½0V>ï¿½2tï¿½ï¿½n#sï¿½ï¿½ï¿½{ï¿½ï¿½6&ï¿½xKï¿½ï¿½UÒ›-ï¿½ï¿½/Kï¿½ï¿½pËï¿½ï¿½x[Ã²ï¿½*pï¿½ï¿½ï¿½Pï¿½d1s`Wzï¿½DIï¿½T40vï¿½ï¿½Å‚hï¿½ ï¿½ï¿½ï¿½Dï¿½@tï¿½ï¿½{j>ï¿½ï¿½oã£´\f~$Cï¿½ï¿½#ï¿½kGbï¿½rï¿½Eï¿½ï¿½ï¿½ï¿½bA$Sï¿½ï¿½ï¿½%^AU7ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½uï¿½
Rï¿½ï¿½Aw2H9ï¿½ï¿½%ï¿½0+ï¿½ï¿½ï¿½ï¿½Jï¿½`ï¿½L:~ï¿½ï¿½9ï¿½ï¿½ï¿½ï¿½zBï¿½ï¿½ï¿½ï¿½xEï¿½Lï¿½IHvï¿½ï¿½Jï¿½LZ=ï¿½+ï¿½d3ï¿½9ï¿½:Bï¿½%QÙ“^ï¿½ ua( _ï¿½2ï¿½ï¿½>gzï¿½ï¿½1ï¿½ï¿½ï¿½Xï¿½hlï¿½YbsPï¿½é•ºH^ï¿½.P]Ì‘lï¿½LJï¿½ï¿½1pKï¿½ï¿½/ï¿½ï¿½Mï¿½ï¿½Ğ±ï¿½ï¿½#ï¿½ï¿½4ï¿½ï¿½Gï¿½ï¿½ï¿½ï¿½VX(mWï¿½:ï¿½ï¿½ï¿½ï¿½Yï¿½$ï¿½ï¿½ï¿½ï¿½*ï¿½Tï¿½Pxï¿½ï¿½-9PgXkEï¿½1[!;ï¿½Ôvï¿½-ï¿½-4\ï¿½ï¿½ï¿½ï¿½[ï¿½cï¿½ï¿½ï¿½0ï¿½0ï¿½mï¿½Gï¿½ï¿½#ï¿½ï¿½fï¿½8#gï¿½w=Oï¿½ï¿½1"Lï¿½ï¿½ANoï¿½ï¿½!ï¿½$-ï¿½ï¿½"Rï¿½ï¿½+ï¿½ï¿½ï¿½ï¿½<aï¿½ï¿½ï¿½{ï¿½ï¿½ï¿½@!RPiQÎÅ ï¿½ï¿½Pï¿½Fkï¿½Å²ï¿½ï¿½ï¿½m]Nï¿½yJï¿½ï¿½ï¿½ï¿½ï¿½ï¿½yï¿½ï¿½Zï¿½fï¿½ï¿½ï¿½4ï¿½uï¿½ymï¿½É‹~Vï¿½ï¿½ï¿½Viï¿½&
	ï¿½iqnØ/ï¿½ï¿½ï¿½:ï¿½ï¿½`ï¿½'ï¿½ï¿½ï¿½2X9%lï¿½ï¿½ï¿½Sï¿½ï¿½Æ°Jiï¿½ï¿½ï¿½ï¿½iDï¿½$ï¿½+yï¿½ï¿½I<3fï¿½ï¿½W;ï¿½8ï¿½ï¿½~lï¿½ï¿½9ï¿½hkï¿½ï¿½ï¿½Drï¿½ï¿½ï¿½OHuï¿½ï¿½=ï¿½uï¿½ï¿½ï¿½ï¿½ï¿½!ï¿½ï¿½.ï¿½ï¿½Ù¿Nk<?ï¿½ï¿½nL&ï¿½[ï¿½ï¿½=<ï¿½ï¿½`ï¿½ï¿½ï¿½ï¿½RMï¿½bï¿½8ï¿½ï¿½?ï¿½zlcS#ï¿½w:Dï¿½/\ï¿½)O|lï¿½ï¿½ï¿½:"ï¿½ï¿½nï¿½ï¿½[dï¿½ÏŸï¿½ï¿½
ï¿½6ï¿½&nnsï¿½ï¿½!ï¿½?Ş³
z;Û»6ï¿½Ç¡ï¿½xyyï¿½.ï¿½ï¿½Öœï¿½ï¿½ï¿½o"ooï¿½ï¿½}?ä§Ÿ6ï¿½ï¿½&ï¿½doï‡¼ï¿½Í¯ï¿½ï¿½ï¿½ï¿½8ï¿½ï¿½ï¿½1ï¿½ï¿½~=ï¿½ï¿½ï¿½_Tï¿½ï¿½ï¿½ï¿½ï¿½5ï¿½ï¿½ï¿½ï¿½m"ß¿ï¿½ï¿½ï¿½ï¿½&?ï¿½qï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½y{ï¿½}ï¿½h{wWAï¿½ç£Ÿ%_ï¿½ï¿½Uoï¿½xoï¿½ï¿½]'ï¿½tï¿½ï¿½?ï¿½ï¿½ï¿½Gï¿½ï¿½~ï¿½ï¿½ï¿½ï¿½?vyï¿½ï¿½>ï¿½ï¿½ï¿½ï¿½ã˜›ï¿½ï¿½cï¿½Dï¿½xï¿½ï¿½ï¿½ï¿½yï¿½Û·ï¿½%ï¿½6n ï¿½ï¿½ï¿½ï¿½&ï¿½ï¿½ï¿½ï¿½Cvï¿½.G{ï¿½Gï¿½ï¿½{5ï¿½~ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½"ï¿½Eï¿½    IENDï¿½B`ï¿½¯OriginalContentÀªSelections¨FilePathÙUC:\Users\ttk08\OneDrive\Documents\GitHub\project\Project2\Project2\Image\longnood.png¨LanguageÀ‘’“¥Value Úôbáº¡n cÃ³ thá»ƒ tháº¥y tÃ´i Ä‘ang xÃ¢y dá»±ng má»™t game Ã¢m nháº¡c áº¥n cÃ¡c nÃºt khi mÃ  cÃ¡c nood Ä‘áº¿n Ä‘Ãºng vá»‹ trÃ­ Ä‘á»ƒ nháº­n Ä‘Æ°á»£c Ä‘iá»ƒm tÃ´i Ä‘Ã£ xÃ¢y dá»±ng xong nood thÆ°á»ng tÆ°Æ¡ng tÃ¡c báº±ng cÃ¡ch nháº¥n nÃºt tÃ´i Ä‘ang xÃ¢y dá»±ng longnood tá»« file áº£nh longnood.png #file:'longnood.png' nÃ³ lÃ  má»™t hÃ¬nh longnood ráº¥t dÃ i vÃ  tÃ´i muá»‘n cÃ³ thá»ƒ chiáº¿u Ä‘Æ°á»£c long nood lÃªn vá»›i chiá»u rá»™ng khÃ´ng Ä‘á»•i vÃ  chiá»u dÃ i tÃ¹y chá»‰nh tÃ´i pháº£i lÃ m saoÀ¨Response…§ContentÚÄá»ƒ hiá»ƒn thá»‹ hÃ¬nh áº£nh longnood vá»›i chiá»u rá»™ng khÃ´ng Ä‘á»•i vÃ  chiá»u dÃ i tÃ¹y chá»‰nh, báº¡n cÃ³ thá»ƒ sá»­ dá»¥ng thÆ° viá»‡n Ä‘á»“ há»a cá»§a C++ nhÆ° SFML hoáº·c SDL. DÆ°á»›i Ä‘Ã¢y lÃ  má»™t vÃ­ dá»¥ vá» cÃ¡ch lÃ m Ä‘iá»u nÃ y vá»›i SFML:

```cpp
#include <SFML/Graphics.hpp>

int main()
{
    // Táº¡o cá»­a sá»• má»›i
    sf::RenderWindow window(sf::VideoMode(800, 600), "Long Nood Game");

    // Táº£i hÃ¬nh áº£nh tá»« file
    sf::Texture texture;
    if (!texture.loadFromFile("longnood.png"))
        return -1;

    // Táº¡o sprite tá»« texture
    sf::Sprite sprite(texture);

    // Äáº·t chiá»u rá»™ng vÃ  chiá»u dÃ i cá»§a sprite
    sprite.setScale(1.f, 2.f); // Thay Ä‘á»•i y scale Ä‘á»ƒ thay Ä‘á»•i chiá»u dÃ i

    while (window.isOpen())
    {
        sf::Event event;
        while (window.pollEvent(event))
        {
            if (event.type == sf::Event::Closed)
                window.close();
        }

        window.clear();
        window.draw(sprite);
        window.display();
    }

    return 0;
}
```

Trong Ä‘oáº¡n mÃ£ trÃªn, hÃ m `sprite.setScale(1.f, 2.f);` Ä‘Æ°á»£c sá»­ dá»¥ng Ä‘á»ƒ thay Ä‘á»•i kÃ­ch thÆ°á»›c cá»§a sprite. Báº¡n cÃ³ thá»ƒ thay Ä‘á»•i giÃ¡ trá»‹ thá»© hai Ä‘á»ƒ Ä‘iá»u chá»‰nh chiá»u dÃ i cá»§a sprite.¤Type ¦Status¯FollowUpPrompts’ÙhLÃ m tháº¿ nÃ o Ä‘á»ƒ tÃ´i cÃ³ thá»ƒ xá»­ lÃ½ sá»± kiá»‡n nháº¥n nÃºt trong game cá»§a mÃ¬nh vá»›i SFML?ÙhCÃ³ cÃ¡ch nÃ o Ä‘á»ƒ tÃ´i cÃ³ thá»ƒ táº¡o hiá»‡u á»©ng chuyá»ƒn Ä‘á»™ng cho hÃ¬nh áº£nh longnood khÃ´ng?³CodeVulnerabilities…¨DateTime×ÿ¹¢ØpeôÿïªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$f0e5f2ca-a064-44bb-9d99-95b83b85c836Ù$6d2dac53-193d-411d-a934-1699c3959649‘’“¥Value ºSprite cÃ³ tÃ¡c dá»¥ng gÃ¬À¨Response…§ContentÚTrong láº­p trÃ¬nh game, má»™t sprite thÆ°á»ng Ä‘Æ°á»£c hiá»ƒu lÃ  má»™t Ä‘á»‘i tÆ°á»£ng Ä‘á»“ há»a 2D Ä‘Æ°á»£c váº½ lÃªn mÃ n hÃ¬nh. Sprites cÃ³ thá»ƒ bao gá»“m cÃ¡c nhÃ¢n váº­t, Ä‘á»‘i tÆ°á»£ng, váº­t pháº©m, ná»n, v.v. trong má»™t game. 

Sprites thÆ°á»ng Ä‘Æ°á»£c sá»­ dá»¥ng Ä‘á»ƒ thá»ƒ hiá»‡n cÃ¡c Ä‘á»‘i tÆ°á»£ng di chuyá»ƒn hoáº·c tÆ°Æ¡ng tÃ¡c trong game. VÃ­ dá»¥, trong má»™t game báº¯n sÃºng, nhÃ¢n váº­t cá»§a báº¡n, káº» thÃ¹, vÃ  cÃ¡c viÃªn Ä‘áº¡n cÃ³ thá»ƒ Ä‘á»u lÃ  sprites.

Sprites cÅ©ng cÃ³ thá»ƒ Ä‘Æ°á»£c sá»­ dá»¥ng Ä‘á»ƒ táº¡o hiá»‡u á»©ng hoáº¡t hÃ¬nh báº±ng cÃ¡ch chuyá»ƒn Ä‘á»•i giá»¯a cÃ¡c hÃ¬nh áº£nh khÃ¡c nhau. VÃ­ dá»¥, má»™t nhÃ¢n váº­t cÃ³ thá»ƒ cÃ³ má»™t sprite cho viá»‡c Ä‘á»©ng yÃªn, má»™t sprite cho viá»‡c di chuyá»ƒn, vÃ  má»™t sprite khÃ¡c cho viá»‡c táº¥n cÃ´ng.

Trong Ä‘oáº¡n mÃ£ báº¡n Ä‘Ã£ cung cáº¥p, `SDL_Texture*` cÃ³ thá»ƒ Ä‘Æ°á»£c coi lÃ  má»™t sprite. NÃ³ Ä‘Æ°á»£c sá»­ dá»¥ng Ä‘á»ƒ lÆ°u trá»¯ hÃ¬nh áº£nh vÃ  sau Ä‘Ã³ Ä‘Æ°á»£c váº½ lÃªn mÃ n hÃ¬nh báº±ng `SDL_RenderCopyEx()`.¤Type ¦Status¯FollowUpPrompts’Ù=LÃ m tháº¿ nÃ o Ä‘á»ƒ táº¡o má»™t sprite animation trong SDL?ÙeCÃ³ cÃ¡ch nÃ o Ä‘á»ƒ quáº£n lÃ½ hiá»‡u suáº¥t khi sá»­ dá»¥ng nhiá»u sprite trong má»™t game khÃ´ng?³CodeVulnerabilities…¨DateTime×ÿªä+@eõ NªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$0e485423-a4df-4f6b-809a-61a11670716cÙ$dc6605bb-ed19-4b94-ab28-a273eb11c813‘’“¥Value Ù.nguyÃªn lÃ½ sá»­ dá»¥ng cá»§a sprite trong sdlÀ¨Response…§ContentÚkTrong thÆ° viá»‡n SDL (Simple DirectMedia Layer), sprite thÆ°á»ng Ä‘Æ°á»£c biá»ƒu diá»…n báº±ng má»™t `SDL_Texture` hoáº·c `SDL_Surface`. ÄÃ¢y lÃ  cÃ¡c Ä‘á»‘i tÆ°á»£ng chá»©a dá»¯ liá»‡u hÃ¬nh áº£nh mÃ  báº¡n muá»‘n váº½ lÃªn mÃ n hÃ¬nh.

DÆ°á»›i Ä‘Ã¢y lÃ  cÃ¡c bÆ°á»›c cÆ¡ báº£n Ä‘á»ƒ sá»­ dá»¥ng sprite trong SDL:

1. **Táº£i hÃ¬nh áº£nh vÃ o má»™t `SDL_Surface` hoáº·c `SDL_Texture`**: Báº¡n cÃ³ thá»ƒ sá»­ dá»¥ng cÃ¡c hÃ m nhÆ° `SDL_LoadBMP()` (Ä‘á»‘i vá»›i cÃ¡c tá»‡p bitmap) hoáº·c `IMG_Load()` (náº¿u báº¡n cÃ³ thÆ° viá»‡n SDL_image vÃ  muá»‘n há»— trá»£ nhiá»u Ä‘á»‹nh dáº¡ng hÃ¬nh áº£nh hÆ¡n) Ä‘á»ƒ táº£i hÃ¬nh áº£nh tá»« tá»‡p vÃ o má»™t `SDL_Surface`. Sau Ä‘Ã³, báº¡n cÃ³ thá»ƒ chuyá»ƒn Ä‘á»•i `SDL_Surface` nÃ y thÃ nh má»™t `SDL_Texture` báº±ng cÃ¡ch sá»­ dá»¥ng `SDL_CreateTextureFromSurface()`.

2. **Váº½ sprite lÃªn mÃ n hÃ¬nh**: Äá»ƒ váº½ sprite lÃªn mÃ n hÃ¬nh, báº¡n sáº½ sá»­ dá»¥ng hÃ m `SDL_RenderCopy()` hoáº·c `SDL_RenderCopyEx()`. Báº¡n cung cáº¥p cho hÃ m nÃ y má»™t `SDL_Renderer` (Ä‘áº¡i diá»‡n cho mÃ n hÃ¬nh), má»™t `SDL_Texture` (sprite cá»§a báº¡n), vÃ  má»™t `SDL_Rect` (Ä‘á»‹nh nghÄ©a vá»‹ trÃ­ vÃ  kÃ­ch thÆ°á»›c cá»§a sprite trÃªn mÃ n hÃ¬nh).

3. **Cáº­p nháº­t mÃ n hÃ¬nh**: Sau khi báº¡n Ä‘Ã£ váº½ táº¥t cáº£ cÃ¡c sprite cá»§a mÃ¬nh, báº¡n sáº½ cáº§n gá»i `SDL_RenderPresent()` Ä‘á»ƒ cáº­p nháº­t mÃ n hÃ¬nh vÃ  hiá»ƒn thá»‹ cÃ¡c thay Ä‘á»•i.

4. **Giáº£i phÃ³ng tÃ i nguyÃªn**: Khi báº¡n Ä‘Ã£ xong vá»›i má»™t sprite, hÃ£y nhá»› giáº£i phÃ³ng tÃ i nguyÃªn mÃ  nÃ³ sá»­ dá»¥ng báº±ng cÃ¡ch gá»i `SDL_DestroyTexture()`.

Trong Ä‘oáº¡n mÃ£ báº¡n Ä‘Ã£ cung cáº¥p, báº¡n cÃ³ thá»ƒ tháº¥y má»™t sá»‘ vÃ­ dá»¥ vá» viá»‡c sá»­ dá»¥ng sprite. VÃ­ dá»¥, hÃ¬nh áº£nh "nood.png" Ä‘Æ°á»£c táº£i vÃ o má»™t `SDL_Surface`, sau Ä‘Ã³ Ä‘Æ°á»£c chuyá»ƒn Ä‘á»•i thÃ nh má»™t `SDL_Texture`. Sau Ä‘Ã³, texture nÃ y Ä‘Æ°á»£c váº½ lÃªn mÃ n hÃ¬nh báº±ng `SDL_RenderCopyEx()`.¤Type ¦Status¯FollowUpPrompts’Ù"How can I animate a sprite in SDL?Ù;What is the difference between SDL_Surface and SDL_Texture?³CodeVulnerabilities…¨DateTime×ÿ†ß@eõ ±ªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$9c35fdf1-9dd4-46af-b348-a6ca728a9454Ù$d92e5cec-9790-4a03-8477-eb1d88089ad2‘’“¥Value Ù,Ã½ tÃ´i lÃ  sprite sáº½ láº¥y gÃ¬ tá»« imageÀ¨Response…§ContentÚ„Trong SDL, má»™t sprite thÆ°á»ng Ä‘Æ°á»£c láº¥y tá»« má»™t pháº§n cá»§a má»™t hÃ¬nh áº£nh lá»›n hÆ¡n, thÆ°á»ng Ä‘Æ°á»£c gá»i lÃ  sprite sheet hoáº·c texture atlas. Má»—i sprite trÃªn sprite sheet Ä‘áº¡i diá»‡n cho má»™t tráº¡ng thÃ¡i hoáº·c khung hÃ¬nh cá»§a má»™t Ä‘á»‘i tÆ°á»£ng trong trÃ² chÆ¡i.

Äá»ƒ láº¥y má»™t sprite tá»« má»™t sprite sheet, báº¡n sáº½ cáº§n xÃ¡c Ä‘á»‹nh má»™t `SDL_Rect` mÃ´ táº£ vá»‹ trÃ­ vÃ  kÃ­ch thÆ°á»›c cá»§a sprite trÃªn sprite sheet. Äiá»u nÃ y thÆ°á»ng bao gá»“m tá»a Ä‘á»™ x, y cá»§a gÃ³c trÃªn cÃ¹ng bÃªn trÃ¡i cá»§a sprite, cÅ©ng nhÆ° chiá»u rá»™ng vÃ  chiá»u cao cá»§a sprite.

Sau Ä‘Ã³, báº¡n sáº½ sá»­ dá»¥ng hÃ m `SDL_RenderCopy()` hoáº·c `SDL_RenderCopyEx()` Ä‘á»ƒ váº½ sprite lÃªn mÃ n hÃ¬nh. Trong hÃ m nÃ y, báº¡n sáº½ cung cáº¥p `SDL_Rect` báº¡n Ä‘Ã£ xÃ¡c Ä‘á»‹nh nhÆ° lÃ  tham sá»‘ "source rectangle". SDL sáº½ láº¥y pixel tá»« sprite sheet báº¯t Ä‘áº§u tá»« gÃ³c trÃªn cÃ¹ng bÃªn trÃ¡i cá»§a source rectangle, vÃ  kÃ©o dÃ i theo chiá»u rá»™ng vÃ  chiá»u cao cá»§a rectangle.

VÃ­ dá»¥, náº¿u báº¡n cÃ³ má»™t sprite sheet vá»›i má»™t sprite náº±m á»Ÿ tá»a Ä‘á»™ (100, 50) trÃªn sprite sheet, vÃ  sprite cÃ³ kÃ­ch thÆ°á»›c lÃ  32x32 pixel, báº¡n sáº½ xÃ¡c Ä‘á»‹nh má»™t `SDL_Rect` nhÆ° sau:

```C++
SDL_Rect sourceRect;
sourceRect.x = 100;
sourceRect.y = 50;
sourceRect.w = 32;
sourceRect.h = 32;
```

Sau Ä‘Ã³, báº¡n sáº½ sá»­ dá»¥ng `sourceRect` nÃ y khi váº½ sprite:

```C++
SDL_RenderCopy(renderer, spriteSheetTexture, &sourceRect, &destinationRect);
```

Trong Ä‘Ã³ `destinationRect` lÃ  má»™t `SDL_Rect` khÃ¡c mÃ´ táº£ vá»‹ trÃ­ vÃ  kÃ­ch thÆ°á»›c mÃ  báº¡n muá»‘n sprite xuáº¥t hiá»‡n trÃªn mÃ n hÃ¬nh.¤Type ¦Status¯FollowUpPrompts’ÙLHow can I animate a sprite using multiple images from a sprite sheet in SDL?ÙPCan you explain how to handle sprite sheet with non-uniform sprite sizes in SDL?³CodeVulnerabilities…¨DateTime×ÿ”ƒÀeõJªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$235fa639-a2b7-4922-910c-19752ce04eddÙ$c4abb21e-5ac0-4f73-9531-16898138c6f1‘’“¥Value ÙEsá»­ dá»¥ng sprite cÃ³ gÃ¬ khÃ¡c so vá»›i dÃ¹ng react bÃ¬nh thÆ°á»ngÀ¨Response…§ContentÚ¶Sá»­ dá»¥ng sprite trong láº­p trÃ¬nh game cÃ³ má»™t sá»‘ lá»£i Ã­ch so vá»›i viá»‡c chá»‰ sá»­ dá»¥ng cÃ¡c hÃ¬nh áº£nh Ä‘Æ¡n láº» (hoáº·c "react" nhÆ° báº¡n Ä‘Ã£ nÃ³i):

1. **Hiá»‡u suáº¥t**: Khi táº¥t cáº£ cÃ¡c hÃ¬nh áº£nh cá»§a má»™t Ä‘á»‘i tÆ°á»£ng hoáº·c nhÃ¢n váº­t game Ä‘Æ°á»£c lÆ°u trong má»™t sprite sheet, mÃ¡y tÃ­nh chá»‰ cáº§n táº£i má»™t tá»‡p hÃ¬nh áº£nh duy nháº¥t vÃ o bá»™ nhá»›. Äiá»u nÃ y giáº£m bá»›t viá»‡c Ä‘á»c/ghi tá»« á»• Ä‘Ä©a vÃ  giÃºp tÄƒng hiá»‡u suáº¥t.

2. **Quáº£n lÃ½ tÃ i nguyÃªn**: Viá»‡c sá»­ dá»¥ng sprite sheet giÃºp tá»• chá»©c cÃ¡c tÃ i nguyÃªn hÃ¬nh áº£nh cá»§a báº¡n má»™t cÃ¡ch hiá»‡u quáº£ hÆ¡n. Báº¡n cÃ³ thá»ƒ dá»… dÃ ng xem vÃ  chá»‰nh sá»­a táº¥t cáº£ cÃ¡c hÃ¬nh áº£nh liÃªn quan Ä‘áº¿n má»™t Ä‘á»‘i tÆ°á»£ng hoáº·c nhÃ¢n váº­t cá»¥ thá»ƒ.

3. **Hoáº¡t áº£nh**: Sprite sheet thÆ°á»ng Ä‘Æ°á»£c sá»­ dá»¥ng Ä‘á»ƒ táº¡o hoáº¡t áº£nh. Má»—i khung hÃ¬nh cá»§a hoáº¡t áº£nh Ä‘Æ°á»£c lÆ°u trá»¯ nhÆ° má»™t sprite riÃªng biá»‡t trÃªn sprite sheet. Báº±ng cÃ¡ch thay Ä‘á»•i sprite hiá»ƒn thá»‹ tá»« sprite sheet theo thá»i gian, báº¡n cÃ³ thá»ƒ táº¡o ra hiá»‡u á»©ng hoáº¡t áº£nh.

Trong khi Ä‘Ã³, viá»‡c sá»­ dá»¥ng cÃ¡c hÃ¬nh áº£nh Ä‘Æ¡n láº» (hoáº·c "react") cÃ³ thá»ƒ Ä‘Æ¡n giáº£n hÆ¡n náº¿u báº¡n chá»‰ cáº§n hiá»ƒn thá»‹ má»™t hÃ¬nh áº£nh tÄ©nh vÃ  khÃ´ng cáº§n Ä‘áº¿n hoáº¡t áº£nh. Tuy nhiÃªn, nÃ³ khÃ´ng mang láº¡i nhá»¯ng lá»£i Ã­ch vá» hiá»‡u suáº¥t vÃ  quáº£n lÃ½ tÃ i nguyÃªn nhÆ° khi sá»­ dá»¥ng sprite.¤Type ¦Status¯FollowUpPrompts’Ù7How can I optimize the use of sprite sheets in my game?ÙICan you provide an example of creating an animation using a sprite sheet?³CodeVulnerabilities…¨DateTime×ÿª×ìàeõªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$9e4e80c5-d8d9-40f6-aaca-52108edf16c6Ù$e6617f5f-9cd4-4ffe-aa20-0f88313ee1c2‘’“¥Value ÙotÃ´i muá»‘n há»i lÃ  SDL_Rect cÅ©ng cÃ³ thá»ƒ láº¥y má»™t pháº§n cá»§a image giá»‘ng nhÆ° sprite Ä‘Ãºng khÃ´ngÀ¨Response…§ContentÚYÄÃºng, `SDL_Rect` cÃ³ thá»ƒ Ä‘Æ°á»£c sá»­ dá»¥ng Ä‘á»ƒ láº¥y má»™t pháº§n cá»§a hÃ¬nh áº£nh, giá»‘ng nhÆ° má»™t sprite. Äiá»u nÃ y thÆ°á»ng Ä‘Æ°á»£c sá»­ dá»¥ng Ä‘á»ƒ táº¡o hoáº¡t áº£nh tá»« má»™t sprite sheet.

Khi báº¡n sá»­ dá»¥ng hÃ m `SDL_RenderCopyEx()`, báº¡n cÃ³ thá»ƒ chá»‰ Ä‘á»‹nh má»™t `SDL_Rect` lÃ m tham sá»‘ nguá»“n (source). `SDL_Rect` nÃ y xÃ¡c Ä‘á»‹nh má»™t hÃ¬nh chá»¯ nháº­t trÃªn hÃ¬nh áº£nh nguá»“n, vÃ  chá»‰ pháº§n cá»§a hÃ¬nh áº£nh trong hÃ¬nh chá»¯ nháº­t nÃ y sáº½ Ä‘Æ°á»£c váº½ lÃªn mÃ n hÃ¬nh.

VÃ­ dá»¥, náº¿u báº¡n cÃ³ má»™t sprite sheet chá»©a cÃ¡c khung hÃ¬nh cá»§a má»™t nhÃ¢n váº­t Ä‘ang cháº¡y, báº¡n cÃ³ thá»ƒ táº¡o má»™t `SDL_Rect` cho má»—i khung hÃ¬nh. Sau Ä‘Ã³, báº¡n cÃ³ thá»ƒ thay Ä‘á»•i `SDL_Rect` nguá»“n mÃ  báº¡n truyá»n vÃ o `SDL_RenderCopyEx()` theo thá»i gian Ä‘á»ƒ táº¡o ra hiá»‡u á»©ng hoáº¡t áº£nh.

DÆ°á»›i Ä‘Ã¢y lÃ  má»™t vÃ­ dá»¥ vá» cÃ¡ch báº¡n cÃ³ thá»ƒ lÃ m Ä‘iá»u nÃ y:

```C++
SDL_Rect sourceRect;
sourceRect.x = currentFrame * spriteWidth; // currentFrame lÃ  khung hÃ¬nh hiá»‡n táº¡i
sourceRect.y = 0;
sourceRect.w = spriteWidth; // spriteWidth lÃ  chiá»u rá»™ng cá»§a má»—i khung hÃ¬nh
sourceRect.h = spriteHeight; // spriteHeight lÃ  chiá»u cao cá»§a má»—i khung hÃ¬nh

SDL_Rect destRect;
destRect.x = xPositionOnScreen;
destRect.y = yPositionOnScreen;
destRect.w = spriteWidth;
destRect.h = spriteHeight;

SDL_RenderCopyEx(renderer, spriteSheetTexture, &sourceRect, &destRect, 0.0, NULL, SDL_FLIP_NONE);
```

Trong vÃ­ dá»¥ trÃªn, `currentFrame` Ä‘Æ°á»£c thay Ä‘á»•i theo thá»i gian Ä‘á»ƒ hiá»ƒn thá»‹ cÃ¡c khung hÃ¬nh khÃ¡c nhau tá»« sprite sheet.¤Type ¦Status¯FollowUpPrompts’ÙHLÃ m tháº¿ nÃ o Ä‘á»ƒ tÃ´i cÃ³ thá»ƒ táº¡o má»™t sprite sheet trong SDL?ÙdCÃ³ cÃ¡ch nÃ o Ä‘á»ƒ tÃ´i cÃ³ thá»ƒ tá»‘i Æ°u hÃ³a viá»‡c sá»­ dá»¥ng sprite sheet trong SDL khÃ´ng?³CodeVulnerabilities…¨DateTime×ÿä¥"Ğeõ+ªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$caed9b39-5cc2-4037-bbc6-4f08fdf3eac0Ù$7a32e0ab-6887-41b6-b674-2f9ab6b38319‘’“¥Value Ú,longnood.png cá»§a tÃ´i lÃ  má»™t hÃ¬nh áº£nh má»™t Ä‘Æ°á»ng dÃ i  nood dÃ i 22-883 vá»›i hÃ i Ä‘áº§u trÃªn Ä‘Æ°á»£c lÃ m trÃ²n láº¡i Ä‘á»ƒ thá»ƒ hiá»‡n Ä‘áº§u vÃ  cuá»‘i lÃ m sao Ä‘á»ƒ tÃ´i láº¥y Ä‘Æ°á»£c hÃ¬nh áº£nh má»™t longnood ra vá»›i kÃ­ch cá»¡ tÃ¹y chá»‰nh mÃ  váº«n giá»¯ Ä‘Æ°á»£c 2 Ä‘áº§uÀ¨Response…§ContentÚôÄá»ƒ giá»¯ nguyÃªn hÃ¬nh dáº¡ng cá»§a Ä‘áº§u vÃ  cuá»‘i cá»§a `longnood`, báº¡n cÃ³ thá»ƒ sá»­ dá»¥ng hai `SDL_Rect` riÃªng biá»‡t: má»™t cho pháº§n Ä‘áº§u vÃ  má»™t cho pháº§n thÃ¢n. Pháº§n thÃ¢n cÃ³ thá»ƒ Ä‘Æ°á»£c kÃ©o dÃ i hoáº·c thu ngáº¯n tÃ¹y Ã½ mÃ  khÃ´ng áº£nh hÆ°á»Ÿng Ä‘áº¿n pháº§n Ä‘áº§u.

DÆ°á»›i Ä‘Ã¢y lÃ  má»™t vÃ­ dá»¥ vá» cÃ¡ch báº¡n cÃ³ thá»ƒ lÃ m Ä‘iá»u nÃ y:

```C++
// Táº¡o SDL_Rect cho pháº§n Ä‘áº§u cá»§a longnood
SDL_Rect headRect;
headRect.x = 0;
headRect.y = 0;
headRect.w = 22; // Chiá»u rá»™ng cá»§a pháº§n Ä‘áº§u
headRect.h = 22; // Chiá»u cao cá»§a pháº§n Ä‘áº§u

// Táº¡o SDL_Rect cho pháº§n thÃ¢n cá»§a longnood
SDL_Rect bodyRect;
bodyRect.x = 0;
bodyRect.y = 22; // Báº¯t Ä‘áº§u tá»« cuá»‘i pháº§n Ä‘áº§u
bodyRect.w = 22; // Chiá»u rá»™ng cá»§a pháº§n thÃ¢n
bodyRect.h = customLength - 44; // Chiá»u dÃ i tÃ¹y chá»‰nh, trá»« Ä‘i chiá»u dÃ i cá»§a pháº§n Ä‘áº§u vÃ  cuá»‘i

// Táº¡o SDL_Rect cho pháº§n cuá»‘i cá»§a longnood
SDL_Rect tailRect;
tailRect.x = 0;
tailRect.y = 883 - 22; // Báº¯t Ä‘áº§u tá»« cuá»‘i hÃ¬nh áº£nh
tailRect.w = 22; // Chiá»u rá»™ng cá»§a pháº§n cuá»‘i
tailRect.h = 22; // Chiá»u cao cá»§a pháº§n cuá»‘i

// Váº½ pháº§n Ä‘áº§u, thÃ¢n vÃ  cuá»‘i cá»§a longnood
SDL_RenderCopyEx(renderer, longnoodTexture, &headRect, &destRect, 0.0, NULL, SDL_FLIP_NONE);
SDL_RenderCopyEx(renderer, longnoodTexture, &bodyRect, &destRect, 0.0, NULL, SDL_FLIP_NONE);
SDL_RenderCopyEx(renderer, longnoodTexture, &tailRect, &destRect, 0.0, NULL, SDL_FLIP_NONE);
```

Trong vÃ­ dá»¥ trÃªn, `customLength` lÃ  chiá»u dÃ i tÃ¹y chá»‰nh cá»§a `longnood` mÃ  báº¡n muá»‘n váº½. Báº¡n cáº§n Ä‘iá»u chá»‰nh `destRect` cho má»—i láº§n gá»i `SDL_RenderCopyEx()` Ä‘á»ƒ váº½ pháº§n Ä‘áº§u, thÃ¢n vÃ  cuá»‘i á»Ÿ vá»‹ trÃ­ Ä‘Ãºng trÃªn mÃ n hÃ¬nh.¤Type ¦Status¯FollowUpPrompts’Ù¥LÃ m tháº¿ nÃ o Ä‘á»ƒ tÃ´i cÃ³ thá»ƒ váº½ pháº§n thÃ¢n cá»§a longnood vá»›i chiá»u dÃ i tÃ¹y chá»‰nh mÃ  khÃ´ng lÃ m áº£nh hÆ°á»Ÿng Ä‘áº¿n pháº§n Ä‘áº§u vÃ  cuá»‘i?ÙiCÃ³ cÃ¡ch nÃ o Ä‘á»ƒ tÃ´i cÃ³ thá»ƒ váº½ longnood vá»›i chiá»u dÃ i tÃ¹y chá»‰nh mÃ  khÃ´ng cáº§n sá»­ d³CodeVulnerabilities…¨DateTime×ÿ‚Ûeõ@ªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$461fccca-df1f-4fc1-95e7-966a8ba8ae9cÙ$bbacd5fd-3988-4027-b5c8-26bf1692f49b‘’“¥Value Ù‰táº¡o cho tÃ´i má»™t hÃ m nháº­n vÃ o render vÃ  thÃ´ng sá»‘ chiá»u dÃ i vá»‹ trÃ­ in ra trÃªn mÃ n hÃ¬nh Ä‘á»ƒ lÃ m Ä‘Æ°á»£c nhÆ° trÃªnÀ¨Response…§ContentÚÃDÆ°á»›i Ä‘Ã¢y lÃ  má»™t hÃ m cÃ³ thá»ƒ giÃºp báº¡n váº½ `longnood` vá»›i chiá»u dÃ i tÃ¹y chá»‰nh vÃ  vá»‹ trÃ­ tÃ¹y chá»‰nh:

```C++
void renderLongnood(SDL_Renderer* renderer, SDL_Texture* longnoodTexture, int customLength, int posX, int posY) {
    // Táº¡o SDL_Rect cho pháº§n Ä‘áº§u cá»§a longnood
    SDL_Rect headRect = { 0, 0, 22, 22 };
    SDL_Rect destHeadRect = { posX, posY, 22, 22 };

    // Táº¡o SDL_Rect cho pháº§n thÃ¢n cá»§a longnood
    SDL_Rect bodyRect = { 0, 22, 22, 883 - 44 };
    SDL_Rect destBodyRect = { posX, posY + 22, 22, customLength - 44 };

    // Táº¡o SDL_Rect cho pháº§n cuá»‘i cá»§a longnood
    SDL_Rect tailRect = { 0, 883 - 22, 22, 22 };
    SDL_Rect destTailRect = { posX, posY + customLength - 22, 22, 22 };

    // Váº½ pháº§n Ä‘áº§u, thÃ¢n vÃ  cuá»‘i cá»§a longnood
    SDL_RenderCopyEx(renderer, longnoodTexture, &headRect, &destHeadRect, 0.0, NULL, SDL_FLIP_NONE);
    SDL_RenderCopyEx(renderer, longnoodTexture, &bodyRect, &destBodyRect, 0.0, NULL, SDL_FLIP_NONE);
    SDL_RenderCopyEx(renderer, longnoodTexture, &tailRect, &destTailRect, 0.0, NULL, SDL_FLIP_NONE);
}
```

Báº¡n cÃ³ thá»ƒ sá»­ dá»¥ng hÃ m nÃ y trong hÃ m `main` cá»§a báº¡n nhÆ° sau:

```C++
// Trong hÃ m main
renderLongnood(renderer, longnoodTexture, 200, 205, 50);
```

HÃ m `renderLongnood` nháº­n vÃ o má»™t `SDL_Renderer*`, má»™t `SDL_Texture*` cho `longnood`, má»™t chiá»u dÃ i tÃ¹y chá»‰nh, vÃ  tá»a Ä‘á»™ x, y Ä‘á»ƒ váº½ `longnood` trÃªn mÃ n hÃ¬nh.¤Type ¦Status¯FollowUpPrompts’ÙBHow can I modify the function to change the color of the longnood?ÙXCan I use this function to render multiple longnoods at different positions and lengths?³CodeVulnerabilities…¨DateTime×ÿj¼ƒ eõ©»ªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$695ca98d-4031-48ee-9a54-4e8dd922ff26Ù$2927812d-7d26-4942-98c0-03cdb733ef4f‘’“¥Value Ùlsá»­a hÃ m chá»‰ cáº§n pháº§n Ä‘áº§u vÃ  cuá»‘i thÃ´i khÃ´ng cáº§n render 3 láº§n Ä‘á»ƒ giáº£m Ã¡p lá»±c cpuÀ¨Response…§ContentÚåBáº¡n cÃ³ thá»ƒ thay Ä‘á»•i hÃ m `renderLongnood` Ä‘á»ƒ chá»‰ váº½ pháº§n Ä‘áº§u vÃ  cuá»‘i cá»§a "longnood". ÄÃ¢y lÃ  cÃ¡ch báº¡n cÃ³ thá»ƒ lÃ m Ä‘iá»u Ä‘Ã³:

```C++
void renderLongnood(SDL_Renderer* renderer, SDL_Texture* longnoodTexture, int customLength, int posX, int posY) {
    // Táº¡o SDL_Rect cho pháº§n Ä‘áº§u cá»§a longnood
    SDL_Rect headRect = { 0, 0, 22, 22 };
    SDL_Rect destHeadRect = { posX, posY, 22, 22 };

    // Táº¡o SDL_Rect cho pháº§n cuá»‘i cá»§a longnood
    SDL_Rect tailRect = { 0, 883 - 22, 22, 22 };
    SDL_Rect destTailRect = { posX, posY + customLength - 22, 22, 22 };

    // Váº½ pháº§n Ä‘áº§u vÃ  cuá»‘i cá»§a longnood
    SDL_RenderCopyEx(renderer, longnoodTexture, &headRect, &destHeadRect, 0.0, NULL, SDL_FLIP_NONE);
    SDL_RenderCopyEx(renderer, longnoodTexture, &tailRect, &destTailRect, 0.0, NULL, SDL_FLIP_NONE);
}
```

LÆ°u Ã½ ráº±ng viá»‡c loáº¡i bá» viá»‡c váº½ pháº§n thÃ¢n cá»§a "longnood" cÃ³ thá»ƒ lÃ m thay Ä‘á»•i cÃ¡ch nÃ³ hiá»ƒn thá»‹.¤Type ¦Status¯FollowUpPrompts’ÙPDoes this change affect the visual representation of the "longnood" in the game?Ù*How can I optimize other parts of my code?³CodeVulnerabilities…¨DateTime×ÿGñX eõª=ªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$93445118-2b78-41dd-8a4e-1c1201c01a94Ù$fcf4c18d-d91e-4008-af72-afe9c0991683‘’“¥Value Ù{nhÆ°ng mÃ  chiá»u dÃ i váº«n tÃ¹y chá»‰nh Ã½ tÃ´i lÃ  chiá»u dÃ i cá»§a node long sáº½ chia ra 2 pháº§n Ä‘áº§u vÃ  cuá»‘iÀ¨Response…§ContentÚàÄá»ƒ giá»¯ chiá»u dÃ i tÃ¹y chá»‰nh cá»§a "longnood" vÃ  chá»‰ váº½ pháº§n Ä‘áº§u vÃ  cuá»‘i, báº¡n cÃ³ thá»ƒ thay Ä‘á»•i hÃ m `renderLongnood` nhÆ° sau:

```C++
void renderLongnood(SDL_Renderer* renderer, SDL_Texture* longnoodTexture, int customLength, int posX, int posY) {
    // Táº¡o SDL_Rect cho pháº§n Ä‘áº§u cá»§a longnood
    SDL_Rect headRect = { 0, 0, 22, 22 };
    SDL_Rect destHeadRect = { posX, posY, 22, 22 };

    // Táº¡o SDL_Rect cho pháº§n cuá»‘i cá»§a longnood
    SDL_Rect tailRect = { 0, 883 - 22, 22, 22 };
    SDL_Rect destTailRect = { posX, posY + customLength - 22, 22, 22 };

    // Váº½ pháº§n Ä‘áº§u vÃ  cuá»‘i cá»§a longnood
    SDL_RenderCopyEx(renderer, longnoodTexture, &headRect, &destHeadRect, 0.0, NULL, SDL_FLIP_NONE);
    SDL_RenderCopyEx(renderer, longnoodTexture, &tailRect, &destTailRect, 0.0, NULL, SDL_FLIP_NONE);
}
```

LÆ°u Ã½ ráº±ng viá»‡c loáº¡i bá» viá»‡c váº½ pháº§n thÃ¢n cá»§a "longnood" cÃ³ thá»ƒ lÃ m thay Ä‘á»•i cÃ¡ch nÃ³ hiá»ƒn thá»‹.¤Type ¦Status¯FollowUpPrompts’ÙcHow can I modify the function to also render the body of the "longnood" but with a lower frequency?ÙWCan I adjust the size of the head and tail separately in the `renderLongnood` function?³CodeVulnerabilities…¨DateTime×ÿ}TñPeõ¬»ªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$6be1f61c-6fe2-4be2-88da-e542b318d000Ù$0ba70d1d-3f35-479f-beb6-b0b82dd2dab5‘’“¥Value Ù7náº¿u sá»­ dá»¥ng sprite thÃ¬ cÃ³ tá»‘i Æ°u hÆ¡n khÃ´ngÀ¨Response…§ContentÚ)Sá»­ dá»¥ng sprite sheets cÃ³ thá»ƒ tá»‘i Æ°u hÃ³a hiá»‡u suáº¥t cá»§a á»©ng dá»¥ng cá»§a báº¡n trong má»™t sá»‘ cÃ¡ch:

1. **Giáº£m sá»‘ lÆ°á»£ng láº§n load tÃ i nguyÃªn:** Khi táº¥t cáº£ cÃ¡c sprite Ä‘á»u náº±m trong má»™t sprite sheet duy nháº¥t, báº¡n chá»‰ cáº§n load tÃ i nguyÃªn má»™t láº§n. Äiá»u nÃ y giÃºp giáº£m thá»i gian load vÃ  giáº£m bá»™ nhá»› sá»­ dá»¥ng.

2. **Giáº£m sá»‘ lÆ°á»£ng láº§n váº½:** Khi sá»­ dá»¥ng sprite sheets, báº¡n cÃ³ thá»ƒ váº½ nhiá»u sprite cÃ¹ng má»™t lÃºc thay vÃ¬ pháº£i váº½ tá»«ng sprite má»™t. Äiá»u nÃ y giÃºp giáº£m sá»‘ lÆ°á»£ng láº§n gá»i hÃ m váº½, tá»« Ä‘Ã³ tÄƒng hiá»‡u suáº¥t.

3. **Giáº£m sá»‘ lÆ°á»£ng láº§n chuyá»ƒn Ä‘á»•i texture:** Khi váº½ nhiá»u sprite tá»« cÃ¹ng má»™t sprite sheet, báº¡n khÃ´ng cáº§n pháº£i chuyá»ƒn Ä‘á»•i giá»¯a cÃ¡c texture khÃ¡c nhau. Äiá»u nÃ y giÃºp giáº£m thá»i gian chuyá»ƒn Ä‘á»•i texture, tá»« Ä‘Ã³ tÄƒng hiá»‡u suáº¥t.

Tuy nhiÃªn, viá»‡c sá»­ dá»¥ng sprite sheets cÅ©ng cÃ³ nhÆ°á»£c Ä‘iá»ƒm cá»§a nÃ³. Viá»‡c quáº£n lÃ½ sprite sheets cÃ³ thá»ƒ trá»Ÿ nÃªn phá»©c táº¡p, Ä‘áº·c biá»‡t lÃ  khi báº¡n cÃ³ nhiá»u sprite vá»›i kÃ­ch thÆ°á»›c khÃ¡c nhau. Báº¡n cÅ©ng cáº§n pháº£i cáº©n tháº­n Ä‘á»ƒ khÃ´ng táº¡o ra sprite sheets quÃ¡ lá»›n, vÃ¬ Ä‘iá»u nÃ y cÃ³ thá»ƒ gÃ¢y ra váº¥n Ä‘á» vá»›i bá»™ nhá»› vÃ  hiá»‡u suáº¥t.¤Type ¦Status¯FollowUpPrompts’Ù:How can I implement a sprite sheet in my current C++ code?ÙACan you provide an example of how to use a sprite sheet with SDL?³CodeVulnerabilities…¨DateTime×ÿ×­ eõ­ªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$b31f0cc7-3c0d-459e-a208-ae9f659079d9Ù$b4a31cf6-fca0-47c0-8e3e-5cb51a84bddc‘’“¥Value ÙUviá»‡c sá»­ dá»¥ng sprite cho hÃ m renderlongnood cá»§a tÃ´i cÃ³ tÃ´i Æ°u hÆ¡n khÃ´ngÀ¨Response…§ContentÚ-Sá»­ dá»¥ng sprite sheets cÃ³ thá»ƒ giÃºp tá»‘i Æ°u hÃ³a hiá»‡u suáº¥t cá»§a hÃ m `renderLongnood` cá»§a báº¡n. Hiá»‡n táº¡i, báº¡n Ä‘ang váº½ pháº§n Ä‘áº§u vÃ  pháº§n cuá»‘i cá»§a "longnood" riÃªng láº». Náº¿u báº¡n cÃ³ má»™t sprite sheet chá»©a cáº£ pháº§n Ä‘áº§u vÃ  pháº§n cuá»‘i, báº¡n cÃ³ thá»ƒ váº½ cáº£ "longnood" chá»‰ trong má»™t láº§n gá»i hÃ m `SDL_RenderCopyEx`.

Tuy nhiÃªn, viá»‡c nÃ y cÅ©ng cÃ³ má»™t sá»‘ háº¡n cháº¿. Äáº§u tiÃªn, báº¡n sáº½ cáº§n pháº£i táº¡o má»™t sprite sheet chá»©a cáº£ pháº§n Ä‘áº§u vÃ  pháº§n cuá»‘i cá»§a "longnood". Äiá»u nÃ y cÃ³ thá»ƒ Ä‘Ã²i há»i thÃªm cÃ´ng viá»‡c thiáº¿t káº¿ Ä‘á»“ há»a. Thá»© hai, náº¿u "longnood" cá»§a báº¡n cÃ³ Ä‘á»™ dÃ i tÃ¹y chá»‰nh, viá»‡c sá»­ dá»¥ng sprite sheet cÃ³ thá»ƒ khÃ´ng pháº£i lÃ  lá»±a chá»n tá»‘t nháº¥t, vÃ¬ báº¡n sáº½ cáº§n pháº£i táº¡o má»™t sprite sheet riÃªng cho má»—i Ä‘á»™ dÃ i khÃ¡c nhau.

Náº¿u "longnood" cá»§a báº¡n cÃ³ Ä‘á»™ dÃ i cá»‘ Ä‘á»‹nh, tÃ´i khuyÃªn báº¡n nÃªn sá»­ dá»¥ng sprite sheet. Náº¿u khÃ´ng, báº¡n cÃ³ thá»ƒ muá»‘n giá»¯ nguyÃªn cÃ¡ch hiá»‡n táº¡i.¤Type ¦Status¯FollowUpPrompts’ÙILÃ m tháº¿ nÃ o Ä‘á»ƒ táº¡o má»™t sprite sheet cho "longnood" cá»§a tÃ´i?ÙyCÃ³ cÃ¡ch nÃ o Ä‘á»ƒ tá»‘i Æ°u hÃ³a hÃ m `renderLongnood` náº¿u "longnood" cá»§a tÃ´i cÃ³ Ä‘á»™ dÃ i tÃ¹y chá»‰nh khÃ´ng?³CodeVulnerabilities…¨DateTime×ÿ‡_êeõÃêªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$c0c56133-f970-431f-8b26-25f62870f432Ù$c085468a-336b-470e-a57e-5fec3b66be35‘’“¥Value Ù2cÃ³ cÃ¡ch nÃ o ghÃ©p vÃ²ng for cho 2 máº£ng khÃ´ngÀ¨Response…§ContentÚCÃ³ thá»ƒ ghÃ©p vÃ²ng láº·p `for` cho hai máº£ng, nhÆ°ng báº¡n cáº§n Ä‘áº£m báº£o ráº±ng cáº£ hai máº£ng Ä‘á»u cÃ³ cÃ¹ng kÃ­ch thÆ°á»›c. DÆ°á»›i Ä‘Ã¢y lÃ  má»™t vÃ­ dá»¥ vá» cÃ¡ch lÃ m Ä‘iá»u nÃ y trong C++:

```C++
std::vector<int> array1 = {1, 2, 3, 4, 5};
std::vector<int> array2 = {6, 7, 8, 9, 10};

for (size_t i = 0; i < array1.size(); ++i) {
    std::cout << "Array1[" << i << "] = " << array1[i] << ", ";
    std::cout << "Array2[" << i << "] = " << array2[i] << std::endl;
}
```

Trong Ä‘oáº¡n mÃ£ trÃªn, chÃºng tÃ´i sá»­ dá»¥ng má»™t vÃ²ng láº·p `for` Ä‘á»ƒ duyá»‡t qua cáº£ hai máº£ng cÃ¹ng má»™t lÃºc. LÆ°u Ã½ ráº±ng Ä‘iá»u nÃ y chá»‰ hoáº¡t Ä‘á»™ng náº¿u cáº£ hai máº£ng Ä‘á»u cÃ³ cÃ¹ng kÃ­ch thÆ°á»›c. Náº¿u chÃºng cÃ³ kÃ­ch thÆ°á»›c khÃ¡c nhau, báº¡n sáº½ cáº§n pháº£i xá»­ lÃ½ trÆ°á»ng há»£p nÃ y má»™t cÃ¡ch cáº©n tháº­n Ä‘á»ƒ trÃ¡nh truy cáº­p vÃ o vá»‹ trÃ­ khÃ´ng há»£p lá»‡ trong máº£ng ngáº¯n hÆ¡n.¤Type ¦Status¯FollowUpPrompts’ÙXLÃ m tháº¿ nÃ o Ä‘á»ƒ xá»­ lÃ½ trÆ°á»ng há»£p hai máº£ng cÃ³ kÃ­ch thÆ°á»›c khÃ¡c nhau?Ù<CÃ³ cÃ¡ch nÃ o Ä‘á»ƒ tá»‘i Æ°u hÃ³a vÃ²ng láº·p nÃ y khÃ´ng?³CodeVulnerabilities…¨DateTime×ÿ>ï eõÄªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$d5cc5576-a080-46ce-b254-67ff215e9da2Ù$49217400-2df1-4b86-97e2-acf5fafe13b2‘’“¥Value Ù\Ã½ tÃ´i lÃ  vÃ²ng for each tÃ´i muá»‘n xá»­ lÃ½ vá»›i tá»«ng pháº§n tá»­ trong cáº£ 2 máº£ngÀ¨Response…§ContentÚæÄá»ƒ xá»­ lÃ½ tá»«ng pháº§n tá»­ trong cáº£ hai máº£ng báº±ng vÃ²ng láº·p `for each`, báº¡n cáº§n Ä‘áº£m báº£o ráº±ng cáº£ hai máº£ng Ä‘á»u cÃ³ cÃ¹ng kÃ­ch thÆ°á»›c. DÆ°á»›i Ä‘Ã¢y lÃ  má»™t vÃ­ dá»¥ vá» cÃ¡ch lÃ m Ä‘iá»u nÃ y trong C++:

```C++
std::vector<int> array1 = {1, 2, 3, 4, 5};
std::vector<int> array2 = {6, 7, 8, 9, 10};

auto it1 = array1.begin();
auto it2 = array2.begin();

for (; it1 != array1.end() && it2 != array2.end(); ++it1, ++it2) {
    std::cout << "Array1 value = " << *it1 << ", ";
    std::cout << "Array2 value = " << *it2 << std::endl;
}
```

Trong Ä‘oáº¡n mÃ£ trÃªn, chÃºng tÃ´i sá»­ dá»¥ng hai iterator Ä‘á»ƒ duyá»‡t qua cáº£ hai máº£ng cÃ¹ng má»™t lÃºc. LÆ°u Ã½ ráº±ng Ä‘iá»u nÃ y chá»‰ hoáº¡t Ä‘á»™ng náº¿u cáº£ hai máº£ng Ä‘á»u cÃ³ cÃ¹ng kÃ­ch thÆ°á»›c. Náº¿u chÃºng cÃ³ kÃ­ch thÆ°á»›c khÃ¡c nhau, báº¡n sáº½ cáº§n pháº£i xá»­ lÃ½ trÆ°á»ng há»£p nÃ y má»™t cÃ¡ch cáº©n tháº­n Ä‘á»ƒ trÃ¡nh truy cáº­p vÃ o vá»‹ trÃ­ khÃ´ng há»£p lá»‡ trong máº£ng ngáº¯n hÆ¡n.¤Type ¦Status¯FollowUpPrompts’ÙXLÃ m tháº¿ nÃ o Ä‘á»ƒ xá»­ lÃ½ trÆ°á»ng há»£p hai máº£ng cÃ³ kÃ­ch thÆ°á»›c khÃ¡c nhau?Ù<CÃ³ cÃ¡ch nÃ o Ä‘á»ƒ tá»‘i Æ°u hÃ³a vÃ²ng láº·p nÃ y khÃ´ng?³CodeVulnerabilities…¨DateTime×ÿ>Ò¨ğeõÅ2ªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$86a92500-2309-4eb4-9548-f0d3ec382cedÙ$ccae051a-fe9b-4c5f-b129-4e9ab94cfd42‘’“¥Value Ù…tÃ´i muá»‘n táº¡o struct long nood káº¿ thá»«a thuá»™c tÃ­nh tá»« nood nhÆ°ng cÃ³ thÃªm biáº¿n int length vÃ  biáº¿n bool isbeingholdÀ¨Response…§ContentÚABáº¡n cÃ³ thá»ƒ táº¡o má»™t struct `LongNood` káº¿ thá»«a tá»« `Nood` nhÆ° sau:

```C++
struct LongNood : Noods {
    int length;
    bool isBeingHold;
};
```

Trong Ä‘oáº¡n mÃ£ trÃªn, `LongNood` káº¿ thá»«a táº¥t cáº£ cÃ¡c thuá»™c tÃ­nh tá»« `Noods` vÃ  thÃªm vÃ o hai thuá»™c tÃ­nh má»›i lÃ  `length` vÃ  `isBeingHold`.¤Type ¦Status¯FollowUpPrompts’Ù6How can I initialize an object of the LongNood struct?ÙBCan I use the LongNood struct in the same way as the Noods struct?³CodeVulnerabilities…¨DateTime×ÿ|á	peõÇªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$608816a2-4406-4546-8aaa-baa2fa4f843aÙ$35899424-35db-4597-901f-4200bfb0a7d9‘’“¥Value Ù¼tÃ´i muá»‘n sá»§a láº¡i cac vÃ²ng for lÃºc trÆ°á»›c for each vá»›i má»—i pháº§n tá»­ trong máº£ng noods láº¥y thÃªm pháº§n tá»­ trong máº£ng longnoods thÃ¬ pháº£i lÃ m sao cho nhanh nháº¥tÀ¨Response…§ContentÚÕBáº¡n cÃ³ thá»ƒ sá»­ dá»¥ng `std::for_each` tá»« thÆ° viá»‡n `<algorithm>` Ä‘á»ƒ láº·p qua má»—i pháº§n tá»­ trong máº£ng `noods` vÃ  `longnoods`. ÄÃ¢y lÃ  má»™t cÃ¡ch hiá»‡u quáº£ vÃ  nhanh chÃ³ng Ä‘á»ƒ thá»±c hiá»‡n Ä‘iá»u nÃ y.

DÆ°á»›i Ä‘Ã¢y lÃ  má»™t vÃ­ dá»¥ vá» cÃ¡ch báº¡n cÃ³ thá»ƒ thá»±c hiá»‡n Ä‘iá»u nÃ y:

```C++
#include <algorithm>

// ...

std::for_each(noods.begin(), noods.end(), [](Noods& nood) {
    // Thá»±c hiá»‡n cÃ¡c thao tÃ¡c trÃªn tá»«ng pháº§n tá»­ 'nood' á»Ÿ Ä‘Ã¢y
});

std::for_each(longnoods.begin(), longnoods.end(), [](Longnoods& longnood) {
    // Thá»±c hiá»‡n cÃ¡c thao tÃ¡c trÃªn tá»«ng pháº§n tá»­ 'longnood' á»Ÿ Ä‘Ã¢y
});
```

Trong Ä‘oáº¡n mÃ£ trÃªn, chÃºng tÃ´i sá»­ dá»¥ng má»™t hÃ m lambda (Ä‘Æ°á»£c chá»‰ Ä‘á»‹nh bá»Ÿi `[]`) Ä‘á»ƒ xÃ¡c Ä‘á»‹nh hÃ nh Ä‘á»™ng cáº§n thá»±c hiá»‡n trÃªn tá»«ng pháº§n tá»­ cá»§a máº£ng. Báº¡n cÃ³ thá»ƒ thay tháº¿ pháº§n nÃ y báº±ng báº¥t ká»³ hÃ m nÃ o báº¡n muá»‘n.

LÆ°u Ã½ ráº±ng `std::for_each` sáº½ láº·p qua má»—i pháº§n tá»­ trong máº£ng tá»« Ä‘áº§u Ä‘áº¿n cuá»‘i, nÃªn náº¿u báº¡n cáº§n thá»±c hiá»‡n má»™t hÃ nh Ä‘á»™ng cá»¥ thá»ƒ dá»±a trÃªn chá»‰ má»¥c cá»§a pháº§n tá»­, báº¡n cÃ³ thá»ƒ cáº§n sá»­ dá»¥ng má»™t vÃ²ng láº·p `for` truyá»n thá»‘ng.¤Type ¦Status¯FollowUpPrompts’Ù]LÃ m tháº¿ nÃ o Ä‘á»ƒ tÃ´i thÃªm má»™t Ä‘iá»u kiá»‡n vÃ o hÃ m lambda trong `std::for_each`?ÙhCÃ³ cÃ¡ch nÃ o Ä‘á»ƒ tÃ´i sá»­ dá»¥ng `std::for_each` vá»›i má»™t hÃ m thÃ nh viÃªn cá»§a struct khÃ´ng?³CodeVulnerabilities…¨DateTime×ÿg¸¼ eõÇPªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$7327dbc2-d1a2-4ec8-a38f-b600bea5aebaÙ$e9984481-aa87-48fc-8a9b-68d5d5d767ee‘’“¥Value ÙštÃ´i muá»‘n trong 1 vÃ²ng for thÃ´i nhÆ°ng náº¿u háº¿t pháº§n tá»­ trong máº£ng noods thÃ¬ duyá»‡t tiáº¿p cÃ¡c pháº§n tá»­ trong longnoods Ä‘Æ°á»£c khÃ´ngÀ¨Response…§ContentÚCÃ³ thá»ƒ, báº¡n cÃ³ thá»ƒ sá»­ dá»¥ng má»™t vÃ²ng láº·p `for` duy nháº¥t Ä‘á»ƒ duyá»‡t qua cáº£ hai máº£ng `noods` vÃ  `longnoods`. Äá»ƒ lÃ m Ä‘iá»u nÃ y, báº¡n cÃ³ thá»ƒ sá»­ dá»¥ng má»™t máº¹o nhá»: táº¡o má»™t vector má»›i chá»©a cáº£ hai máº£ng vÃ  sau Ä‘Ã³ duyá»‡t qua nÃ³.

DÆ°á»›i Ä‘Ã¢y lÃ  má»™t vÃ­ dá»¥ vá» cÃ¡ch báº¡n cÃ³ thá»ƒ thá»±c hiá»‡n Ä‘iá»u nÃ y:

```C++
// Táº¡o má»™t vector má»›i chá»©a cáº£ hai máº£ng
std::vector<Noods> combined(noods);
combined.insert(combined.end(), longnoods.begin(), longnoods.end());

// Duyá»‡t qua vector má»›i
for (Noods& nood : combined) {
    // Thá»±c hiá»‡n cÃ¡c thao tÃ¡c trÃªn tá»«ng pháº§n tá»­ 'nood' á»Ÿ Ä‘Ã¢y
}
```

Trong Ä‘oáº¡n mÃ£ trÃªn, chÃºng tÃ´i táº¡o má»™t vector má»›i `combined` chá»©a táº¥t cáº£ cÃ¡c pháº§n tá»­ tá»« `noods` vÃ  `longnoods`. Sau Ä‘Ã³, chÃºng tÃ´i sá»­ dá»¥ng má»™t vÃ²ng láº·p `for` Ä‘á»ƒ duyá»‡t qua má»—i pháº§n tá»­ trong `combined`.

LÆ°u Ã½ ráº±ng Ä‘oáº¡n mÃ£ nÃ y sáº½ táº¡o ra má»™t báº£n sao cá»§a cáº£ hai máº£ng, nÃªn náº¿u báº¡n cÃ³ ráº¥t nhiá»u dá»¯ liá»‡u, Ä‘iá»u nÃ y cÃ³ thá»ƒ tá»‘n kÃ©m vá» máº·t bá»™ nhá»›. Náº¿u Ä‘Ã¢y lÃ  má»™t váº¥n Ä‘á», báº¡n cÃ³ thá»ƒ muá»‘n xem xÃ©t viá»‡c sá»­ dá»¥ng má»™t giáº£i phÃ¡p khÃ¡c nhÆ° viá»‡c sá»­ dá»¥ng hai vÃ²ng láº·p `for` riÃªng biá»‡t.¤Type ¦Status¯FollowUpPrompts’ÙfLÃ m tháº¿ nÃ o Ä‘á»ƒ tÃ´i cÃ³ thá»ƒ duyá»‡t qua hai máº£ng mÃ  khÃ´ng cáº§n táº¡o ra má»™t báº£n sao?ÙqCÃ³ cÃ¡ch nÃ o Ä‘á»ƒ tÃ´i cÃ³ thá»ƒ duyá»‡t qua hai máº£ng mÃ  khÃ´ng cáº§n sá»­ dá»¥ng vÃ²ng láº·p `for` khÃ´ng?³CodeVulnerabilities…¨DateTime×ÿ‰w€eõÇêªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$24b842c1-f017-4eaf-90df-c717c872d270Ù$4e338186-b40a-4981-9d3d-d5967f955548‘’“¥Value ÙŠcÃ³ thá»ƒ duyá»‡t longnoods nhÆ° má»™t noods bÃ¬nh  thÆ°á»ng nhÆ° váº­y khÃ´ng trong khi nÃ³ lÃ  má»™t struct chá»‰ káº¿ thá»«a tá»« noodÀ¨Response…§ContentÚ;CÃ³, báº¡n hoÃ n toÃ n cÃ³ thá»ƒ duyá»‡t qua má»™t vector cá»§a `Longnoods` giá»‘ng nhÆ° báº¡n duyá»‡t qua má»™t vector cá»§a `Noods`. Äiá»u nÃ y lÃ  do `Longnoods` káº¿ thá»«a tá»« `Noods`, nghÄ©a lÃ  má»i Ä‘á»‘i tÆ°á»£ng `Longnoods` cÅ©ng lÃ  má»™t Ä‘á»‘i tÆ°á»£ng `Noods`.

Tuy nhiÃªn, cÃ³ má»™t Ä‘iá»u quan trá»ng cáº§n lÆ°u Ã½: khi báº¡n duyá»‡t qua vector `Longnoods` nhÆ° má»™t vector `Noods`, báº¡n chá»‰ cÃ³ thá»ƒ truy cáº­p vÃ o cÃ¡c thÃ nh pháº§n mÃ  `Longnoods` káº¿ thá»«a tá»« `Noods`. Báº¡n khÃ´ng thá»ƒ truy cáº­p vÃ o cÃ¡c thÃ nh pháº§n Ä‘á»™c quyá»n cá»§a `Longnoods` (nhÆ° `length` vÃ  `isbeinghold`) trá»« khi báº¡n cháº¯c cháº¯n ráº±ng Ä‘á»‘i tÆ°á»£ng báº¡n Ä‘ang xá»­ lÃ½ lÃ  má»™t `Longnoods` vÃ  báº¡n Ã©p kiá»ƒu nÃ³ vá» `Longnoods`.

DÆ°á»›i Ä‘Ã¢y lÃ  má»™t vÃ­ dá»¥ vá» cÃ¡ch báº¡n cÃ³ thá»ƒ duyá»‡t qua má»™t vector `Longnoods`:

```C++
vector<Longnoods> longnoods;
// ... thÃªm cÃ¡c pháº§n tá»­ vÃ o longnoods ...

for (Noods& nood : longnoods) {
    // Báº¡n cÃ³ thá»ƒ truy cáº­p vÃ o cÃ¡c thÃ nh pháº§n cá»§a Noods á»Ÿ Ä‘Ã¢y, nhÆ° nood.a, nood.x, nood.y, nood.check
    // NhÆ°ng báº¡n khÃ´ng thá»ƒ truy cáº­p vÃ o length hoáº·c isbeinghold trá»« khi báº¡n Ã©p kiá»ƒu nood vá» Longnoods
}
```

Náº¿u báº¡n muá»‘n truy cáº­p vÃ o cÃ¡c thÃ nh pháº§n Ä‘á»™c quyá»n cá»§a `Longnoods`, báº¡n cÃ³ thá»ƒ lÃ m nhÆ° sau:

```C++
for (Noods& nood : longnoods) {
    // Ã‰p kiá»ƒu nood vá» Longnoods
    Longnoods& longnood = static_cast<Longnoods&>(nood);

    // BÃ¢y giá» báº¡n cÃ³ thá»ƒ truy cáº­p vÃ o length vÃ  isbeinghold
    int length = longnood.length;
    bool isBeingHold = longnood.isbeinghold;
}
```

LÆ°u Ã½ ráº±ng viá»‡c Ã©p kiá»ƒu nhÆ° trÃªn chá»‰ an toÃ n náº¿u báº¡n cháº¯c cháº¯n ráº±ng `nood` thá»±c sá»± lÃ  má»™t `Longnoods`. Náº¿u khÃ´ng, hÃ nh vi cá»§a chÆ°Æ¡ng trÃ¬nh sáº½ khÃ´ng xÃ¡c Ä‘á»‹nh.¤Type ¦Status¯FollowUpPrompts’ÙaLÃ m tháº¿ nÃ o Ä‘á»ƒ kiá»ƒm tra má»™t Ä‘á»‘i tÆ°á»£ng `Noods` cÃ³ pháº£i lÃ  `Longnoods` khÃ´ng?Ù|CÃ³ cÃ¡ch nÃ o Ä‘á»ƒ truy cáº­p vÃ o cÃ¡c thÃ nh pháº§n Ä‘á»™c quyá»n cá»§a `Longnoods` mÃ  khÃ´ng cáº§n Ã©p kiá»ƒu khÃ´ng?³CodeVulnerabilities…¨DateTime×ÿÑy‹eõÈªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$db6d433b-1e2c-4a50-8a30-2f3a847b3ee3Ù$e7f728c9-ac06-4681-b489-f63b50c8b46f‘’“¥Value ÙAcÃ³ thá»ƒ kiÃªm tra xem x lÃ  longnood hay nood hay khÃ´ng khÃ´ngÀ¨Response…§ContentÚFCÃ³, báº¡n cÃ³ thá»ƒ kiá»ƒm tra xem má»™t Ä‘á»‘i tÆ°á»£ng `Noods` cÃ³ pháº£i lÃ  `Longnoods` hay khÃ´ng báº±ng cÃ¡ch sá»­ dá»¥ng `dynamic_cast`. `dynamic_cast` sáº½ tráº£ vá» `nullptr` náº¿u Ä‘á»‘i tÆ°á»£ng khÃ´ng pháº£i lÃ  kiá»ƒu báº¡n muá»‘n Ã©p kiá»ƒu.

DÆ°á»›i Ä‘Ã¢y lÃ  má»™t vÃ­ dá»¥ vá» cÃ¡ch báº¡n cÃ³ thá»ƒ kiá»ƒm tra xem má»™t Ä‘á»‘i tÆ°á»£ng `Noods` cÃ³ pháº£i lÃ  `Longnoods` hay khÃ´ng:

```C++
for (Noods& nood : noods) {
    Longnoods* longnood = dynamic_cast<Longnoods*>(&nood);
    if (longnood != nullptr) {
        // nood lÃ  má»™t Longnoods
    } else {
        // nood khÃ´ng pháº£i lÃ  Longnoods
    }
}
```

Tuy nhiÃªn, lÆ°u Ã½ ráº±ng `dynamic_cast` chá»‰ hoáº¡t Ä‘á»™ng vá»›i cÃ¡c lá»›p cÃ³ Ã­t nháº¥t má»™t hÃ m áº£o. Náº¿u `Noods` khÃ´ng cÃ³ hÃ m áº£o nÃ o, báº¡n sáº½ khÃ´ng thá»ƒ sá»­ dá»¥ng `dynamic_cast` Ä‘á»ƒ kiá»ƒm tra xem má»™t `Noods` cÃ³ pháº£i lÃ  `Longnoods` hay khÃ´ng. Trong trÆ°á»ng há»£p Ä‘Ã³, báº¡n cÃ³ thá»ƒ cáº§n pháº£i thÃªm má»™t hÃ m áº£o vÃ o `Noods` (tháº­m chÃ­ chá»‰ lÃ  má»™t hÃ m há»§y áº£o) Ä‘á»ƒ cÃ³ thá»ƒ sá»­ dá»¥ng `dynamic_cast`.¤Type ¦Status¯FollowUpPrompts’Ù9LÃ m tháº¿ nÃ o Ä‘á»ƒ thÃªm má»™t hÃ m áº£o vÃ o `Noods`?Ù‚CÃ³ cÃ¡ch nÃ o khÃ¡c Ä‘á»ƒ kiá»ƒm tra xem má»™t `Noods` cÃ³ pháº£i lÃ  `Longnoods` khÃ´ng náº¿u khÃ´ng sá»­ dá»¥ng `dynamic_cast`?³CodeVulnerabilities…¨DateTime×ÿÓ¶€eõÊ[ªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$28bc23b7-1b83-4127-8e1d-c8fba2546d11Ù$cec0258d-800c-4234-be76-d99f3537589c‘’“¥Value ÙjlÃ m tháº¿ nÃ o Ä‘á»ƒ táº¡o ra má»™t vector chá»©a kiáº¿u nood mÃ  tÃ´i cÃ³ thá»ƒ thÃªm longnood vÃ o nÃ³ À¨Response…§ContentÚ—Äá»ƒ táº¡o má»™t vector chá»©a cÃ¡c Ä‘á»‘i tÆ°á»£ng `Noods` mÃ  báº¡n cÃ³ thá»ƒ thÃªm cÃ¡c Ä‘á»‘i tÆ°á»£ng `Longnoods` vÃ o, báº¡n cáº§n táº¡o má»™t vector chá»©a con trá» Ä‘áº¿n `Noods`. Äiá»u nÃ y cho phÃ©p báº¡n lÆ°u trá»¯ cÃ¡c Ä‘á»‘i tÆ°á»£ng `Longnoods` trong vector, vÃ¬ `Longnoods` lÃ  má»™t lá»›p con cá»§a `Noods`.

DÆ°á»›i Ä‘Ã¢y lÃ  cÃ¡ch báº¡n cÃ³ thá»ƒ lÃ m Ä‘iá»u Ä‘Ã³:

```C++
std::vector<Noods*> noods;
```

BÃ¢y giá» báº¡n cÃ³ thá»ƒ thÃªm cÃ¡c Ä‘á»‘i tÆ°á»£ng `Noods` vÃ  `Longnoods` vÃ o vector:

```C++
Noods* nood = new Noods;
noods.push_back(nood);

Longnoods* longnood = new Longnoods;
noods.push_back(longnood);
```

LÆ°u Ã½ ráº±ng khi báº¡n sá»­ dá»¥ng con trá» nhÆ° váº­y, báº¡n cáº§n pháº£i cháº¯c cháº¯n ráº±ng báº¡n giáº£i phÃ³ng bá»™ nhá»› mÃ  báº¡n Ä‘Ã£ cáº¥p phÃ¡t khi báº¡n khÃ´ng cÃ²n cáº§n Ä‘áº¿n nÃ³ ná»¯a. Äiá»u nÃ y cÃ³ thá»ƒ Ä‘Æ°á»£c thá»±c hiá»‡n báº±ng cÃ¡ch sá»­ dá»¥ng `delete`:

```C++
for (Noods* nood : noods) {
    delete nood;
}
noods.clear();
```

Äiá»u nÃ y sáº½ giáº£i phÃ³ng bá»™ nhá»› mÃ  má»—i Ä‘á»‘i tÆ°á»£ng `Noods` vÃ  `Longnoods` Ä‘Ã£ sá»­ dá»¥ng, vÃ  sau Ä‘Ã³ xÃ³a táº¥t cáº£ cÃ¡c pháº§n tá»­ khá»i vector.¤Type ¦Status¯FollowUpPrompts’ÙPHow can I access the properties of the `Longnoods` objects stored in the vector?ÙNHow can I differentiate between `Noods` and `Longnoods` objects in the vector?³CodeVulnerabilities…¨DateTime×ÿwm¬ğeõÊñªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$d109de5c-2560-488b-ac24-3e988608d342Ù$355c2a7f-996e-4305-9082-f98bfbf5d93d‘’“¥Value ÙŠtÃ´i muá»‘n giáº£i phÃ³ng vÃ  xÃ³a há»¯u háº¡n cÃ¡c pháº§n tá»­ thÃ¬ sao giáº£ sá»­ lÃ  chá»‰ xÃ³a cÃ¡c pháº§n tá»­ cÃ³ check báº±ng falseÀ¨Response…§ContentÚ8Äá»ƒ xÃ³a cÃ¡c pháº§n tá»­ cÃ³ thuá»™c tÃ­nh `check` báº±ng `false` tá»« vector `noods`, báº¡n cÃ³ thá»ƒ sá»­ dá»¥ng hÃ m `remove_if` tá»« thÆ° viá»‡n `<algorithm>`. HÃ m nÃ y sáº½ dá»‹ch chuyá»ƒn táº¥t cáº£ cÃ¡c pháº§n tá»­ cáº§n xÃ³a lÃªn cuá»‘i vector, sau Ä‘Ã³ báº¡n cÃ³ thá»ƒ sá»­ dá»¥ng hÃ m `erase` Ä‘á»ƒ xÃ³a chÃºng.

DÆ°á»›i Ä‘Ã¢y lÃ  cÃ¡ch báº¡n cÃ³ thá»ƒ lÃ m Ä‘iá»u Ä‘Ã³:

```C++
noods.erase(std::remove_if(noods.begin(), noods.end(), [](const Noods& nood) {
    return !nood.check;
}), noods.end());
```

LÆ°u Ã½ ráº±ng Ä‘oáº¡n mÃ£ trÃªn sáº½ xÃ³a táº¥t cáº£ cÃ¡c pháº§n tá»­ cÃ³ `check` báº±ng `false` tá»« vector. Náº¿u báº¡n chá»‰ muá»‘n xÃ³a má»™t sá»‘ lÆ°á»£ng há»¯u háº¡n cÃ¡c pháº§n tá»­ nhÆ° váº­y, báº¡n sáº½ cáº§n pháº£i viáº¿t má»™t vÃ²ng láº·p vÃ  chá»‰ xÃ³a sá»‘ lÆ°á»£ng pháº§n tá»­ mong muá»‘n.¤Type ¦Status¯FollowUpPrompts’Ù[LÃ m tháº¿ nÃ o Ä‘á»ƒ tÃ´i kiá»ƒm tra xem vector Ä‘Ã£ Ä‘Æ°á»£c xÃ³a thÃ nh cÃ´ng hay chÆ°a?ÙdCÃ³ cÃ¡ch nÃ o Ä‘á»ƒ tÃ´i xÃ³a má»™t sá»‘ lÆ°á»£ng cá»‘ Ä‘á»‹nh cÃ¡c pháº§n tá»­ tá»« vector khÃ´ng?³CodeVulnerabilities…¨DateTime×ÿ]£:`eõËUªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$64ba241e-cc36-4342-bd79-e1e5e9b8a155Ù$b5ffec3e-40a4-4006-911d-e518bc81aeba‘’“¥Value ÙOtÃ´i muá»‘n xÃ³a vÃ  giáº£i phÃ³ng bá»™ nhá»› ná»¯a nhÆ° nhá»¯ng gÃ¬ bnÃ³iáº¡n À¨Response…§ContentÚ³Äá»ƒ xÃ³a vÃ  giáº£i phÃ³ng bá»™ nhá»› cho cÃ¡c pháº§n tá»­ trong vector `noods` cÃ³ thuá»™c tÃ­nh `check` báº±ng `false`, báº¡n cÃ³ thá»ƒ sá»­ dá»¥ng hÃ m `remove_if` tá»« thÆ° viá»‡n `<algorithm>`. HÃ m nÃ y sáº½ dá»‹ch chuyá»ƒn táº¥t cáº£ cÃ¡c pháº§n tá»­ cáº§n xÃ³a lÃªn cuá»‘i vector, sau Ä‘Ã³ báº¡n cÃ³ thá»ƒ sá»­ dá»¥ng hÃ m `erase` Ä‘á»ƒ xÃ³a chÃºng.

DÆ°á»›i Ä‘Ã¢y lÃ  cÃ¡ch báº¡n cÃ³ thá»ƒ lÃ m Ä‘iá»u Ä‘Ã³ trong hÃ m `main` cá»§a báº¡n:

```C++
// Inside your main function, after all the gameplay logic
noods.erase(std::remove_if(noods.begin(), noods.end(), [](const Noods& nood) {
    return !nood.check;
}), noods.end());
```

LÆ°u Ã½ ráº±ng Ä‘oáº¡n mÃ£ trÃªn sáº½ xÃ³a táº¥t cáº£ cÃ¡c pháº§n tá»­ cÃ³ `check` báº±ng `false` tá»« vector. Náº¿u báº¡n chá»‰ muá»‘n xÃ³a má»™t sá»‘ lÆ°á»£ng há»¯u háº¡n cÃ¡c pháº§n tá»­ nhÆ° váº­y, báº¡n sáº½ cáº§n pháº£i viáº¿t má»™t vÃ²ng láº·p vÃ  chá»‰ xÃ³a sá»‘ lÆ°á»£ng pháº§n tá»­ mong muá»‘n.¤Type ¦Status¯FollowUpPrompts’ÙhLÃ m tháº¿ nÃ o Ä‘á»ƒ tÃ´i cÃ³ thá»ƒ xÃ³a má»™t sá»‘ lÆ°á»£ng cá»‘ Ä‘á»‹nh cÃ¡c pháº§n tá»­ tá»« vector?Ù^CÃ³ cÃ¡ch nÃ o Ä‘á»ƒ tÃ´i kiá»ƒm tra xem vector Ä‘Ã£ Ä‘Æ°á»£c giáº£i phÃ³ng hoÃ n toÃ n chÆ°a?³CodeVulnerabilities…¨DateTime×ÿíğâpeõËŠªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$0366fb76-ba97-46c8-9202-76adef388896Ù$fd5ed35a-af0c-4ddb-ad83-c140119ee4ba‘’“¥Value Ù5nhÆ° váº­y cÃ³ giáº£i phÃ³ng bá»™ nhá»›  luÃ´n khÃ´ngÀ¨Response…§ContentÚTrong C++, viá»‡c giáº£i phÃ³ng bá»™ nhá»› khÃ´ng Ä‘Æ°á»£c thá»±c hiá»‡n tá»± Ä‘á»™ng cho cÃ¡c Ä‘á»‘i tÆ°á»£ng Ä‘Æ°á»£c cáº¥p phÃ¡t báº±ng toÃ¡n tá»­ `new`. Tuy nhiÃªn, trong trÆ°á»ng há»£p cá»§a báº¡n, báº¡n Ä‘ang sá»­ dá»¥ng `std::vector`, má»™t container cá»§a thÆ° viá»‡n chuáº©n C++, nÃ³ tá»± Ä‘á»™ng quáº£n lÃ½ bá»™ nhá»› cho báº¡n.

Khi báº¡n gá»i `noods.erase(noods.begin(), noods.begin() + 30);`, cÃ¡c pháº§n tá»­ trong pháº¡m vi Ä‘Æ°á»£c chá»‰ Ä‘á»‹nh sáº½ bá»‹ xÃ³a khá»i vector vÃ  bá»™ nhá»› mÃ  chÃºng chiáº¿m giá»¯ sáº½ Ä‘Æ°á»£c giáº£i phÃ³ng.

Tuy nhiÃªn, náº¿u báº¡n cÃ³ cÃ¡c Ä‘á»‘i tÆ°á»£ng trong vector mÃ  chÃºng tá»± cáº¥p phÃ¡t bá»™ nhá»› (vÃ­ dá»¥ thÃ´ng qua toÃ¡n tá»­ `new`), báº¡n sáº½ cáº§n cháº¯c cháº¯n ráº±ng báº¡n Ä‘Ã£ giáº£i phÃ³ng bá»™ nhá»› Ä‘Ã³ trÆ°á»›c khi xÃ³a chÃºng khá»i vector. Trong trÆ°á»ng há»£p cá»§a báº¡n, `Noods` khÃ´ng tá»± cáº¥p phÃ¡t bá»™ nhá»› nÃªn báº¡n khÃ´ng cáº§n pháº£i lo láº¯ng vá» Ä‘iá»u nÃ y.

VÃ¬ váº­y, Ä‘oáº¡n mÃ£ cá»§a báº¡n Ä‘Ã£ giáº£i phÃ³ng bá»™ nhá»› má»™t cÃ¡ch chÃ­nh xÃ¡c.¤Type ¦Status¯FollowUpPrompts’ÙpLÃ m tháº¿ nÃ o Ä‘á»ƒ tÃ´i cÃ³ thá»ƒ giáº£m sá»‘ lÆ°á»£ng pháº§n tá»­ trong vector mÃ  khÃ´ng cáº§n xÃ³a chÃºng?ÙVCÃ³ cÃ¡ch nÃ o Ä‘á»ƒ tÃ´i kiá»ƒm tra xem bá»™ nhá»› Ä‘Ã£ Ä‘Æ°á»£c giáº£i phÃ³ng chÆ°a?³CodeVulnerabilities…¨DateTime×ÿä[d°eõËÍªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$aa7b681e-0630-45ad-b4ae-d9bc13bb9493Ù$f747bac3-61ad-4bea-8b7e-b4f9325bcc3c‘’“¥Value ÙSnhÆ°ng náº¿u tÃ´i lÃ m theo cÃ¡ch cá»§a báº¡n thÃ¬ tÃ´i cáº§n xÃ³a bá»™ nhá»› ná»¯aÀ¨Response…§ContentÚTrong C++, viá»‡c giáº£i phÃ³ng bá»™ nhá»› khÃ´ng Ä‘Æ°á»£c thá»±c hiá»‡n tá»± Ä‘á»™ng cho cÃ¡c Ä‘á»‘i tÆ°á»£ng Ä‘Æ°á»£c cáº¥p phÃ¡t báº±ng toÃ¡n tá»­ `new`. Tuy nhiÃªn, trong trÆ°á»ng há»£p cá»§a báº¡n, báº¡n Ä‘ang sá»­ dá»¥ng `std::vector`, má»™t container cá»§a thÆ° viá»‡n chuáº©n C++, nÃ³ tá»± Ä‘á»™ng quáº£n lÃ½ bá»™ nhá»› cho báº¡n.

Khi báº¡n gá»i `noods.erase(noods.begin(), noods.begin() + 30);`, cÃ¡c pháº§n tá»­ trong pháº¡m vi Ä‘Æ°á»£c chá»‰ Ä‘á»‹nh sáº½ bá»‹ xÃ³a khá»i vector vÃ  bá»™ nhá»› mÃ  chÃºng chiáº¿m giá»¯ sáº½ Ä‘Æ°á»£c giáº£i phÃ³ng.

Tuy nhiÃªn, náº¿u báº¡n cÃ³ cÃ¡c Ä‘á»‘i tÆ°á»£ng trong vector mÃ  chÃºng tá»± cáº¥p phÃ¡t bá»™ nhá»› (vÃ­ dá»¥ thÃ´ng qua toÃ¡n tá»­ `new`), báº¡n sáº½ cáº§n cháº¯c cháº¯n ráº±ng báº¡n Ä‘Ã£ giáº£i phÃ³ng bá»™ nhá»› Ä‘Ã³ trÆ°á»›c khi xÃ³a chÃºng khá»i vector. Trong trÆ°á»ng há»£p cá»§a báº¡n, `Noods` khÃ´ng tá»± cáº¥p phÃ¡t bá»™ nhá»› nÃªn báº¡n khÃ´ng cáº§n pháº£i lo láº¯ng vá» Ä‘iá»u nÃ y.

VÃ¬ váº­y, Ä‘oáº¡n mÃ£ cá»§a báº¡n Ä‘Ã£ giáº£i phÃ³ng bá»™ nhá»› má»™t cÃ¡ch chÃ­nh xÃ¡c.¤Type ¦Status¯FollowUpPrompts³CodeVulnerabilities…¨DateTime×ÿ¡ş- eõÌHªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$41050d7d-588b-46b6-8ca1-fc1f4b3c23dfÙ$99cae906-593d-4145-82ac-b586bc9fa0a1‘’“¥Value ÚNoods* nood = new Noods;
noods.push_back(nood);

Longnoods* longnood = new Longnoods;
noods.push_back(longnood);
náº¿u tÃ´i táº¡o máº£ng há»—n há»£p nhÆ° tháº¿ nÃ y thÃ¬ khi tÃ´i duyá»‡t for each tÃ´i cÃ³ thá»ƒ sá»­ dá»¥ng thuá»™c tÃ­nh cá»§a longnood khÃ´ngÀ¨Response…§ContentÚÃTrong C++, báº¡n khÃ´ng thá»ƒ trá»±c tiáº¿p thÃªm cÃ¡c Ä‘á»‘i tÆ°á»£ng cá»§a lá»›p con vÃ o má»™t vector cá»§a lá»›p cha. Tuy nhiÃªn, báº¡n cÃ³ thá»ƒ sá»­ dá»¥ng con trá» Ä‘á»ƒ giáº£i quyáº¿t váº¥n Ä‘á» nÃ y. 

Äá»ƒ lÃ m Ä‘iá»u nÃ y, báº¡n cáº§n táº¡o má»™t vector cá»§a con trá» Ä‘áº¿n lá»›p cha (`Noods`). Khi báº¡n thÃªm má»™t Ä‘á»‘i tÆ°á»£ng cá»§a lá»›p con (`Longnoods`) vÃ o vector, báº¡n cáº§n Ã©p kiá»ƒu Ä‘á»‘i tÆ°á»£ng Ä‘Ã³ thÃ nh con trá» Ä‘áº¿n lá»›p cha (`Noods*`). 

```C++
std::vector<Noods*> noods;
Noods* nood = new Noods;
noods.push_back(nood);

Longnoods* longnood = new Longnoods;
noods.push_back(static_cast<Noods*>(longnood));
```

Khi duyá»‡t qua vector, báº¡n cÃ³ thá»ƒ kiá»ƒm tra xem má»—i Ä‘á»‘i tÆ°á»£ng cÃ³ pháº£i lÃ  má»™t `Longnoods` hay khÃ´ng báº±ng cÃ¡ch sá»­ dá»¥ng `dynamic_cast`. Náº¿u `dynamic_cast` tráº£ vá» má»™t con trá» khÃ´ng null, Ä‘Ã³ lÃ  má»™t `Longnoods`.

```C++
for (Noods* nood : noods) {
    Longnoods* longnood = dynamic_cast<Longnoods*>(nood);
    if (longnood != nullptr) {
        // Sá»­ dá»¥ng thuá»™c tÃ­nh cá»§a Longnoods
    } else {
        // Sá»­ dá»¥ng thuá»™c tÃ­nh cá»§a Noods
    }
}
```

LÆ°u Ã½ ráº±ng báº¡n cáº§n cháº¯c cháº¯n ráº±ng báº¡n giáº£i phÃ³ng bá»™ nhá»› mÃ  báº¡n Ä‘Ã£ cáº¥p phÃ¡t báº±ng `new` khi báº¡n khÃ´ng cÃ²n cáº§n Ä‘áº¿n nÃ³ ná»¯a. Äiá»u nÃ y cÃ³ thá»ƒ Ä‘Æ°á»£c thá»±c hiá»‡n báº±ng cÃ¡ch sá»­ dá»¥ng `delete` trÃªn má»—i pháº§n tá»­ cá»§a vector khi báº¡n Ä‘Ã£ xong vá»›i nÃ³.¤Type ¦Status¯FollowUpPrompts’ÙDHow can I delete the memory allocated for the objects in the vector?ÙYCan I use this approach to store objects of different derived classes in the same vector?³CodeVulnerabilities…¨DateTime×ÿ¤Å¾eõÌ«ªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$aa6eedef-4279-442c-bce2-0ef7ced8fbbdÙ$1e521500-3e5e-4739-a118-ae585ae8a7ec‘’“¥Value Ùˆnáº¿u tÃ´i lÃ m nhÆ° váº­y thÃ¬ lÃ m sao Ä‘á»ƒ giáº£i phÃ³ng bá»™ nhá»› rá»“i xÃ³a khá»i vector vá»›i má»—i pháº§n tá»­ cÃ³ check=falseÀ¨Response…§ContentÚ[Äá»ƒ giáº£i phÃ³ng bá»™ nhá»› vÃ  xÃ³a cÃ¡c pháº§n tá»­ cÃ³ `check = false` khá»i vector, báº¡n cÃ³ thá»ƒ sá»­ dá»¥ng hÃ m `erase` káº¿t há»£p vá»›i hÃ m `remove_if` tá»« thÆ° viá»‡n `<algorithm>`.

Trong trÆ°á»ng há»£p cá»§a báº¡n, vÃ¬ báº¡n khÃ´ng cáº¥p phÃ¡t Ä‘á»™ng cho cÃ¡c Ä‘á»‘i tÆ°á»£ng `Noods` trong vector `noods`, báº¡n khÃ´ng cáº§n giáº£i phÃ³ng bá»™ nhá»› cho chÃºng. Tuy nhiÃªn, náº¿u báº¡n cÃ³ cáº¥p phÃ¡t Ä‘á»™ng cho chÃºng, báº¡n sáº½ cáº§n sá»­ dá»¥ng `delete` trÆ°á»›c khi xÃ³a chÃºng khá»i vector.

DÆ°á»›i Ä‘Ã¢y lÃ  cÃ¡ch báº¡n cÃ³ thá»ƒ xÃ³a cÃ¡c pháº§n tá»­ cÃ³ `check = false` khá»i vector:

```C++
noods.erase(std::remove_if(noods.begin(), noods.end(), [](const Noods& nood) {
    return !nood.check;
}), noods.end());
```

HÃ m `remove_if` sáº½ di chuyá»ƒn táº¥t cáº£ cÃ¡c pháº§n tá»­ mÃ  khÃ´ng thá»a mÃ£n Ä‘iá»u kiá»‡n (trong trÆ°á»ng há»£p nÃ y lÃ  `nood.check == false`) vá» cuá»‘i vector, vÃ  tráº£ vá» má»™t iterator Ä‘áº¿n pháº§n tá»­ Ä‘áº§u tiÃªn trong pháº§n tá»­ Ä‘Ã³. HÃ m `erase` sau Ä‘Ã³ sáº½ xÃ³a táº¥t cáº£ cÃ¡c pháº§n tá»­ tá»« iterator Ä‘Ã³ Ä‘áº¿n cuá»‘i vector.¤Type ¦Status¯FollowUpPrompts’ÙJHow can I dynamically allocate memory for the Noods objects in the vector?ÙMWhat happens if I don't remove the elements with check=false from the vector?³CodeVulnerabilities…¨DateTime×ÿÈx¾ğeõÌØªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$5d153623-d0fa-4e5d-a335-1f7166a6c8e7Ù$44183520-ebf9-48e4-a2a5-d7a940a5bcd8‘’“¥Value Ù;tÃ´i Ä‘ang nÃ³i Ä‘áº¿n trÆ°á»ng há»£p cáº¥p phÃ¡t Ä‘á»™ng À¨Response…§ContentÚ
Náº¿u báº¡n cáº¥p phÃ¡t Ä‘á»™ng cho cÃ¡c Ä‘á»‘i tÆ°á»£ng `Noods` trong vector `noods`, báº¡n sáº½ cáº§n giáº£i phÃ³ng bá»™ nhá»› cho chÃºng trÆ°á»›c khi xÃ³a chÃºng khá»i vector. Äiá»u nÃ y cÃ³ thá»ƒ Ä‘Æ°á»£c thá»±c hiá»‡n báº±ng cÃ¡ch sá»­ dá»¥ng `delete` trÃªn con trá» Ä‘áº¿n má»—i Ä‘á»‘i tÆ°á»£ng `Noods` trÆ°á»›c khi xÃ³a nÃ³ khá»i vector.

Trong trÆ°á»ng há»£p nÃ y, báº¡n cáº§n thay Ä‘á»•i kiá»ƒu cá»§a vector `noods` tá»« `vector<Noods>` thÃ nh `vector<Noods*>`, vÃ¬ má»—i pháº§n tá»­ trong vector sáº½ lÃ  má»™t con trá» Ä‘áº¿n má»™t Ä‘á»‘i tÆ°á»£ng `Noods` thay vÃ¬ má»™t Ä‘á»‘i tÆ°á»£ng `Noods` thá»±c sá»±.

Sau Ä‘Ã³, báº¡n cÃ³ thá»ƒ sá»­ dá»¥ng hÃ m `remove_if` vÃ  `erase` nhÆ° trÆ°á»›c Ä‘Ã¢y, nhÆ°ng trÆ°á»›c khi xÃ³a má»™t pháº§n tá»­, báº¡n cáº§n giáº£i phÃ³ng bá»™ nhá»› mÃ  nÃ³ chiáº¿m giá»¯:

```C++
noods.erase(std::remove_if(noods.begin(), noods.end(), [](Noods* nood) {
    if (!nood->check) {
        delete nood;
        return true;
    }
    return false;
}), noods.end());
```

LÆ°u Ã½ ráº±ng sau khi gá»i `delete` trÃªn má»™t con trá», báº¡n khÃ´ng nÃªn sá»­ dá»¥ng con trá» Ä‘Ã³ ná»¯a. Trong trÆ°á»ng há»£p nÃ y, sau khi gá»i `delete nood`, chÃºng ta xÃ³a con trá» `nood` khá»i vector, vÃ¬ váº­y chÃºng ta khÃ´ng cáº§n quan tÃ¢m Ä‘áº¿n nÃ³ ná»¯a.¤Type ¦Status¯FollowUpPrompts’ÙDHow can I prevent memory leaks when using dynamic allocation in C++?Ù5What other methods can I use to manage memory in C++?³CodeVulnerabilities…¨DateTime×ÿiÁÀeõ×EªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$488e7534-de4e-4630-b552-b89f0e280824Ù$070c9b77-023c-46b2-9b63-c474b1662df6‘’“¥Value Ùƒkhi tÃ´i Ä‘Æ°a longnood vÃ o máº£ng nood thÃ¬ nÃ³ khÃ´ng nháº­n Ä‘Æ°á»£c cÃ¡c thÃ´ng sá»‘ khÃ¡c cá»§a longnood tÃ´i pháº£i lÃ m saoÀ¨Response…§ContentÚHTrong trÆ°á»ng há»£p cá»§a báº¡n, báº¡n Ä‘ang cá»‘ gáº¯ng lÆ°u má»™t Ä‘á»‘i tÆ°á»£ng `Longnoods` vÃ o má»™t vector chá»©a cÃ¡c Ä‘á»‘i tÆ°á»£ng `Noods`. Äiá»u nÃ y khÃ´ng hoáº¡t Ä‘á»™ng nhÆ° báº¡n mong Ä‘á»£i vÃ¬ `Longnoods` lÃ  má»™t lá»›p con cá»§a `Noods`, vÃ  khi báº¡n thÃªm má»™t Ä‘á»‘i tÆ°á»£ng `Longnoods` vÃ o vector, nÃ³ sáº½ bá»‹ cáº¯t xÃ©n thÃ nh má»™t Ä‘á»‘i tÆ°á»£ng `Noods`. Äiá»u nÃ y cÃ³ nghÄ©a lÃ  táº¥t cáº£ cÃ¡c thuá»™c tÃ­nh vÃ  phÆ°Æ¡ng thá»©c Ä‘áº·c biá»‡t cá»§a `Longnoods` sáº½ bá»‹ máº¥t.

Äá»ƒ giáº£i quyáº¿t váº¥n Ä‘á» nÃ y, báº¡n cÃ³ thá»ƒ thay Ä‘á»•i vector `noods` Ä‘á»ƒ chá»©a cÃ¡c con trá» Ä‘áº¿n `Noods` thay vÃ¬ cÃ¡c Ä‘á»‘i tÆ°á»£ng `Noods` thá»±c sá»±. Äiá»u nÃ y cho phÃ©p báº¡n lÆ°u trá»¯ cÃ¡c con trá» Ä‘áº¿n cÃ¡c Ä‘á»‘i tÆ°á»£ng `Longnoods` trong vector, vÃ¬ má»i con trá» Ä‘áº¿n má»™t Ä‘á»‘i tÆ°á»£ng `Longnoods` cÅ©ng lÃ  má»™t con trá» Ä‘áº¿n má»™t Ä‘á»‘i tÆ°á»£ng `Noods`.

ÄÃ¢y lÃ  cÃ¡ch báº¡n cÃ³ thá»ƒ thá»±c hiá»‡n Ä‘iá»u nÃ y:

```C++
vector<Noods*> noods;
```

Khi báº¡n thÃªm má»™t Ä‘á»‘i tÆ°á»£ng `Longnoods` vÃ o vector, báº¡n cáº§n pháº£i cáº¥p phÃ¡t Ä‘á»™ng cho nÃ³ vÃ  sau Ä‘Ã³ thÃªm con trá» Ä‘áº¿n nÃ³ vÃ o vector:

```C++
Longnoods* longnood = new Longnoods;
longnood->length = generateRandomNumber(200, 400);
longnood->x = positionnood[y - 1];
longnood->y = 0;
longnood->check = true;
noods.push_back(longnood);
```

LÆ°u Ã½ ráº±ng khi báº¡n lÃ m nhÆ° váº­y, báº¡n cáº§n pháº£i cháº¯c cháº¯n ráº±ng báº¡n giáº£i phÃ³ng bá»™ nhá»› cho má»—i Ä‘á»‘i tÆ°á»£ng `Longnoods` khi báº¡n Ä‘Ã£ xong vá»›i nÃ³, Ä‘á»ƒ trÃ¡nh rÃ² rá»‰ bá»™ nhá»›.¤Type ¦Status¯FollowUpPrompts’ÙIHow can I safely delete an object from the vector after I'm done with it?ÙEWhat happens if I forget to delete the dynamically allocated objects?³CodeVulnerabilities…¨DateTime×ÿ5Æ<@eûªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$fce9cc5c-bc82-4d3f-b362-e372abc6c4bbÙ$1a25b1ff-de94-46ff-864d-a030990d2011‘†¯ProviderMoniker‚¤NameÙ6Microsoft.VisualStudio.Copilot.DocumentContextProvider§Version£0.1¦Member¤file©CanReduceÃ©RequestIdÙ$fce9cc5c-bc82-4d3f-b362-e372abc6c4bb©Reference²#file:'Source.cpp'¥ValueÈ†ædÙ‘Microsoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a…§ContentÚ…Å#include <SDL.h>
#include <stdio.h>
#include <SDL_image.h>
#include <iostream>
#include <ctime>
#include<vector>
#include<algorithm>
#include<random>
#include<SDL_mixer.h>
#include<SDL_ttf.h>
#include<thread>

using namespace std;


//creat a funtion to generate random number from seed time
int generateRandomNumber(int min, int max) {
	static bool first = true;
    if (first) {
		srand(time(NULL));
		first = false;
	}
	return min + rand() % ((max + 1) - min);
}
//creat a funtion to generate n random numbers from seed time
vector<int> generateRandomNumbers(int min, int max, int n) {
	vector<int> result;
    for (int i = 0; i < n; i++) {
		result.push_back(generateRandomNumber(min, max));
	}
	return result;
}
const int positionnood[] = { 59,205,331,605,751,876 };//position of nood
const int numbernood[]={1,1,1,1,1,1,2,2,2,2,2,3,3,1,3,4,1,4,6,2};//rate of random number of nood
//funtion to random number of nood
int creatnumberofnood() {
	int numberofnood = generateRandomNumber(1,20);
	return numbernood[numberofnood];
}
//funtion to random position of nood with number of nood
vector<int> creatpositionofnood(int numbernood) {
    vector<int> result;
    if (numbernood % 2 == 0) {
        
        result= generateRandomNumbers(1, 3, numbernood/2);
        for (int i = 0; i < numbernood / 2; i++) { result.push_back(6 - result[i] + 1); }
        return result;
    }
    else {
        int th=generateRandomNumber(1,2);
        if (th == 1) {
           
            return generateRandomNumbers(1, 3, numbernood);
        }
        else {
            return generateRandomNumbers(4, 6, numbernood);
		}
    }
    return result;
}
//struct of nood
struct Noods {
    SDL_Texture* a;
    int x=0, y=0;
    bool check = false;
    int type = 0;
};
struct Longnoods:Noods {
    int length;
    bool isbeinghold;
    int type = 1;
};
void renderLongnood(SDL_Renderer* renderer, SDL_Texture* longnoodTexture, int customLength, int posX, int posY) {
    // Táº¡o SDL_Rect cho pháº§n Ä‘áº§u cá»§a longnood
    SDL_Rect headRect = { 0, 0, 88, customLength/2*4.5 };
    SDL_Rect destHeadRect = { posX, posY, 44, customLength/2 };
    // Táº¡o SDL_Rect cho pháº§n cuá»‘i cá»§a longnood
    SDL_Rect tailRect = { 0, 3532 - customLength/2*4.5, 88, customLength/2*4.5 };
    SDL_Rect destTailRect = { posX, posY + customLength/2, 44, customLength/2 };
    // Váº½ pháº§n Ä‘áº§u, thÃ¢n vÃ  cuá»‘i cá»§a longnood
    SDL_RenderCopyEx(renderer, longnoodTexture, &headRect, &destHeadRect, 0.0, NULL, SDL_FLIP_NONE);
    SDL_RenderCopyEx(renderer, longnoodTexture, &tailRect, &destTailRect, 0.0, NULL, SDL_FLIP_NONE);
}
int main(int argc, char* args[]) {
    bool gameplay = false;

    // Khá»Ÿi táº¡o SDL
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        printf("SDL could not initialize! SDL_Error: %s\n", SDL_GetError());
        return 1;
    }

    SDL_Window* window = SDL_CreateWindow("SDL 2.0 Basic Example", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 1080, 810, SDL_WINDOW_SHOWN);
    if (window == NULL) {
        printf("Window could not be created! SDL_Error: %s\n", SDL_GetError());
        return 1;
    }

    // Táº¡o renderer
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    if (renderer == NULL) {
        printf("Renderer could not be created! SDL_Error: %s\n", SDL_GetError());
        return 1;
    }
    SDL_Surface* noodSurface = IMG_Load("Image/nood.png");
    if (noodSurface == NULL) {
        printf("SDL could not load image! SDL Error: %s\n", SDL_GetError());
        return 1;
    }
    SDL_Surface* longnoodSurface = IMG_Load("Image/longnood.png");
    if (longnoodSurface == NULL) {
		printf("SDL could not load image! SDL Error: %s\n", SDL_GetError());
		return 1;
	}
    SDL_Texture* noodTexture = SDL_CreateTextureFromSurface(renderer, noodSurface);
    SDL_FreeSurface(noodSurface);
    SDL_Rect noodRect = { 100,1.1, 100, 100 };
    SDL_Texture* longnoodTexture = SDL_CreateTextureFromSurface(renderer, longnoodSurface);
    SDL_FreeSurface(longnoodSurface);
    //create longnoodreact with full image of longnood
    SDL_Rect longnoodRect = { 205,50, 22, 200};

    SDL_Surface* openSurface = IMG_Load("Image/open.png");
    SDL_Texture* openTexture = SDL_CreateTextureFromSurface(renderer, openSurface);
    SDL_FreeSurface(openSurface);

   
    SDL_Texture* texture = openTexture;
    
    SDL_Rect destinationRect = { 0,0, 1080, 810 };
    SDL_RenderCopyEx(renderer, texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
    
    
    Noods nood;
    nood.a = noodTexture;
    nood.x = 59;
    nood.y = 0;
    nood.check = true;
    //creat vector nood for gameplay
    vector<Noods*> noods;
    
    Longnoods longnood;
    longnood.a = longnoodTexture;
    longnood.x = 205;
    longnood.y = 0;
    longnood.check = true;
    SDL_RenderPresent(renderer);

    //loop of opentexture go to game if mouse click
    while (true) {
        //if mouse click
        SDL_Event e;
        SDL_PollEvent(&e);
        if (e.type == SDL_MOUSEBUTTONDOWN) {
            break;
        }
    }
    SDL_DestroyTexture(openTexture);
    bool quit = false;
    SDL_Event e;
    // variable to control speed and number of nood
    float demSpeed = 0;
    float demWave = 0;
    int demNood = 0;
    int speed = 6;
    int demsp = 0;
    int maxWave = 125;
    if (SDL_Init(SDL_INIT_AUDIO) < 0) {
        printf("SDL could not initialize! SDL_Error: %s\n", SDL_GetError());
        return 1;
    }
    if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048) < 0) {
        printf("SDL_mixer could not initialize! SDL_mixer Error: %s\n", Mix_GetError());
        return 1;
    }

    // load menu music
    Mix_Music* music = Mix_LoadMUS("music/menu.mp3");
    if (music == NULL) {
        printf("Failed to load music! SDL_mixer Error: %s\n", Mix_GetError());
        return 1;
    }
    //main loop start menu 
    while (!quit) {
        SDL_Surface* menuSurface = IMG_Load("Image/Menu.png");
        SDL_Texture* menuTexture = SDL_CreateTextureFromSurface(renderer, menuSurface);
        SDL_FreeSurface(menuSurface);
        SDL_Surface* menu1Surface = IMG_Load("Image/Menu1.png");
        SDL_Texture* menu1Texture = SDL_CreateTextureFromSurface(renderer, menu1Surface);
        SDL_FreeSurface(menu1Surface);

        SDL_Surface* menu2Surface = IMG_Load("Image/Menu2.png");
        SDL_Texture* menu2Texture = SDL_CreateTextureFromSurface(renderer, menu2Surface);
        SDL_FreeSurface(menu2Surface);

        SDL_Surface* menu3Surface = IMG_Load("Image/Menu3.png");
        SDL_Texture* menu3Texture = SDL_CreateTextureFromSurface(renderer, menu3Surface);
        SDL_FreeSurface(menu3Surface);
        texture = menuTexture;
        //thread to play menu music and play again if music menu end
        std::thread t1([&music]() {
            Mix_PlayMusic(music, -1);
            if (music == NULL) Mix_PlayMusic(music, -1);

            });
        t1.join();
        //menu loop
        while (true) {

            while (SDL_PollEvent(&e) != 0) {
                if (e.type == SDL_QUIT) {
                    quit = true;
                }
            }

            SDL_Rect destinationRect = { 0,0.0, 1080, 810 };
            SDL_RenderCopyEx(renderer, texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
            SDL_RenderPresent(renderer);
   //get mouse position
            int x, y;
            SDL_GetMouseState(&x, &y);
            //action with each button of menu be clicked
            //play button
            if (x > 400 && x < 700) {
                if (y > 350 && y < 475) {
                    texture = menu1Texture;
                    //go to gameplay if mouse click in play button
                    SDL_PollEvent(&e);
                    if (e.type == SDL_MOUSEBUTTONDOWN) {
                        gameplay = true;

                        break;
                    }
                }
                //how to play button
                else if (y > 490 && y < 600) {
                    texture = menu2Texture;
                    SDL_PollEvent(&e);
                    if (e.type == SDL_MOUSEBUTTONDOWN) {
						//pause music and display how to play texture
                        Mix_PauseMusic();
						SDL_Surface* howtoplaySurface = IMG_Load("Image/how to play.png");
						SDL_Texture* howtoplayTexture = SDL_CreateTextureFromSurface(renderer, howtoplaySurface);
						SDL_FreeSurface(howtoplaySurface);
						destinationRect = { 0,0, 1080, 810 };
						SDL_RenderCopyEx(renderer, howtoplayTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
						SDL_RenderPresent(renderer);
                        SDL_Delay(500);
						//how to play loop
                        while (true) {
							SDL_PollEvent(&e);
                            //go back to menu if mouse click
                            if (e.type == SDL_MOUSEBUTTONDOWN) {
								SDL_DestroyTexture(howtoplayTexture);
								break;
                            }
						}
						SDL_DestroyTexture(howtoplayTexture);
                        //music resume
                        Mix_ResumeMusic();
					}
                    
                }
                //exit button
                else if (y > 600 && y < 700) {

                    texture = menu3Texture;
                    //program quif if mouse click

                    SDL_PollEvent(&e);
                    if (e.type == SDL_MOUSEBUTTONDOWN) {

                        return 0;

                    }

                }
				//if mouse not in button
                else {
                    texture = menuTexture;
                }
            }
			//if mouse not in button
            else {
                texture = menuTexture;
            }
        }
        // Load gameplay music
        Mix_Music* music = Mix_LoadMUS("music/AdhesiveWombat - 8 Bit Adventure.mp3");
        if (music == NULL) {
            printf("Failed to load music! SDL_mixer Error: %s\n", Mix_GetError());
            return 1;
        }
        //setup for gameplay
        if (gameplay == true) {
            //delete menu texture
            SDL_DestroyTexture(menuTexture);
            SDL_DestroyTexture(menu1Texture);
            SDL_DestroyTexture(menu2Texture);
            SDL_DestroyTexture(menu3Texture);
            SDL_Surface* backgroundSurface = IMG_Load("Image/gameplay.png");
            if (backgroundSurface == NULL) {
                printf("SDL could not load image! SDL Error: %s\n", SDL_GetError());
                return 1;
            }
            SDL_Texture* backgroundTexture = SDL_CreateTextureFromSurface(renderer, backgroundSurface);
            SDL_FreeSurface(backgroundSurface);
            texture = backgroundTexture;
            SDL_Surface* goodSurface = IMG_Load("Image/good.png");
            SDL_Texture* goodTexture = SDL_CreateTextureFromSurface(renderer, goodSurface);
            SDL_FreeSurface(goodSurface);
            SDL_Surface* missSurface = IMG_Load("Image/miss.png");
            SDL_Texture* missTexture = SDL_CreateTextureFromSurface(renderer, missSurface);
            SDL_FreeSurface(missSurface);
            SDL_Surface* perfectSurface = IMG_Load("Image/perfect.png");
            SDL_Texture* perfectTexture = SDL_CreateTextureFromSurface(renderer, perfectSurface);
            SDL_FreeSurface(perfectSurface);    
            SDL_Surface* tooearlySurface = IMG_Load("Image/too early.png");
            SDL_Texture* tooearlyTexture = SDL_CreateTextureFromSurface(renderer, tooearlySurface);
            SDL_FreeSurface(tooearlySurface);
            
            //thread to play gameplay music
            t1 = std::thread([&music]() {
                Mix_PlayMusic(music, -1);
                });
            t1.join();
            //variable for gameplay
            time_t startTime = std::time(nullptr);
            int demkey = 0;
            int demperfect = 0;
            int choice;
            int perfect = 0;
            int good = 0;
            int miss = 0;
            int tooearly = 0;
            int waitlongnood = 0;
            speed = 6;
            //gameplay loop
            while (gameplay) {
                // check time after each loop
                time_t currentTime = std::time(nullptr);
                time_t elapsedTime = currentTime - startTime;
                while (SDL_PollEvent(&e) != 0) {
                    if (e.type == SDL_QUIT) {
                        quit = true;
                    }
                }
                destinationRect = { 0,0, 1080, 810 };
                SDL_RenderCopyEx(renderer, texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
                demSpeed += 1;
                //control speed, create wave nood
                if (demSpeed >= 1) {
                    demSpeed = 0;
                    for (Noods*& x : noods) {
                        if (x->check == true) {
                            if (x->y >= 810) {
                                x->check = false;
                                choice = 0;
                                demperfect = 20;
                                miss++;
                            }
                            x->y +=speed ;//move nood and control speed
                            SDL_Rect noodrect = { x->x,x->y, 100, 100 };
                            //check type of nood to render
                            if (x->type == 1) {
                                //Ã©p kiá»ƒu sang longnood Ä‘á»ƒ váº½
                               Longnoods* y= (Longnoods*)x;
                                renderLongnood(renderer, longnoodTexture, y->length, y->x+33, y->y);
                           }
                            else {
								SDL_RenderCopyEx(renderer, x->a, NULL, &noodrect, 0.0, NULL, SDL_FLIP_NONE);
                            }
                        }
                      
                      
                    }
                    demWave +=2;
                    // wave of nood
                    if (demWave >= maxWave&&waitlongnood<=0) {
                        demWave = 0;
                        //create new wave nood
                        vector<int> position = creatpositionofnood(creatnumberofnood());
                        if (elapsedTime <= 268 && !(elapsedTime >= 206 && elapsedTime <= 210)) {
                            int type=generateRandomNumber(1,8);
                            if (elapsedTime < 50 || type>1) {
                                for (int i = 0; i < position.size(); i++) {
								   Noods* nood = new Noods;
								   nood->a = noodTexture;
								   nood->x = positionnood[position[i] - 1];
								   nood->y = 0;
								   nood->check = true;
								   noods.push_back(nood);
							   }
						   }
                            else {
                                int length = generateRandomNumber(200,400);
                                for (int i = 0; i < position.size(); i++) {
                                    Longnoods* longnood = new Longnoods;
                                    longnood->a = longnoodTexture;
                                    longnood->x = positionnood[position[i] - 1];
                                    longnood->y = 0-length;
                                    longnood->check = true;
                                    longnood->length = length;
                                    noods.push_back(longnood);
                                    noods.back()->type = 1;
                                   
                               }
                                waitlongnood = length / speed*2 + maxWave;
                            }
                        }
                        // increase speecd of nood follow time
                        demsp++;
                        if (demsp >= 23) {
                            if (speed <12) {
                                speed += 1;
                            }
                            if(maxWave>60) maxWave -= 5;
                            demsp = 0;
                        }
                    }
                    else if(waitlongnood>0) waitlongnood-=2;
                }
                if (noods.size() > 50) {
                    //giáº£i phÃ³ng bá»™ nhá»› vÃ  xÃ³a 30 pháº§n tá»­ Ä‘áº§u
                    for (int i = 0; i < 30; i++) {
						delete noods[i];
					}
                    noods.erase(noods.begin(), noods.begin() + 30);
                }
                if (demkey == 0) {//demkey to reduce stick key
                    //main gameplay get point and check correct nood be pressed
                    for (Noods*& x : noods) {
                        if (x->check == true && x->y >= 525 && x->y <= 800) {
                            if (x->x == 59 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_S]) {
                                x->check = false;
                                if (x->y >= 525 && x->y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x->y >= 575 && x->y < 630) || (x->y >= 740 && x->y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x->y >= 630 && x->y < 740) { choice = 3; demperfect = 20; perfect++; }
                                demkey = 10;
                            }
                            else if (x->x == 205 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_D]) {
                                x->check = false;
                                
                                if (x->y >= 525 && x->y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x->y >= 575 && x->y < 630) || (x->y >= 740 && x->y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x->y >= 630 && x->y < 740) { choice = 3; demperfect = 20; perfect++; }
                               
                                demkey = 10;
                            }
                            else if (x->x == 331 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_F]) {
                                x->check = false;
                               
                                if (x->y >= 525 && x->y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x->y >= 575 && x->y < 630) || (x->y >= 740 && x->y < 800)) { choice = 2; demperfect = 20;good++; }
                                else if (x->y >= 630 && x->y < 740) { choice = 3; demperfect = 20; perfect++; }
                                
                                    demkey = 10;
                            }
                            else if (x->x == 605 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_J]) {
                                x->check = false;
                                
                                if (x->y >= 525 && x->y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x->y >= 575 && x->y < 630) || (x->y >= 740 && x->y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x->y >= 630 && x->y < 740) { choice = 3; demperfect = 20; perfect++; }
								
									
                                
                                demkey = 10;
                            }
                            else if (x->x == 751 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_K]) {
                                x->check = false;

                                if (x->y >= 525 && x->y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x->y >= 575 && x->y < 630) || (x->y >= 740 && x->y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x->y >= 630 && x->y < 740) { choice = 3; demperfect = 20; perfect++; }
								
								
                             
                                demkey = 10;
                            }
                            else if (x->x == 876 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_L]) {
                                x->check = false;
                               
                                if (x->y >= 525 && x->y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x->y >= 575 && x->y < 630) || (x->y >= 740 && x->y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x->y >= 630 && x->y < 740) { choice = 3; demperfect = 20; perfect++; }
                               
                                demkey = 10;
                            }
                            else continue;
                        }
                        else if (x->check == true && x->y < 575) { break; }
                    }
                }
                else demkey--;
                //pause game if esc press
                
              
                    if (SDL_GetKeyboardState(NULL)[SDL_SCANCODE_ESCAPE]) {
                        Mix_PauseMusic();
                        SDL_Surface* pauseSurface = IMG_Load("Image/pause.png");
                        SDL_Texture* pauseTexture = SDL_CreateTextureFromSurface(renderer, pauseSurface);
                        SDL_FreeSurface(pauseSurface);
                        destinationRect = {230,200, 600, 450};
                        SDL_RenderCopyEx(renderer, pauseTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
                        SDL_RenderPresent(renderer);
                        while (true) {
                            //if mouse click
                            SDL_PollEvent(&e);
                            if (e.type == SDL_MOUSEBUTTONDOWN) {
                                int x, y;
                                SDL_GetMouseState(&x, &y);
                                //check button be clicked
                                if (x > 450 && x < 600 && y > 350 && y < 500) {
                                    // Resume button clicked
                                    Mix_ResumeMusic();
                                    break;
                                }
                                else if (x > 320 && x < 440 && y > 510 && y < 580) {
                                    // Quit button clicked
                                    noods.resize(0);
                                    std::thread t1([&music]() {
                                        Mix_PlayMusic(music, -1);
                                        if (music == NULL) Mix_PlayMusic(music, -1);
                                        });
                                    t1.join();
                                    perfect = 0;
                                    good = 0;
                                    miss = 0;
                                    tooearly = 0;
                                    startTime = std::time(nullptr);
                                    break;
                                }
                                else if (y > 510 && y < 580&&x>610&&x<730) {
									gameplay = false;
                                    noods.resize(0);
                                    break;
								}
							}
                        }
                        SDL_DestroyTexture(pauseTexture);
                        demkey = 10;
                    }

                }
                else demkey--;
                //code for display result of nood be pressed
                if (demperfect > 0) {
                    demperfect--;
                    //thread to display result
                    thread t2([&renderer, perfectTexture,goodTexture,missTexture,tooearlyTexture,choice]() {
                        SDL_Rect destinationRect = { 430,550,200,250 };
                        if (choice == 0) SDL_RenderCopyEx(renderer, missTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
						else if (choice == 1) SDL_RenderCopyEx(renderer, tooearlyTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
						else if (choice == 2) SDL_RenderCopyEx(renderer, goodTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
						else if (choice == 3)
                        SDL_RenderCopyEx(renderer, perfectTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
                        });

                    t2.join();
                }
                //renderer gameplay
                SDL_RenderPresent(renderer);
             
                SDL_Delay(12);
               //check to end game
                if ((size(noods) == 0 || noods.back()->check == false) && elapsedTime >= 271) {
                    Mix_HaltMusic();
                    //end music
                    Mix_Music* end = Mix_LoadMUS("music/end.mp3");
                    if (end == NULL) {
						printf("Failed to load music! SDL_mixer Error: %s\n", Mix_GetError());
						return 1;
					}
                    Mix_PlayMusic(end, 1);
                    SDL_Delay(400);
                    gameplay = false;
                    noods.resize(0);
                    //complete game and caculate point and display
                    SDL_Surface* complete0Surface = IMG_Load("Image/complete0.png");
                    SDL_Texture* complete0Texture = SDL_CreateTextureFromSurface(renderer, complete0Surface);
                    SDL_FreeSurface(complete0Surface);
                    SDL_Surface* complete1Surface = IMG_Load("Image/complete1.png");
                    SDL_Texture* complete1Texture = SDL_CreateTextureFromSurface(renderer, complete1Surface);
                    SDL_FreeSurface(complete1Surface);
                    SDL_Surface* complete2Surface = IMG_Load("Image/complete2.png");
                    SDL_Texture* complete2Texture = SDL_CreateTextureFromSurface(renderer, complete2Surface);
                    SDL_FreeSurface(complete2Surface);
                    SDL_Surface* complete3Surface = IMG_Load("Image/complete3.png");
                    SDL_Texture* complete3Texture = SDL_CreateTextureFromSurface(renderer, complete3Surface);
                    SDL_FreeSurface(complete3Surface);
                   int point=perfect*5+good*3;
                   float completionRate = (perfect*1.0 * 2 + good) / ((perfect + good + miss + tooearly) * 2);
                   destinationRect = {-10,0,1200,810 };
                   if (completionRate>0.8) {
						destinationRect = { -80,0,1200,810 };
						SDL_RenderCopyEx(renderer, complete3Texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
                       
					}
                   else if (completionRate>0.6) {
						
						SDL_RenderCopyEx(renderer, complete2Texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
					}
                   else if (completionRate>0.4) {
						
						SDL_RenderCopyEx(renderer, complete1Texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
					}
                   else {
						
						SDL_RenderCopyEx(renderer, complete0Texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
					}
                   //use ttf to write completed art
                   thread t3([&renderer, point, perfect, good, miss, tooearly]() {
                   TTF_Init();
                   TTF_Font* font = TTF_OpenFont("Front/font.ttf", 24);
                   SDL_Color color = { 255, 255, 0 };
                   SDL_Surface* surface;
                   SDL_Texture* texture;
                   SDL_Rect textRect;
                   if (miss + tooearly == 0 && good == 0) {
                       surface = TTF_RenderText_Solid(font, "So Amazing, You are perfect", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 210,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                   else if (miss + tooearly<0.05*(perfect+good+miss+tooearly) && good > 0 && good<0.25 * perfect) {
                       surface = TTF_RenderText_Solid(font, "Great,you're almost perfect", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 220,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                   else if ((good + perfect*2) > 0.8* (miss + tooearly + good + perfect)*2) {
                       surface = TTF_RenderText_Solid(font, "Good", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 475,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                   else if ( (good + perfect*2)> 0.6* (miss + tooearly + good + perfect)*2) {
                       surface = TTF_RenderText_Solid(font, "Not bad but you can better", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 240,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                   else {
                       surface = TTF_RenderText_Solid(font, "You need to practice more", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 230,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                    surface = TTF_RenderText_Solid(font, ("Your point is: " + to_string(point)).c_str(), color);
                    texture = SDL_CreateTextureFromSurface(renderer, surface);
                    textRect = { 325,400, surface->w, surface->h };
                   SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   surface = TTF_RenderText_Solid(font, ("Perfect: " + to_string(perfect)).c_str(), color);
                   texture = SDL_CreateTextureFromSurface(renderer, surface);
                   textRect = { 325,450, surface->w, surface->h };
                   SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   surface = TTF_RenderText_Solid(font, ("Good: " + to_string(good)).c_str(), color);
                   texture = SDL_CreateTextureFromSurface(renderer, surface);
                   textRect = { 325,500, surface->w, surface->h };
                   SDL_RenderCopy(renderer, texture, NULL, &textRect);  
                   surface = TTF_RenderText_Solid(font, ("Error: " + to_string(miss+tooearly)).c_str(), color);
                   texture = SDL_CreateTextureFromSurface(renderer, surface);
                    textRect = { 325,550, surface->w, surface->h };
                    SDL_RenderCopy(renderer, texture, NULL, &textRect);
					SDL_DestroyTexture(texture);
					SDL_FreeSurface(surface);
					TTF_CloseFont(font);
					TTF_Quit();
					});
					t3.join();
					SDL_RenderPresent(renderer);
                    //completed loop
                    while (true) {
						//check button be clicked
						SDL_PollEvent(&e);
                        if (e.type == SDL_MOUSEBUTTONDOWN) {
                            int x, y;
							SDL_GetMouseState(&x, &y);
							//replay button
                            if (x > 230&& x <400 && y > 620 && y < 800) {
                                gameplay = true;
                                noods.resize(0);
                                std::thread t1([&music]() {
                                    Mix_PlayMusic(music, -1);
                                    if (music == NULL) Mix_PlayMusic(music, -1);
                                    });
                                t1.join();
                                //time reset
                                startTime = std::time(nullptr);
                                perfect = 0;
                                good = 0;
                                miss = 0;
                                tooearly = 0;
                                break;
							}
                            //quit button
                            else if (x > 680 && x < 860 && y > 610 && y < 780) {
								noods.resize(0);
                                std::thread t1([&music]() {
									Mix_PlayMusic(music, -1);
									if (music == NULL) Mix_PlayMusic(music, -1);
									});
								t1.join();
								perfect = 0;
								good = 0;
								miss = 0;
								tooearly = 0;
                                SDL_DestroyTexture(backgroundTexture);
                                SDL_DestroyTexture(goodTexture);
                                SDL_DestroyTexture(missTexture);
                                SDL_DestroyTexture(perfectTexture);
                                SDL_DestroyTexture(tooearlyTexture);
								break;
							}
                           
						}
					}
                    SDL_DestroyTexture(complete0Texture);
                    SDL_DestroyTexture(complete1Texture);
                    SDL_DestroyTexture(complete2Texture);
                    SDL_DestroyTexture(complete3Texture);
                    Mix_FreeMusic(end);
                    
                }
                //check time
                cout << elapsedTime<< endl;
               
            }
            startTime = std::time(nullptr);
        }
        //close music
        Mix_FreeMusic(music);
       
    }

   
    // endgame
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_DestroyTexture(noodTexture);
    SDL_DestroyTexture(longnoodTexture);
    SDL_Quit();
    return 0;
}
¯OriginalContentÀªSelections¨FilePathÙMC:\Users\ttk08\OneDrive\Documents\GitHub\project\Project2\Project2\Source.cpp¨Language£C++‘’“¥Value Ùb#file:'Source.cpp'  cÃ³ váº» tÃ´i Ä‘Ã£ xÃ³a nháº§m dáº¥u { á»Ÿ Ä‘Ã¢u Ä‘Ã³ báº¡n  cÃ³ biáº¿t khÃ´ngÀ¨Response…§ContentÚ/Dá»±a trÃªn Ä‘oáº¡n mÃ£ báº¡n Ä‘Ã£ cung cáº¥p, cÃ³ váº» nhÆ° báº¡n Ä‘Ã£ xÃ³a nháº§m dáº¥u `{` á»Ÿ cuá»‘i Ä‘oáº¡n mÃ£. Äoáº¡n mÃ£ cuá»‘i cÃ¹ng cá»§a báº¡n Ä‘ang má»Ÿ má»™t cÃ¢u lá»‡nh `if` nhÆ°ng khÃ´ng cÃ³ dáº¥u `{` Ä‘á»ƒ báº¯t Ä‘áº§u khá»‘i mÃ£ cho cÃ¢u lá»‡nh `if` Ä‘Ã³. 

ÄÃ¢y lÃ  Ä‘oáº¡n mÃ£ Ä‘Ã£ Ä‘Æ°á»£c sá»­a:

```C++
...
else if (choice == 2) SDL_RenderCopyEx(renderer, goodTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
else if (choice == 3) {
    SDL_RenderCopyEx(renderer, perfectTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
}
...
```

Tuy nhiÃªn, Ä‘Ã¢y chá»‰ lÃ  giáº£ Ä‘á»‹nh dá»±a trÃªn Ä‘oáº¡n mÃ£ báº¡n Ä‘Ã£ cung cáº¥p. Báº¡n nÃªn kiá»ƒm tra láº¡i toÃ n bá»™ mÃ£ nguá»“n Ä‘á»ƒ Ä‘áº£m báº£o ráº±ng táº¥t cáº£ cÃ¡c khá»‘i mÃ£ Ä‘á»u Ä‘Æ°á»£c má»Ÿ vÃ  Ä‘Ã³ng Ä‘Ãºng cÃ¡ch.¤Type ¦Status¯FollowUpPrompts’ÙZIs there a tool in Visual Studio that can help me find missing or extra braces in my code?ÙICan you explain more about the SDL_RenderCopyEx function used in my code?³CodeVulnerabilities…¨DateTime×ÿ>Ò eû6ªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$0f8fcd87-1190-4a4b-ab3e-52d1f519f8acÙ$60abcdcc-bcdf-4474-a437-7c8155284904‘’“¥Value °dÃ²ng bao nhiÃªuÀ¨Response…§ContentÚ~Dá»±a trÃªn Ä‘oáº¡n mÃ£ báº¡n Ä‘Ã£ cung cáº¥p, cÃ³ váº» nhÆ° báº¡n Ä‘Ã£ xÃ³a nháº§m dáº¥u `{` á»Ÿ dÃ²ng 405, ngay sau cÃ¢u lá»‡nh `else if (x->x == 876 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_L])`. 

ÄÃ¢y lÃ  Ä‘oáº¡n mÃ£ Ä‘Ã£ Ä‘Æ°á»£c sá»­a:

```C++
...
else if (x->x == 876 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_L]) {
    x->check = false;
    if (x->y >= 525 && x->y < 575) { choice = 1; demperfect = 20; tooearly++; }
    else if ((x->y >= 575 && x->y < 630) || (x->y >= 740 && x->y < 800)) { choice = 2; demperfect = 20; good++; }
    else if (x->y >= 630 && x->y < 740) { choice = 3; demperfect = 20; perfect++; }
    demkey = 10;
}
...
```

Tuy nhiÃªn, Ä‘Ã¢y chá»‰ lÃ  giáº£ Ä‘á»‹nh dá»±a trÃªn Ä‘oáº¡n mÃ£ báº¡n Ä‘Ã£ cung cáº¥p. Báº¡n nÃªn kiá»ƒm tra láº¡i toÃ n bá»™ mÃ£ nguá»“n Ä‘á»ƒ Ä‘áº£m báº£o ráº±ng táº¥t cáº£ cÃ¡c khá»‘i mÃ£ Ä‘á»u Ä‘Æ°á»£c má»Ÿ vÃ  Ä‘Ã³ng Ä‘Ãºng cÃ¡ch.¤Type ¦Status¯FollowUpPrompts’ÙWLÃ m tháº¿ nÃ o Ä‘á»ƒ tÃ´i cÃ³ thá»ƒ trÃ¡nh nhá»¯ng lá»—i nhÆ° váº­y trong tÆ°Æ¡ng lai?ÙICÃ³ cÃ´ng cá»¥ nÃ o giÃºp tÃ´i kiá»ƒm tra cÃº phÃ¡p cá»§a mÃ£ C++ khÃ´ng?³CodeVulnerabilities…¨DateTime×ÿC9• eû&ªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$0b21a913-a635-457a-815c-5df49efce87cÙ$1aefd8b0-3c78-4a2e-9606-aa50225828e9‘†¯ProviderMoniker‚¤NameÙ6Microsoft.VisualStudio.Copilot.DocumentContextProvider§Version£0.1¦Member¤file©CanReduceÃ©RequestIdÙ$0b21a913-a635-457a-815c-5df49efce87c©Reference²#file:'Source.cpp'¥ValueÈ†@dÙ‘Microsoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a…§ContentÚ…#include <SDL.h>
#include <stdio.h>
#include <SDL_image.h>
#include <iostream>
#include <ctime>
#include<vector>
#include<algorithm>
#include<random>
#include<SDL_mixer.h>
#include<SDL_ttf.h>
#include<thread>

using namespace std;


//creat a funtion to generate random number from seed time
int generateRandomNumber(int min, int max) {
	static bool first = true;
    if (first) {
		srand(time(NULL));
		first = false;
	}
	return min + rand() % ((max + 1) - min);
}
//creat a funtion to generate n random numbers from seed time
vector<int> generateRandomNumbers(int min, int max, int n) {
	vector<int> result;
    for (int i = 0; i < n; i++) {
		result.push_back(generateRandomNumber(min, max));
	}
	return result;
}
const int positionnood[] = { 59,205,331,605,751,876 };//position of nood
const int numbernood[]={1,1,1,1,1,1,2,2,2,2,2,3,3,1,3,4,1,4,6,2};//rate of random number of nood
//funtion to random number of nood
int creatnumberofnood() {
	int numberofnood = generateRandomNumber(1,20);
	return numbernood[numberofnood];
}
//funtion to random position of nood with number of nood
vector<int> creatpositionofnood(int numbernood) {
    vector<int> result;
    if (numbernood % 2 == 0) {
        
        result= generateRandomNumbers(1, 3, numbernood/2);
        for (int i = 0; i < numbernood / 2; i++) { result.push_back(6 - result[i] + 1); }
        return result;
    }
    else {
        int th=generateRandomNumber(1,2);
        if (th == 1) {
           
            return generateRandomNumbers(1, 3, numbernood);
        }
        else {
            return generateRandomNumbers(4, 6, numbernood);
		}
    }
    return result;
}
//struct of nood
struct Noods {
    SDL_Texture* a;
    int x=0, y=0;
    bool check = false;
    int type = 0;
};
struct Longnoods:Noods {
    int length;
    bool isbeinghold;
    int type = 1;
};
void renderLongnood(SDL_Renderer* renderer, SDL_Texture* longnoodTexture, int customLength, int posX, int posY) {
    // Táº¡o SDL_Rect cho pháº§n Ä‘áº§u cá»§a longnood
    SDL_Rect headRect = { 0, 0, 88, customLength/2*4.5 };
    SDL_Rect destHeadRect = { posX, posY, 44, customLength/2 };
    // Táº¡o SDL_Rect cho pháº§n cuá»‘i cá»§a longnood
    SDL_Rect tailRect = { 0, 3532 - customLength/2*4.5, 88, customLength/2*4.5 };
    SDL_Rect destTailRect = { posX, posY + customLength/2, 44, customLength/2 };
    // Váº½ pháº§n Ä‘áº§u, thÃ¢n vÃ  cuá»‘i cá»§a longnood
    SDL_RenderCopyEx(renderer, longnoodTexture, &headRect, &destHeadRect, 0.0, NULL, SDL_FLIP_NONE);
    SDL_RenderCopyEx(renderer, longnoodTexture, &tailRect, &destTailRect, 0.0, NULL, SDL_FLIP_NONE);
}
int main(int argc, char* args[]) {
    bool gameplay = false;

    // Khá»Ÿi táº¡o SDL
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        printf("SDL could not initialize! SDL_Error: %s\n", SDL_GetError());
        return 1;
    }

    SDL_Window* window = SDL_CreateWindow("SDL 2.0 Basic Example", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 1080, 810, SDL_WINDOW_SHOWN);
    if (window == NULL) {
        printf("Window could not be created! SDL_Error: %s\n", SDL_GetError());
        return 1;
    }

    // Táº¡o renderer
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    if (renderer == NULL) {
        printf("Renderer could not be created! SDL_Error: %s\n", SDL_GetError());
        return 1;
    }
    SDL_Surface* noodSurface = IMG_Load("Image/nood.png");
    if (noodSurface == NULL) {
        printf("SDL could not load image! SDL Error: %s\n", SDL_GetError());
        return 1;
    }
    SDL_Surface* longnoodSurface = IMG_Load("Image/longnood.png");
    if (longnoodSurface == NULL) {
		printf("SDL could not load image! SDL Error: %s\n", SDL_GetError());
		return 1;
	}
    SDL_Texture* noodTexture = SDL_CreateTextureFromSurface(renderer, noodSurface);
    SDL_FreeSurface(noodSurface);
    SDL_Rect noodRect = { 100,1.1, 100, 100 };
    SDL_Texture* longnoodTexture = SDL_CreateTextureFromSurface(renderer, longnoodSurface);
    SDL_FreeSurface(longnoodSurface);
    //create longnoodreact with full image of longnood
    SDL_Rect longnoodRect = { 205,50, 22, 200};

    SDL_Surface* openSurface = IMG_Load("Image/open.png");
    SDL_Texture* openTexture = SDL_CreateTextureFromSurface(renderer, openSurface);
    SDL_FreeSurface(openSurface);

   
    SDL_Texture* texture = openTexture;
    
    SDL_Rect destinationRect = { 0,0, 1080, 810 };
    SDL_RenderCopyEx(renderer, texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
    
    
    Noods nood;
    nood.a = noodTexture;
    nood.x = 59;
    nood.y = 0;
    nood.check = true;
    //creat vector nood for gameplay
    vector<Noods*> noods;
    
    Longnoods longnood;
    longnood.a = longnoodTexture;
    longnood.x = 205;
    longnood.y = 0;
    longnood.check = true;
    SDL_RenderPresent(renderer);

    //loop of opentexture go to game if mouse click
    while (true) {
        //if mouse click
        SDL_Event e;
        SDL_PollEvent(&e);
        if (e.type == SDL_MOUSEBUTTONDOWN) {
            break;
        }
    }
    SDL_DestroyTexture(openTexture);
    bool quit = false;
    SDL_Event e;
    // variable to control speed and number of nood
    float demSpeed = 0;
    float demWave = 0;
    int demNood = 0;
    int speed = 6;
    int demsp = 0;
    int maxWave = 125;
    if (SDL_Init(SDL_INIT_AUDIO) < 0) {
        printf("SDL could not initialize! SDL_Error: %s\n", SDL_GetError());
        return 1;
    }
    if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048) < 0) {
        printf("SDL_mixer could not initialize! SDL_mixer Error: %s\n", Mix_GetError());
        return 1;
    }

    // load menu music
    Mix_Music* music = Mix_LoadMUS("music/menu.mp3");
    if (music == NULL) {
        printf("Failed to load music! SDL_mixer Error: %s\n", Mix_GetError());
        return 1;
    }
    //main loop start menu 
    while (!quit) {
        SDL_Surface* menuSurface = IMG_Load("Image/Menu.png");
        SDL_Texture* menuTexture = SDL_CreateTextureFromSurface(renderer, menuSurface);
        SDL_FreeSurface(menuSurface);
        SDL_Surface* menu1Surface = IMG_Load("Image/Menu1.png");
        SDL_Texture* menu1Texture = SDL_CreateTextureFromSurface(renderer, menu1Surface);
        SDL_FreeSurface(menu1Surface);

        SDL_Surface* menu2Surface = IMG_Load("Image/Menu2.png");
        SDL_Texture* menu2Texture = SDL_CreateTextureFromSurface(renderer, menu2Surface);
        SDL_FreeSurface(menu2Surface);

        SDL_Surface* menu3Surface = IMG_Load("Image/Menu3.png");
        SDL_Texture* menu3Texture = SDL_CreateTextureFromSurface(renderer, menu3Surface);
        SDL_FreeSurface(menu3Surface);
        texture = menuTexture;
        //thread to play menu music and play again if music menu end
        std::thread t1([&music]() {
            Mix_PlayMusic(music, -1);
            if (music == NULL) Mix_PlayMusic(music, -1);

            });
        t1.join();
        //menu loop
        while (true) {

            while (SDL_PollEvent(&e) != 0) {
                if (e.type == SDL_QUIT) {
                    quit = true;
                }
            }

            SDL_Rect destinationRect = { 0,0.0, 1080, 810 };
            SDL_RenderCopyEx(renderer, texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
            SDL_RenderPresent(renderer);
   //get mouse position
            int x, y;
            SDL_GetMouseState(&x, &y);
            //action with each button of menu be clicked
            //play button
            if (x > 400 && x < 700) {
                if (y > 350 && y < 475) {
                    texture = menu1Texture;
                    //go to gameplay if mouse click in play button
                    SDL_PollEvent(&e);
                    if (e.type == SDL_MOUSEBUTTONDOWN) {
                        gameplay = true;

                        break;
                    }
                }
                //how to play button
                else if (y > 490 && y < 600) {
                    texture = menu2Texture;
                    SDL_PollEvent(&e);
                    if (e.type == SDL_MOUSEBUTTONDOWN) {
						//pause music and display how to play texture
                        Mix_PauseMusic();
						SDL_Surface* howtoplaySurface = IMG_Load("Image/how to play.png");
						SDL_Texture* howtoplayTexture = SDL_CreateTextureFromSurface(renderer, howtoplaySurface);
						SDL_FreeSurface(howtoplaySurface);
						destinationRect = { 0,0, 1080, 810 };
						SDL_RenderCopyEx(renderer, howtoplayTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
						SDL_RenderPresent(renderer);
                        SDL_Delay(500);
						//how to play loop
                        while (true) {
							SDL_PollEvent(&e);
                            //go back to menu if mouse click
                            if (e.type == SDL_MOUSEBUTTONDOWN) {
								SDL_DestroyTexture(howtoplayTexture);
								break;
                            }
						}
						SDL_DestroyTexture(howtoplayTexture);
                        //music resume
                        Mix_ResumeMusic();
					}
                    
                }
                //exit button
                else if (y > 600 && y < 700) {

                    texture = menu3Texture;
                    //program quif if mouse click

                    SDL_PollEvent(&e);
                    if (e.type == SDL_MOUSEBUTTONDOWN) {

                        return 0;

                    }

                }
				//if mouse not in button
                else {
                    texture = menuTexture;
                }
            }
			//if mouse not in button
            else {
                texture = menuTexture;
            }
        }
        // Load gameplay music
        Mix_Music* music = Mix_LoadMUS("music/AdhesiveWombat - 8 Bit Adventure.mp3");
        if (music == NULL) {
            printf("Failed to load music! SDL_mixer Error: %s\n", Mix_GetError());
            return 1;
        }
        //setup for gameplay
        if (gameplay == true) {
            //delete menu texture
            SDL_DestroyTexture(menuTexture);
            SDL_DestroyTexture(menu1Texture);
            SDL_DestroyTexture(menu2Texture);
            SDL_DestroyTexture(menu3Texture);
            SDL_Surface* backgroundSurface = IMG_Load("Image/gameplay.png");
            if (backgroundSurface == NULL) {
                printf("SDL could not load image! SDL Error: %s\n", SDL_GetError());
                return 1;
            }
            SDL_Texture* backgroundTexture = SDL_CreateTextureFromSurface(renderer, backgroundSurface);
            SDL_FreeSurface(backgroundSurface);
            texture = backgroundTexture;
            SDL_Surface* goodSurface = IMG_Load("Image/good.png");
            SDL_Texture* goodTexture = SDL_CreateTextureFromSurface(renderer, goodSurface);
            SDL_FreeSurface(goodSurface);
            SDL_Surface* missSurface = IMG_Load("Image/miss.png");
            SDL_Texture* missTexture = SDL_CreateTextureFromSurface(renderer, missSurface);
            SDL_FreeSurface(missSurface);
            SDL_Surface* perfectSurface = IMG_Load("Image/perfect.png");
            SDL_Texture* perfectTexture = SDL_CreateTextureFromSurface(renderer, perfectSurface);
            SDL_FreeSurface(perfectSurface);    
            SDL_Surface* tooearlySurface = IMG_Load("Image/too early.png");
            SDL_Texture* tooearlyTexture = SDL_CreateTextureFromSurface(renderer, tooearlySurface);
            SDL_FreeSurface(tooearlySurface);
            
            //thread to play gameplay music
            t1 = std::thread([&music]() {
                Mix_PlayMusic(music, -1);
                });
            t1.join();
            //variable for gameplay
            time_t startTime = std::time(nullptr);
            int demkey = 0;
            int demperfect = 0;
            int choice;
            int perfect = 0;
            int good = 0;
            int miss = 0;
            int tooearly = 0;
            int waitlongnood = 0;
            speed = 6;
            //gameplay loop
            while (gameplay) {
                // check time after each loop
                time_t currentTime = std::time(nullptr);
                time_t elapsedTime = currentTime - startTime;
                while (SDL_PollEvent(&e) != 0) {
                    if (e.type == SDL_QUIT) {
                        quit = true;
                    }
                }
                destinationRect = { 0,0, 1080, 810 };
                SDL_RenderCopyEx(renderer, texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
                demSpeed += 1;
                //control speed, create wave nood
                if (demSpeed >= 1) {
                    demSpeed = 0;
                    for (Noods*& x : noods) {
                        if (x->check == true) {
                            if (x->y >= 810) {
                                x->check = false;
                                choice = 0;
                                demperfect = 20;
                                miss++;
                            }
                            x->y += speed;//move nood and control speed
                            SDL_Rect noodrect = { x->x,x->y, 100, 100 };
                            //check type of nood to render
                            if (x->type == 1) {
                                //Ã©p kiá»ƒu sang longnood Ä‘á»ƒ váº½
                                Longnoods* y = (Longnoods*)x;
                                renderLongnood(renderer, longnoodTexture, y->length, y->x + 30, y->y);
                            }
                            else {
                                SDL_RenderCopyEx(renderer, x->a, NULL, &noodrect, 0.0, NULL, SDL_FLIP_NONE);
                            }
                        }


                    }
                    demWave += 2;
                    // wave of nood
                    if (demWave >= maxWave && waitlongnood <= 0) {
                        demWave = 0;
                        //create new wave nood
                        vector<int> position = creatpositionofnood(creatnumberofnood());
                        if (elapsedTime <= 268 && !(elapsedTime >= 206 && elapsedTime <= 210)) {
                            int type = generateRandomNumber(1, 8);
                            if (elapsedTime < 10|| type>1) {
                                for (int i = 0; i < position.size(); i++) {
                                    Noods* nood = new Noods;
                                    nood->a = noodTexture;
                                    nood->x = positionnood[position[i] - 1];
                                    nood->y = 0;
                                    nood->check = true;
                                    noods.push_back(nood);
                                }
                            }
                            else {
                                int length = generateRandomNumber(200, 400);
                                for (int i = 0; i < position.size(); i++) {
                                    Longnoods* longnood = new Longnoods;
                                    longnood->a = longnoodTexture;
                                    longnood->x = positionnood[position[i] - 1];
                                    longnood->y = 0 - length;
                                    longnood->check = true;
                                    longnood->length = length;
                                    noods.push_back(longnood);
                                    noods.back()->type = 1;

                                }
                                waitlongnood = length / speed * 2 + maxWave;
                            }
                        }
                        // increase speecd of nood follow time
                        demsp++;
                        if (demsp >= 23) {
                            if (speed < 12) {
                                speed += 1;
                            }
                            if (maxWave > 60) maxWave -= 5;
                            demsp = 0;
                        }
                    }
                    else if (waitlongnood > 0) waitlongnood -= 2;
                }
                if (noods.size() > 50) {
                    //giáº£i phÃ³ng bá»™ nhá»› vÃ  xÃ³a 30 pháº§n tá»­ Ä‘áº§u
                    for (int i = 0; i < 30; i++) {
                        delete noods[i];
                    }
                    noods.erase(noods.begin(), noods.begin() + 30);
                }
                if (demkey == 0) {//demkey to reduce stick key
                    //main gameplay get point and check correct nood be pressed
                    for (Noods*& x : noods) {
                        if (x->check == true && x->y >= 525 && x->y <= 800) {
                            if (x->x == 59 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_S]) {
                                x->check = false;
                                if (x->y >= 525 && x->y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x->y >= 575 && x->y < 630) || (x->y >= 740 && x->y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x->y >= 630 && x->y < 740) { choice = 3; demperfect = 20; perfect++; }
                                demkey = 10;
                            }
                            else if (x->x == 205 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_D]) {
                                x->check = false;

                                if (x->y >= 525 && x->y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x->y >= 575 && x->y < 630) || (x->y >= 740 && x->y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x->y >= 630 && x->y < 740) { choice = 3; demperfect = 20; perfect++; }

                                demkey = 10;
                            }
                            else if (x->x == 331 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_F]) {
                                x->check = false;

                                if (x->y >= 525 && x->y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x->y >= 575 && x->y < 630) || (x->y >= 740 && x->y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x->y >= 630 && x->y < 740) { choice = 3; demperfect = 20; perfect++; }

                                demkey = 10;
                            }
                            else if (x->x == 605 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_J]) {
                                x->check = false;

                                if (x->y >= 525 && x->y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x->y >= 575 && x->y < 630) || (x->y >= 740 && x->y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x->y >= 630 && x->y < 740) { choice = 3; demperfect = 20; perfect++; }



                                demkey = 10;
                            }
                            else if (x->x == 751 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_K]) {
                                x->check = false;

                                if (x->y >= 525 && x->y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x->y >= 575 && x->y < 630) || (x->y >= 740 && x->y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x->y >= 630 && x->y < 740) { choice = 3; demperfect = 20; perfect++; }



                                demkey = 10;
                            }
                            else if (x->x == 876 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_L]) {
                                x->check = false;

                                if (x->y >= 525 && x->y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x->y >= 575 && x->y < 630) || (x->y >= 740 && x->y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x->y >= 630 && x->y < 740) { choice = 3; demperfect = 20; perfect++; }

                                demkey = 10;
                            }
                            else continue;
                        }
                        else if (x->check == true && x->y < 575) { break; }
                    }
                }
                else demkey--;
               
              
                    if (SDL_GetKeyboardState(NULL)[SDL_SCANCODE_ESCAPE]) {
                        Mix_PauseMusic();
                        SDL_Surface* pauseSurface = IMG_Load("Image/pause.png");
                        SDL_Texture* pauseTexture = SDL_CreateTextureFromSurface(renderer, pauseSurface);
                        SDL_FreeSurface(pauseSurface);
                        destinationRect = {230,200, 600, 450};
                        SDL_RenderCopyEx(renderer, pauseTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
                        SDL_RenderPresent(renderer);
                        while (true) {
                            //if mouse click
                            SDL_PollEvent(&e);
                            if (e.type == SDL_MOUSEBUTTONDOWN) {
                                int x, y;
                                SDL_GetMouseState(&x, &y);
                                //check button be clicked
                                if (x > 450 && x < 600 && y > 350 && y < 500) {
                                    // Resume button clicked
                                    Mix_ResumeMusic();
                                    break;
                                }
                                else if (x > 320 && x < 440 && y > 510 && y < 580) {
                                    // Quit button clicked
                                    noods.resize(0);
                                    std::thread t1([&music]() {
                                        Mix_PlayMusic(music, -1);
                                        if (music == NULL) Mix_PlayMusic(music, -1);
                                        });
                                    t1.join();
                                    perfect = 0;
                                    good = 0;
                                    miss = 0;
                                    tooearly = 0;
                                    startTime = std::time(nullptr);
                                    break;
                                }
                                else if (y > 510 && y < 580&&x>610&&x<730) {
									gameplay = false;
                                    noods.resize(0);
                                    break;
								}
							}
                        }
                        SDL_DestroyTexture(pauseTexture);
                        demkey = 10;
                    }

                
                else demkey--;
                //code for display result of nood be pressed
                if (demperfect > 0) {
                    demperfect--;
                    //thread to display result
                    thread t2([&renderer, perfectTexture,goodTexture,missTexture,tooearlyTexture,choice]() {
                        SDL_Rect destinationRect = { 430,550,200,250 };
                        if (choice == 0) SDL_RenderCopyEx(renderer, missTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
						else if (choice == 1) SDL_RenderCopyEx(renderer, tooearlyTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
						else if (choice == 2) SDL_RenderCopyEx(renderer, goodTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
						else if (choice == 3)
                        SDL_RenderCopyEx(renderer, perfectTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
                        });

                    t2.join();
                }
                //renderer gameplay
                SDL_RenderPresent(renderer);
             
                SDL_Delay(12);
               //check to end game
                if ((size(noods) == 0 || noods.back()->check == false) && elapsedTime >= 271) {
                    Mix_HaltMusic();
                    //end music
                    Mix_Music* end = Mix_LoadMUS("music/end.mp3");
                    if (end == NULL) {
						printf("Failed to load music! SDL_mixer Error: %s\n", Mix_GetError());
						return 1;
					}
                    Mix_PlayMusic(end, 1);
                    SDL_Delay(400);
                    gameplay = false;
                    noods.resize(0);
                    //complete game and caculate point and display
                    SDL_Surface* complete0Surface = IMG_Load("Image/complete0.png");
                    SDL_Texture* complete0Texture = SDL_CreateTextureFromSurface(renderer, complete0Surface);
                    SDL_FreeSurface(complete0Surface);
                    SDL_Surface* complete1Surface = IMG_Load("Image/complete1.png");
                    SDL_Texture* complete1Texture = SDL_CreateTextureFromSurface(renderer, complete1Surface);
                    SDL_FreeSurface(complete1Surface);
                    SDL_Surface* complete2Surface = IMG_Load("Image/complete2.png");
                    SDL_Texture* complete2Texture = SDL_CreateTextureFromSurface(renderer, complete2Surface);
                    SDL_FreeSurface(complete2Surface);
                    SDL_Surface* complete3Surface = IMG_Load("Image/complete3.png");
                    SDL_Texture* complete3Texture = SDL_CreateTextureFromSurface(renderer, complete3Surface);
                    SDL_FreeSurface(complete3Surface);
                   int point=perfect*5+good*3;
                   float completionRate = (perfect*1.0 * 2 + good) / ((perfect + good + miss + tooearly) * 2);
                   destinationRect = {-10,0,1200,810 };
                   if (completionRate>0.8) {
						destinationRect = { -80,0,1200,810 };
						SDL_RenderCopyEx(renderer, complete3Texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
                       
					}
                   else if (completionRate>0.6) {
						
						SDL_RenderCopyEx(renderer, complete2Texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
					}
                   else if (completionRate>0.4) {
						
						SDL_RenderCopyEx(renderer, complete1Texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
					}
                   else {
						
						SDL_RenderCopyEx(renderer, complete0Texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
					}
                   //use ttf to write completed art
                   thread t3([&renderer, point, perfect, good, miss, tooearly]() {
                   TTF_Init();
                   TTF_Font* font = TTF_OpenFont("Front/font.ttf", 24);
                   SDL_Color color = { 255, 255, 0 };
                   SDL_Surface* surface;
                   SDL_Texture* texture;
                   SDL_Rect textRect;
                   if (miss + tooearly == 0 && good == 0) {
                       surface = TTF_RenderText_Solid(font, "So Amazing, You are perfect", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 210,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                   else if (miss + tooearly<0.05*(perfect+good+miss+tooearly) && good > 0 && good<0.25 * perfect) {
                       surface = TTF_RenderText_Solid(font, "Great,you're almost perfect", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 220,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                   else if ((good + perfect*2) > 0.8* (miss + tooearly + good + perfect)*2) {
                       surface = TTF_RenderText_Solid(font, "Good", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 475,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                   else if ( (good + perfect*2)> 0.6* (miss + tooearly + good + perfect)*2) {
                       surface = TTF_RenderText_Solid(font, "Not bad but you can better", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 240,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                   else {
                       surface = TTF_RenderText_Solid(font, "You need to practice more", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 230,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                    surface = TTF_RenderText_Solid(font, ("Your point is: " + to_string(point)).c_str(), color);
                    texture = SDL_CreateTextureFromSurface(renderer, surface);
                    textRect = { 325,400, surface->w, surface->h };
                   SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   surface = TTF_RenderText_Solid(font, ("Perfect: " + to_string(perfect)).c_str(), color);
                   texture = SDL_CreateTextureFromSurface(renderer, surface);
                   textRect = { 325,450, surface->w, surface->h };
                   SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   surface = TTF_RenderText_Solid(font, ("Good: " + to_string(good)).c_str(), color);
                   texture = SDL_CreateTextureFromSurface(renderer, surface);
                   textRect = { 325,500, surface->w, surface->h };
                   SDL_RenderCopy(renderer, texture, NULL, &textRect);  
                   surface = TTF_RenderText_Solid(font, ("Error: " + to_string(miss+tooearly)).c_str(), color);
                   texture = SDL_CreateTextureFromSurface(renderer, surface);
                    textRect = { 325,550, surface->w, surface->h };
                    SDL_RenderCopy(renderer, texture, NULL, &textRect);
					SDL_DestroyTexture(texture);
					SDL_FreeSurface(surface);
					TTF_CloseFont(font);
					TTF_Quit();
					});
					t3.join();
					SDL_RenderPresent(renderer);
                    //completed loop
                    while (true) {
						//check button be clicked
						SDL_PollEvent(&e);
                        if (e.type == SDL_MOUSEBUTTONDOWN) {
                            int x, y;
							SDL_GetMouseState(&x, &y);
							//replay button
                            if (x > 230&& x <400 && y > 620 && y < 800) {
                                gameplay = true;
                                noods.resize(0);
                                std::thread t1([&music]() {
                                    Mix_PlayMusic(music, -1);
                                    if (music == NULL) Mix_PlayMusic(music, -1);
                                    });
                                t1.join();
                                //time reset
                                startTime = std::time(nullptr);
                                perfect = 0;
                                good = 0;
                                miss = 0;
                                tooearly = 0;
                                break;
							}
                            //quit button
                            else if (x > 680 && x < 860 && y > 610 && y < 780) {
								noods.resize(0);
                                std::thread t1([&music]() {
									Mix_PlayMusic(music, -1);
									if (music == NULL) Mix_PlayMusic(music, -1);
									});
								t1.join();
								perfect = 0;
								good = 0;
								miss = 0;
								tooearly = 0;
                                SDL_DestroyTexture(backgroundTexture);
                                SDL_DestroyTexture(goodTexture);
                                SDL_DestroyTexture(missTexture);
                                SDL_DestroyTexture(perfectTexture);
                                SDL_DestroyTexture(tooearlyTexture);
								break;
							}
                           
						}
					}
                    SDL_DestroyTexture(complete0Texture);
                    SDL_DestroyTexture(complete1Texture);
                    SDL_DestroyTexture(complete2Texture);
                    SDL_DestroyTexture(complete3Texture);
                    Mix_FreeMusic(end);
                    
                }
                //check time
                cout << elapsedTime<< endl;
               
            }
            startTime = std::time(nullptr);
        }
        //close music
        Mix_FreeMusic(music);
       
    }

   
    // endgame
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_DestroyTexture(noodTexture);
    SDL_DestroyTexture(longnoodTexture);
    SDL_Quit();
    return 0;
}
¯OriginalContentÀªSelections¨FilePathÙMC:\Users\ttk08\OneDrive\Documents\GitHub\project\Project2\Project2\Source.cpp¨Language£C++‘’“¥Value Ù`#file:'Source.cpp'  táº¡i sao khi tÃ´i áº¥n nÃºt s hoáº·c d ,f ,j ,k, l nood khÃ´ng biáº¿n máº¥tÀ¨Response…§ContentÚ¡Trong Ä‘oáº¡n mÃ£ cá»§a báº¡n, má»™t "nood" chá»‰ Ä‘Æ°á»£c Ä‘Ã¡nh dáº¥u lÃ  "check = false" (tá»©c lÃ  biáº¿n máº¥t) khi má»™t trong cÃ¡c Ä‘iá»u kiá»‡n sau Ä‘Ãºng:

1. Nood Ä‘ang á»Ÿ vá»‹ trÃ­ y tá»« 525 Ä‘áº¿n 800.
2. NÃºt tÆ°Æ¡ng á»©ng vá»›i vá»‹ trÃ­ x cá»§a nood Ä‘Æ°á»£c nháº¥n.

Náº¿u báº¡n Ä‘ang gáº·p váº¥n Ä‘á» vá»›i viá»‡c nood khÃ´ng biáº¿n máº¥t khi báº¡n nháº¥n nÃºt, cÃ³ thá»ƒ cÃ³ má»™t sá»‘ nguyÃªn nhÃ¢n sau:

- Nood khÃ´ng á»Ÿ trong pháº¡m vi y tá»« 525 Ä‘áº¿n 800. Báº¡n cÃ³ thá»ƒ kiá»ƒm tra láº¡i logic cá»§a trÃ² chÆ¡i Ä‘á»ƒ Ä‘áº£m báº£o ráº±ng báº¡n Ä‘ang nháº¥n nÃºt vÃ o thá»i Ä‘iá»ƒm Ä‘Ãºng.
- Báº¡n cÃ³ thá»ƒ Ä‘ang nháº¥n nÃºt khÃ´ng Ä‘Ãºng vá»›i vá»‹ trÃ­ x cá»§a nood. HÃ£y cháº¯c cháº¯n ráº±ng báº¡n Ä‘ang nháº¥n nÃºt Ä‘Ãºng tÆ°Æ¡ng á»©ng vá»›i vá»‹ trÃ­ cá»§a nood.
- CÃ³ thá»ƒ cÃ³ lá»—i vá»›i cÃ¡ch báº¡n xá»­ lÃ½ sá»± kiá»‡n bÃ n phÃ­m. HÃ£y kiá»ƒm tra láº¡i Ä‘oáº¡n mÃ£ cá»§a báº¡n Ä‘á»ƒ Ä‘áº£m báº£o ráº±ng báº¡n Ä‘ang xá»­ lÃ½ sá»± kiá»‡n bÃ n phÃ­m má»™t cÃ¡ch chÃ­nh xÃ¡c.

Náº¿u táº¥t cáº£ cÃ¡c Ä‘iá»u kiá»‡n trÃªn Ä‘á»u Ä‘Ãºng nhÆ°ng váº¥n Ä‘á» váº«n cÃ²n, hÃ£y kiá»ƒm tra láº¡i toÃ n bá»™ logic cá»§a trÃ² chÆ¡i Ä‘á»ƒ tÃ¬m ra nguyÃªn nhÃ¢n.¤Type ¦Status¯FollowUpPrompts’Ù7How can I debug the keyboard event handling in my code?ÙkCan you suggest a way to verify if the nood's y position is within the correct range when a key is pressed?³CodeVulnerabilities…¨DateTime×ÿ¡íĞeûªThreadNameÀ°CopilotSessionId‚¤GuidÙ$c302e80e-c53f-4447-a5fd-b49766fd74d3¨ClientId¢IdÙ4Microsoft.VisualStudio.Conversations.Chat.HelpWindow§Request§Request•Ù$6ae4f1e2-9a59-428a-ba27-3bc39f3f3607Ù$bc1cbb89-1261-4034-a902-ccc10d2a7563’†¯ProviderMoniker‚¤NameÙ6Microsoft.VisualStudio.Copilot.DocumentContextProvider§Version£0.1¦Member¤file©CanReduceÃ©RequestIdÙ$6ae4f1e2-9a59-428a-ba27-3bc39f3f3607©ReferenceÙ-#file:'repos\\Project2\\Project2\\Source.cpp'¥ValueÈ|°dÙ‘Microsoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a…§ContentÚ{¤#include <SDL.h>
#include <stdio.h>
#include <SDL_image.h>
#include <iostream>
#include <ctime>
#include<vector>
#include<algorithm>
#include<random>
#include<SDL_mixer.h>
#include<SDL_ttf.h>
#include<thread>

using namespace std;


//creat a funtion to generate random number from seed time
int generateRandomNumber(int min, int max) {
	static bool first = true;
    if (first) {
		srand(time(NULL));
		first = false;
	}
	return min + rand() % ((max + 1) - min);
}
//creat a funtion to generate n random numbers from seed time
vector<int> generateRandomNumbers(int min, int max, int n) {
	vector<int> result;
    for (int i = 0; i < n; i++) {
		result.push_back(generateRandomNumber(min, max));
	}
	return result;
}

const int positionnood[] = { 59,205,331,605,751,876 };
const int numbernood[]={1,1,1,1,1,1,2,2,2,2,2,3,3,1,3,4,1,4,6,2};
int creatnumberofnood() {
	int numberofnood = generateRandomNumber(1,20);
	return numbernood[numberofnood];
}
vector<int> creatpositionofnood(int numbernood) {
    vector<int> result;
    if (numbernood % 2 == 0) {
        
        result= generateRandomNumbers(1, 3, numbernood/2);
        for (int i = 0; i < numbernood / 2; i++) { result.push_back(6 - result[i] + 1); }
        return result;
    }
    else {
        int th=generateRandomNumber(1,2);
        if (th == 1) {
           
            return generateRandomNumbers(1, 3, numbernood);
        }
        else {
            return generateRandomNumbers(4, 6, numbernood);
		}
    }
    return result;
}
struct Noods {
    SDL_Texture* a;
    int x=0, y=0;
    bool check = false;
};
  

int main(int argc, char* args[]) {
    bool gameplay = false;

    // Khá»Ÿi táº¡o SDL
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        printf("SDL could not initialize! SDL_Error: %s\n", SDL_GetError());
        return 1;
    }

    SDL_Window* window = SDL_CreateWindow("SDL 2.0 Basic Example", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 1080, 810, SDL_WINDOW_SHOWN);
    if (window == NULL) {
        printf("Window could not be created! SDL_Error: %s\n", SDL_GetError());
        return 1;
    }

    // Táº¡o renderer
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    if (renderer == NULL) {
        printf("Renderer could not be created! SDL_Error: %s\n", SDL_GetError());
        return 1;
    }
    SDL_Surface* mouse = IMG_Load("Image/nood.png");
    if (mouse == NULL) {
        printf("SDL could not load image! SDL Error: %s\n", SDL_GetError());
        return 1;
    }
    SDL_Texture* mouseTexture = SDL_CreateTextureFromSurface(renderer, mouse);
    SDL_FreeSurface(mouse);
    SDL_Rect mouseRect = { 100,1.1, 100, 100 };
    

    SDL_Surface* openSurface = IMG_Load("Image/open.png");
    SDL_Texture* openTexture = SDL_CreateTextureFromSurface(renderer, openSurface);
    SDL_FreeSurface(openSurface);

   
    SDL_Texture* texture = openTexture;
    
    SDL_Rect destinationRect = { 0,0, 1080, 810 };
    SDL_RenderCopyEx(renderer, texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
    
    
    Noods nood;
    nood.a = mouseTexture;
    nood.x = 59;
    nood.y = 0;
    nood.check = true;
    vector<Noods> noods;
    noods.push_back(nood);

    // Update renderer
    SDL_RenderPresent(renderer);


    while (true) {
        //if mouse click
        SDL_Event e;
        SDL_PollEvent(&e);
        if (e.type == SDL_MOUSEBUTTONDOWN) {
            break;
        }
    }
    //delete opentexture
    SDL_DestroyTexture(openTexture);
 
    // Texture máº·c Ä‘á»‹nh
  

    // Táº¡o cá»­a sá»•
    // Main loop
    bool quit = false;
    SDL_Event e;
    float demSpeed = 0;
    float demWave = 0;
    int demNood = 0;
    // Khá»Ÿi táº¡o SDL
    if (SDL_Init(SDL_INIT_AUDIO) < 0) {
        printf("SDL could not initialize! SDL_Error: %s\n", SDL_GetError());
        return 1;
    }

    // Khá»Ÿi táº¡o SDL_mixer
    if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048) < 0) {
        printf("SDL_mixer could not initialize! SDL_mixer Error: %s\n", Mix_GetError());
        return 1;
    }

    // Load file nháº¡c MP3
    Mix_Music* music = Mix_LoadMUS("music/menu.mp3");
    if (music == NULL) {
        printf("Failed to load music! SDL_mixer Error: %s\n", Mix_GetError());
        return 1;
    }
    // creat a SDL_Thread to play music
    

    while (!quit) {
        SDL_Surface* menuSurface = IMG_Load("Image/Menu.png");
        SDL_Texture* menuTexture = SDL_CreateTextureFromSurface(renderer, menuSurface);
        SDL_FreeSurface(menuSurface);
        SDL_Surface* menu1Surface = IMG_Load("Image/Menu1.png");
        SDL_Texture* menu1Texture = SDL_CreateTextureFromSurface(renderer, menu1Surface);
        SDL_FreeSurface(menu1Surface);

        SDL_Surface* menu2Surface = IMG_Load("Image/Menu2.png");
        SDL_Texture* menu2Texture = SDL_CreateTextureFromSurface(renderer, menu2Surface);
        SDL_FreeSurface(menu2Surface);

        SDL_Surface* menu3Surface = IMG_Load("Image/Menu3.png");
        SDL_Texture* menu3Texture = SDL_CreateTextureFromSurface(renderer, menu3Surface);
        SDL_FreeSurface(menu3Surface);
        texture = menuTexture;
        int speed = 16;
        int demsp = 0;
        // Xá»­ lÃ½ sá»± kiá»‡n
        std::thread t1([&music]() {
            Mix_PlayMusic(music, -1);
            // if music end reapeat
            if (music == NULL) Mix_PlayMusic(music, -1);

            });
        t1.join();
        while (true) {

            while (SDL_PollEvent(&e) != 0) {
                if (e.type == SDL_QUIT) {
                    quit = true;
                }
            }

            SDL_Rect destinationRect = { 0,0.0, 1080, 810 };
            SDL_RenderCopyEx(renderer, texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);

            // Update renderer
            SDL_RenderPresent(renderer);
            //if mouse in position
            int x, y;
            SDL_GetMouseState(&x, &y);
            //if mouse don't
            if (x > 400 && x < 700) {
                if (y > 350 && y < 475) {
                    texture = menu1Texture;
                    //exit program if mouse click   
                    SDL_PollEvent(&e);
                    if (e.type == SDL_MOUSEBUTTONDOWN) {
                        gameplay = true;

                        break;
                    }
                }
                else if (y > 490 && y < 600) {
                    texture = menu2Texture;
                    //if mouse click
                    
                    SDL_PollEvent(&e);
                    
                    if (e.type == SDL_MOUSEBUTTONDOWN) {
						//pause music and display how to play
                        Mix_PauseMusic();
						SDL_Surface* howtoplaySurface = IMG_Load("Image/how to play.png");
						SDL_Texture* howtoplayTexture = SDL_CreateTextureFromSurface(renderer, howtoplaySurface);
						SDL_FreeSurface(howtoplaySurface);
						destinationRect = { 0,0, 1080, 810 };
						SDL_RenderCopyEx(renderer, howtoplayTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
						SDL_RenderPresent(renderer);
                        SDL_Delay(500);
						//if mouse click
                        while (true) {
							SDL_PollEvent(&e);
                            //if mouse click
                            if (e.type == SDL_MOUSEBUTTONDOWN) {
								//delete howtoplay texture
								SDL_DestroyTexture(howtoplayTexture);
								break;
                            }
						}
						//delete howtoplay texture
						SDL_DestroyTexture(howtoplayTexture);
                        //music resume
                        Mix_ResumeMusic();
					}
                    
                }
                else if (y > 600 && y < 700) {

                    texture = menu3Texture;
                    //program quif if mouse click

                    SDL_PollEvent(&e);
                    if (e.type == SDL_MOUSEBUTTONDOWN) {

                        return 0;

                    }

                }
                else {
                    texture = menuTexture;
                }
            }
            else {
                texture = menuTexture;
            }
           // SDL_Delay(5);
        }
        // Load file nháº¡c MP3
        Mix_Music* music = Mix_LoadMUS("music/AdhesiveWombat - 8 Bit Adventure.mp3");
        if (music == NULL) {
            printf("Failed to load music! SDL_mixer Error: %s\n", Mix_GetError());
            return 1;
        }

        // PhÃ¡t nháº¡c
       
        




        if (gameplay == true) {
            //delete menu texture
            SDL_DestroyTexture(menuTexture);
            SDL_DestroyTexture(menu1Texture);
            SDL_DestroyTexture(menu2Texture);
            SDL_DestroyTexture(menu3Texture);
            //gameplay
            SDL_Surface* backgroundSurface = IMG_Load("Image/gameplay.png");
            if (backgroundSurface == NULL) {
                printf("SDL could not load image! SDL Error: %s\n", SDL_GetError());
                return 1;
            }
            SDL_Texture* backgroundTexture = SDL_CreateTextureFromSurface(renderer, backgroundSurface);
            SDL_FreeSurface(backgroundSurface);
            texture = backgroundTexture;
            SDL_Surface* goodSurface = IMG_Load("Image/good.png");
            SDL_Texture* goodTexture = SDL_CreateTextureFromSurface(renderer, goodSurface);
            SDL_FreeSurface(goodSurface);
            SDL_Surface* missSurface = IMG_Load("Image/miss.png");
            SDL_Texture* missTexture = SDL_CreateTextureFromSurface(renderer, missSurface);
            SDL_FreeSurface(missSurface);
            SDL_Surface* perfectSurface = IMG_Load("Image/perfect.png");
            SDL_Texture* perfectTexture = SDL_CreateTextureFromSurface(renderer, perfectSurface);
            SDL_FreeSurface(perfectSurface);    
            SDL_Surface* tooearlySurface = IMG_Load("Image/too early.png");
            SDL_Texture* tooearlyTexture = SDL_CreateTextureFromSurface(renderer, tooearlySurface);
            SDL_FreeSurface(tooearlySurface);
            
            
            
            

            SDL_Delay(1000);
            t1 = std::thread([&music]() {
                Mix_PlayMusic(music, -1);
                });
            t1.join();
            //stopwatch with ctime
            time_t startTime = std::time(nullptr);
            int demkey = 0;
            int demperfect = 0;
            int choice;
            int perfect = 0;
            int good = 0;
            int miss = 0;
            int tooearly = 0;
            while (gameplay) {
                time_t currentTime = std::time(nullptr);
                time_t elapsedTime = currentTime - startTime;
                //display background
                while (SDL_PollEvent(&e) != 0) {
                    if (e.type == SDL_QUIT) {
                        quit = true;
                    }
                }
                destinationRect = { 0,0, 1080, 810 };
                SDL_RenderCopyEx(renderer, texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
                demSpeed += 1;
              //  if (size(noods) > 100) noods.erase(noods.begin(), noods.begin() + 80);
                if (demSpeed >= 1) {
                    demSpeed = 0;
                    for (Noods& x : noods) {

                        if (x.check == true) {
                            if (x.y >= 810) {
                                x.check = false;
                                choice = 0;
                                demperfect = 20;
                                miss++;
                                // gameplay = false;
                               //  noods.resize(0);
                            }
                            x.y += 6;

                            SDL_Rect mouseRect = { x.x,x.y, 100, 100 };
                            SDL_RenderCopyEx(renderer, x.a, NULL, &mouseRect, 0.0, NULL, SDL_FLIP_NONE);
                        }
                      
                      
                    }
                    demWave +=2;
                    if (demWave >= 125) {
                        demWave = 0;
                        vector<int> position = creatpositionofnood(creatnumberofnood());
                        
                        if (elapsedTime <= 268 && !(elapsedTime >= 206 && elapsedTime <= 210)) {
                            for (int y : position) {

                                noods.push_back(nood);
                                noods.back().x = positionnood[y - 1];

                            }
                        }
                        demsp++;
                        if (demsp >= 15) {
                            if (speed > 8) {
                                speed -= 1;
                            }
                            demsp = 0;
                        }
                    }
                }

                if (demkey == 0) {

                    for (Noods& x : noods) {
                        if (x.check == true && x.y >= 525 && x.y <= 800) {
                            if (x.x == 59 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_S]) {
                                x.check = false;

                               
                                if (x.y >= 525 && x.y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x.y >= 575 && x.y < 630) || (x.y >= 740 && x.y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x.y >= 630 && x.y < 740) { choice = 3; demperfect = 20; perfect++; }
                                demkey = 10;
                            }
                            else if (x.x == 205 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_D]) {
                                x.check = false;
                                
                                if (x.y >= 525 && x.y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x.y >= 575 && x.y < 630) || (x.y >= 740 && x.y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x.y >= 630 && x.y < 740) { choice = 3; demperfect = 20; perfect++; }
                               
                                demkey = 10;
                            }
                            else if (x.x == 331 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_F]) {
                                x.check = false;
                               
                                if (x.y >= 525 && x.y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x.y >= 575 && x.y < 630) || (x.y >= 740 && x.y < 800)) { choice = 2; demperfect = 20;good++; }
                                else if (x.y >= 630 && x.y < 740) { choice = 3; demperfect = 20; perfect++; }
                                
                                    demkey = 10;
                            }
                            else if (x.x == 605 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_J]) {
                                x.check = false;
                                
                                if (x.y >= 525 && x.y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x.y >= 575 && x.y < 630) || (x.y >= 740 && x.y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x.y >= 630 && x.y < 740) { choice = 3; demperfect = 20; perfect++; }
								
									
                                
                                demkey = 10;
                            }
                            else if (x.x == 751 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_K]) {
                                x.check = false;

                                if (x.y >= 525 && x.y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x.y >= 575 && x.y < 630) || (x.y >= 740 && x.y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x.y >= 630 && x.y < 740) { choice = 3; demperfect = 20; perfect++; }
								
								
                             
                                demkey = 10;
                            }
                            else if (x.x == 876 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_L]) {
                                x.check = false;
                               
                                if (x.y >= 525 && x.y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x.y >= 575 && x.y < 630) || (x.y >= 740 && x.y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x.y >= 630 && x.y < 740) { choice = 3; demperfect = 20; perfect++; }
                               
                                demkey = 10;
                            }
                            else continue;
                        }
                        else if (x.check == true && x.y < 575) { break; }
                    }
                }
                else demkey--;
                //pause game if esc press
                if (demkey == 0) {
                    if (SDL_GetKeyboardState(NULL)[SDL_SCANCODE_ESCAPE]) {
                        Mix_PauseMusic();
                        SDL_Surface* pauseSurface = IMG_Load("Image/pause.png");
                        SDL_Texture* pauseTexture = SDL_CreateTextureFromSurface(renderer, pauseSurface);
                        SDL_FreeSurface(pauseSurface);
                        destinationRect = {230,200, 600, 450};
                        SDL_RenderCopyEx(renderer, pauseTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
                        SDL_RenderPresent(renderer);
                        //music pause
                        while (true) {
                            //if mouse click
                            SDL_PollEvent(&e);
                            if (e.type == SDL_MOUSEBUTTONDOWN) {
                                int x, y;
                                SDL_GetMouseState(&x, &y);
                                // XÃ¡c Ä‘á»‹nh xem ngÆ°á»i dÃ¹ng Ä‘Ã£ nháº¥n vÃ o nÃºt nÃ o
                                if (x > 450 && x < 600 && y > 350 && y < 500) {
                                    // Resume button clicked
                                    Mix_ResumeMusic();
                                    break;
                                }
                                else if (x > 320 && x < 440 && y > 510 && y < 580) {
                                    // Quit button clicked
                                    noods.resize(0);
                                    std::thread t1([&music]() {
                                        Mix_PlayMusic(music, -1);
                                        if (music == NULL) Mix_PlayMusic(music, -1);
                                        });
                                    t1.join();
                                    perfect = 0;
                                    good = 0;
                                    miss = 0;
                                    tooearly = 0;
                                    //time reset
                                    startTime = std::time(nullptr);

                                    break;
                                }
                                else if (y > 510 && y < 580&&x>610&&x<730) {
									gameplay = false;
                                    noods.resize(0);
                                    break;
								}
							}
                        }
                        
                        //delete pause texture
                        SDL_DestroyTexture(pauseTexture);
                        demkey = 10;
                    }

                }
                else demkey--;
                if (demperfect > 0) {
                    demperfect--;
                    thread t2([&renderer, perfectTexture,goodTexture,missTexture,tooearlyTexture,choice]() {
                        //display perfect
                        SDL_Rect destinationRect = { 430,550,200,250 };
                        if (choice == 0) SDL_RenderCopyEx(renderer, missTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
						else if (choice == 1) SDL_RenderCopyEx(renderer, tooearlyTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
						else if (choice == 2) SDL_RenderCopyEx(renderer, goodTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
						else if (choice == 3)
                        SDL_RenderCopyEx(renderer, perfectTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
                        });

                    t2.join();
                }

                SDL_RenderPresent(renderer);
               


                SDL_Delay(speed);
                //elapsedTime>=1
                //(size(noods)==0||noods.back().check == false) && elapsedTime >= 272
                if ((size(noods) == 0 || noods.back().check == false) && elapsedTime >= 271) {
                    Mix_HaltMusic();
                    //play end music 
                  //creat music end
                    Mix_Music* end = Mix_LoadMUS("music/end.mp3");
                    if (end == NULL) {
						printf("Failed to load music! SDL_mixer Error: %s\n", Mix_GetError());
						return 1;
					}
                    //play music end
                    //increase volume
                    
                    Mix_PlayMusic(end, 1);
                    //while music end
                    SDL_Delay(400);
                    gameplay = false;
                    noods.resize(0);
                    //delete texture
                    //music stop
                    
                    SDL_Surface* complete0Surface = IMG_Load("Image/complete0.png");
                    SDL_Texture* complete0Texture = SDL_CreateTextureFromSurface(renderer, complete0Surface);
                    SDL_FreeSurface(complete0Surface);
                    SDL_Surface* complete1Surface = IMG_Load("Image/complete1.png");
                    SDL_Texture* complete1Texture = SDL_CreateTextureFromSurface(renderer, complete1Surface);
                    SDL_FreeSurface(complete1Surface);
                    SDL_Surface* complete2Surface = IMG_Load("Image/complete2.png");
                    SDL_Texture* complete2Texture = SDL_CreateTextureFromSurface(renderer, complete2Surface);
                    SDL_FreeSurface(complete2Surface);
                    SDL_Surface* complete3Surface = IMG_Load("Image/complete3.png");
                    SDL_Texture* complete3Texture = SDL_CreateTextureFromSurface(renderer, complete3Surface);
                    SDL_FreeSurface(complete3Surface);
                   int point=perfect*5+good*3;
                   float completionRate = (perfect*1.0 * 2 + good) / ((perfect + good + miss + tooearly) * 2);
                   destinationRect = {-10,0,1200,810 };
                   if (completionRate>0.8) {
						destinationRect = { -80,0,1200,810 };
						SDL_RenderCopyEx(renderer, complete3Texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
                       
					}
                   else if (completionRate>0.6) {
						
						SDL_RenderCopyEx(renderer, complete2Texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
					}
                   else if (completionRate>0.4) {
						
						SDL_RenderCopyEx(renderer, complete1Texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
					}
                   else {
						
						SDL_RenderCopyEx(renderer, complete0Texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
					}
                   //use tff to write string "Your point is: " + point in line 1
                   thread t3([&renderer, point, perfect, good, miss, tooearly]() {
                   TTF_Init();
                   TTF_Font* font = TTF_OpenFont("Front/font.ttf", 24);
                   SDL_Color color = { 255, 255, 0 };
                   SDL_Surface* surface;
                   SDL_Texture* texture;
                   SDL_Rect textRect;
                   if (miss + tooearly == 0 && good == 0) {
                       surface = TTF_RenderText_Solid(font, "So Amazing, You are perfect", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 210,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                   else if (miss + tooearly<0.05*(perfect+good+miss+tooearly) && good > 0 && good<0.2 * perfect) {
                       surface = TTF_RenderText_Solid(font, "Great,you're almost perfect", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 220,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                   else if ((good + perfect*2) > 0.8* (miss + tooearly + good + perfect)*2) {
                       surface = TTF_RenderText_Solid(font, "Good", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 450,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                   else if ( (good + perfect*2)> 0.6* (miss + tooearly + good + perfect)*2) {
                       surface = TTF_RenderText_Solid(font, "Not bad but you can better", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 240,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                   else {
                       surface = TTF_RenderText_Solid(font, "You need to practice more", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 230,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                    surface = TTF_RenderText_Solid(font, ("Your point is: " + to_string(point)).c_str(), color);
                    texture = SDL_CreateTextureFromSurface(renderer, surface);
                    textRect = { 325,400, surface->w, surface->h };
                   SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   //wirite string Perfect: + perfect in line 2
                   surface = TTF_RenderText_Solid(font, ("Perfect: " + to_string(perfect)).c_str(), color);
                   texture = SDL_CreateTextureFromSurface(renderer, surface);
                   textRect = { 325,450, surface->w, surface->h };
                   SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   //wirite string Good: + good in line 3
                   surface = TTF_RenderText_Solid(font, ("Good: " + to_string(good)).c_str(), color);
                   texture = SDL_CreateTextureFromSurface(renderer, surface);
                   textRect = { 325,500, surface->w, surface->h };
                   SDL_RenderCopy(renderer, texture, NULL, &textRect);  
                   //wirite string error:+(miss+tooearly) in line 4
                   surface = TTF_RenderText_Solid(font, ("Error: " + to_string(miss+tooearly)).c_str(), color);
                   texture = SDL_CreateTextureFromSurface(renderer, surface);
                    textRect = { 325,550, surface->w, surface->h };
                    SDL_RenderCopy(renderer, texture, NULL, &textRect);
                    //in line 5 if error=0 and good=0 wirite string "So Amazing, You are perfect" else if error=0 and good>0 wirite string "Great" else if error>0 and (good+perrfect)>70%total wirite string "Good" else if error>0 and (good+perrfect)>50%total wirite string "Not bad but you can better" else wirite string "You need to practice more"
                   
                    //delete texture
					SDL_DestroyTexture(texture);
					//delete surface
					SDL_FreeSurface(surface);
					//close font
					TTF_CloseFont(font);
					//quit ttf
					TTF_Quit();
					});
					t3.join();
					// Update renderer
					SDL_RenderPresent(renderer);
                    

                   //delete texture
                    
                   


                    //if mouse click break
                    while (true) {
						//if mouse click
						SDL_PollEvent(&e);
                        if (e.type == SDL_MOUSEBUTTONDOWN) {
							//if position of mouse
                            int x, y;
							SDL_GetMouseState(&x, &y);
							// XÃ¡c Ä‘á»‹nh xem ngÆ°á»i dÃ¹ng Ä‘Ã£ nháº¥n vÃ o nÃºt nÃ o
                            if (x > 230&& x <400 && y > 620 && y < 800) {
                                gameplay = true;
                                noods.resize(0);
                                std::thread t1([&music]() {
                                    Mix_PlayMusic(music, -1);
                                    if (music == NULL) Mix_PlayMusic(music, -1);
                                    });
                                t1.join();
                                //time reset
                                startTime = std::time(nullptr);
                                perfect = 0;
                                good = 0;
                                miss = 0;
                                tooearly = 0;
                                break;
							}
                            else if (x > 680 && x < 860 && y > 610 && y < 780) {
								// Quit button clicked
								noods.resize(0);
                                std::thread t1([&music]() {
									Mix_PlayMusic(music, -1);
									if (music == NULL) Mix_PlayMusic(music, -1);
									});
								t1.join();
								perfect = 0;
								good = 0;
								miss = 0;
								tooearly = 0;
                                //delete texture
                                SDL_DestroyTexture(backgroundTexture);
								break;
							}
                           
						}
					}
                    //delete texture
                    SDL_DestroyTexture(complete0Texture);
                    SDL_DestroyTexture(complete1Texture);
                    SDL_DestroyTexture(complete2Texture);
                    SDL_DestroyTexture(complete3Texture);
                    //delete end
                    Mix_FreeMusic(end);
                    
                }
                cout << elapsedTime << " " << noods.size() << endl;
            }
            //Ã¬f music end reapeat
            //reset time
            startTime = std::time(nullptr);

        }
        //close music
        Mix_FreeMusic(music);
    }

   
    // Giáº£i phÃ³ng bá»™ nhá»› vÃ  Ä‘Ã³ng SDL
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();
    return 0;
}
¯OriginalContentÀªSelections¨FilePathÙ8C:\Users\ttk08\source\repos\Project2\Project2\Source.cpp¨Language£C++†¯ProviderMoniker‚¤NameÙ6Microsoft.VisualStudio.Copilot.DocumentContextProvider§Version£0.1¦Member¤file©CanReduceÃ©RequestIdÙ$6ae4f1e2-9a59-428a-ba27-3bc39f3f3607©ReferenceÙ/#file:'project\\Project2\\Project2\\Source.cpp'¥ValueÈ†@dÙ‘Microsoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a…§ContentÚ…#include <SDL.h>
#include <stdio.h>
#include <SDL_image.h>
#include <iostream>
#include <ctime>
#include<vector>
#include<algorithm>
#include<random>
#include<SDL_mixer.h>
#include<SDL_ttf.h>
#include<thread>

using namespace std;


//creat a funtion to generate random number from seed time
int generateRandomNumber(int min, int max) {
	static bool first = true;
    if (first) {
		srand(time(NULL));
		first = false;
	}
	return min + rand() % ((max + 1) - min);
}
//creat a funtion to generate n random numbers from seed time
vector<int> generateRandomNumbers(int min, int max, int n) {
	vector<int> result;
    for (int i = 0; i < n; i++) {
		result.push_back(generateRandomNumber(min, max));
	}
	return result;
}
const int positionnood[] = { 59,205,331,605,751,876 };//position of nood
const int numbernood[]={1,1,1,1,1,1,2,2,2,2,2,3,3,1,3,4,1,4,6,2};//rate of random number of nood
//funtion to random number of nood
int creatnumberofnood() {
	int numberofnood = generateRandomNumber(1,20);
	return numbernood[numberofnood];
}
//funtion to random position of nood with number of nood
vector<int> creatpositionofnood(int numbernood) {
    vector<int> result;
    if (numbernood % 2 == 0) {
        
        result= generateRandomNumbers(1, 3, numbernood/2);
        for (int i = 0; i < numbernood / 2; i++) { result.push_back(6 - result[i] + 1); }
        return result;
    }
    else {
        int th=generateRandomNumber(1,2);
        if (th == 1) {
           
            return generateRandomNumbers(1, 3, numbernood);
        }
        else {
            return generateRandomNumbers(4, 6, numbernood);
		}
    }
    return result;
}
//struct of nood
struct Noods {
    SDL_Texture* a;
    int x=0, y=0;
    bool check = false;
    int type = 0;
};
struct Longnoods:Noods {
    int length;
    bool isbeinghold;
    int type = 1;
};
void renderLongnood(SDL_Renderer* renderer, SDL_Texture* longnoodTexture, int customLength, int posX, int posY) {
    // Táº¡o SDL_Rect cho pháº§n Ä‘áº§u cá»§a longnood
    SDL_Rect headRect = { 0, 0, 88, customLength/2*4.5 };
    SDL_Rect destHeadRect = { posX, posY, 44, customLength/2 };
    // Táº¡o SDL_Rect cho pháº§n cuá»‘i cá»§a longnood
    SDL_Rect tailRect = { 0, 3532 - customLength/2*4.5, 88, customLength/2*4.5 };
    SDL_Rect destTailRect = { posX, posY + customLength/2, 44, customLength/2 };
    // Váº½ pháº§n Ä‘áº§u, thÃ¢n vÃ  cuá»‘i cá»§a longnood
    SDL_RenderCopyEx(renderer, longnoodTexture, &headRect, &destHeadRect, 0.0, NULL, SDL_FLIP_NONE);
    SDL_RenderCopyEx(renderer, longnoodTexture, &tailRect, &destTailRect, 0.0, NULL, SDL_FLIP_NONE);
}
int main(int argc, char* args[]) {
    bool gameplay = false;

    // Khá»Ÿi táº¡o SDL
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        printf("SDL could not initialize! SDL_Error: %s\n", SDL_GetError());
        return 1;
    }

    SDL_Window* window = SDL_CreateWindow("SDL 2.0 Basic Example", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 1080, 810, SDL_WINDOW_SHOWN);
    if (window == NULL) {
        printf("Window could not be created! SDL_Error: %s\n", SDL_GetError());
        return 1;
    }

    // Táº¡o renderer
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    if (renderer == NULL) {
        printf("Renderer could not be created! SDL_Error: %s\n", SDL_GetError());
        return 1;
    }
    SDL_Surface* noodSurface = IMG_Load("Image/nood.png");
    if (noodSurface == NULL) {
        printf("SDL could not load image! SDL Error: %s\n", SDL_GetError());
        return 1;
    }
    SDL_Surface* longnoodSurface = IMG_Load("Image/longnood.png");
    if (longnoodSurface == NULL) {
		printf("SDL could not load image! SDL Error: %s\n", SDL_GetError());
		return 1;
	}
    SDL_Texture* noodTexture = SDL_CreateTextureFromSurface(renderer, noodSurface);
    SDL_FreeSurface(noodSurface);
    SDL_Rect noodRect = { 100,1.1, 100, 100 };
    SDL_Texture* longnoodTexture = SDL_CreateTextureFromSurface(renderer, longnoodSurface);
    SDL_FreeSurface(longnoodSurface);
    //create longnoodreact with full image of longnood
    SDL_Rect longnoodRect = { 205,50, 22, 200};

    SDL_Surface* openSurface = IMG_Load("Image/open.png");
    SDL_Texture* openTexture = SDL_CreateTextureFromSurface(renderer, openSurface);
    SDL_FreeSurface(openSurface);

   
    SDL_Texture* texture = openTexture;
    
    SDL_Rect destinationRect = { 0,0, 1080, 810 };
    SDL_RenderCopyEx(renderer, texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
    
    
    Noods nood;
    nood.a = noodTexture;
    nood.x = 59;
    nood.y = 0;
    nood.check = true;
    //creat vector nood for gameplay
    vector<Noods*> noods;
    
    Longnoods longnood;
    longnood.a = longnoodTexture;
    longnood.x = 205;
    longnood.y = 0;
    longnood.check = true;
    SDL_RenderPresent(renderer);

    //loop of opentexture go to game if mouse click
    while (true) {
        //if mouse click
        SDL_Event e;
        SDL_PollEvent(&e);
        if (e.type == SDL_MOUSEBUTTONDOWN) {
            break;
        }
    }
    SDL_DestroyTexture(openTexture);
    bool quit = false;
    SDL_Event e;
    // variable to control speed and number of nood
    float demSpeed = 0;
    float demWave = 0;
    int demNood = 0;
    int speed = 6;
    int demsp = 0;
    int maxWave = 125;
    if (SDL_Init(SDL_INIT_AUDIO) < 0) {
        printf("SDL could not initialize! SDL_Error: %s\n", SDL_GetError());
        return 1;
    }
    if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048) < 0) {
        printf("SDL_mixer could not initialize! SDL_mixer Error: %s\n", Mix_GetError());
        return 1;
    }

    // load menu music
    Mix_Music* music = Mix_LoadMUS("music/menu.mp3");
    if (music == NULL) {
        printf("Failed to load music! SDL_mixer Error: %s\n", Mix_GetError());
        return 1;
    }
    //main loop start menu 
    while (!quit) {
        SDL_Surface* menuSurface = IMG_Load("Image/Menu.png");
        SDL_Texture* menuTexture = SDL_CreateTextureFromSurface(renderer, menuSurface);
        SDL_FreeSurface(menuSurface);
        SDL_Surface* menu1Surface = IMG_Load("Image/Menu1.png");
        SDL_Texture* menu1Texture = SDL_CreateTextureFromSurface(renderer, menu1Surface);
        SDL_FreeSurface(menu1Surface);

        SDL_Surface* menu2Surface = IMG_Load("Image/Menu2.png");
        SDL_Texture* menu2Texture = SDL_CreateTextureFromSurface(renderer, menu2Surface);
        SDL_FreeSurface(menu2Surface);

        SDL_Surface* menu3Surface = IMG_Load("Image/Menu3.png");
        SDL_Texture* menu3Texture = SDL_CreateTextureFromSurface(renderer, menu3Surface);
        SDL_FreeSurface(menu3Surface);
        texture = menuTexture;
        //thread to play menu music and play again if music menu end
        std::thread t1([&music]() {
            Mix_PlayMusic(music, -1);
            if (music == NULL) Mix_PlayMusic(music, -1);

            });
        t1.join();
        //menu loop
        while (true) {

            while (SDL_PollEvent(&e) != 0) {
                if (e.type == SDL_QUIT) {
                    quit = true;
                }
            }

            SDL_Rect destinationRect = { 0,0.0, 1080, 810 };
            SDL_RenderCopyEx(renderer, texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
            SDL_RenderPresent(renderer);
   //get mouse position
            int x, y;
            SDL_GetMouseState(&x, &y);
            //action with each button of menu be clicked
            //play button
            if (x > 400 && x < 700) {
                if (y > 350 && y < 475) {
                    texture = menu1Texture;
                    //go to gameplay if mouse click in play button
                    SDL_PollEvent(&e);
                    if (e.type == SDL_MOUSEBUTTONDOWN) {
                        gameplay = true;

                        break;
                    }
                }
                //how to play button
                else if (y > 490 && y < 600) {
                    texture = menu2Texture;
                    SDL_PollEvent(&e);
                    if (e.type == SDL_MOUSEBUTTONDOWN) {
						//pause music and display how to play texture
                        Mix_PauseMusic();
						SDL_Surface* howtoplaySurface = IMG_Load("Image/how to play.png");
						SDL_Texture* howtoplayTexture = SDL_CreateTextureFromSurface(renderer, howtoplaySurface);
						SDL_FreeSurface(howtoplaySurface);
						destinationRect = { 0,0, 1080, 810 };
						SDL_RenderCopyEx(renderer, howtoplayTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
						SDL_RenderPresent(renderer);
                        SDL_Delay(500);
						//how to play loop
                        while (true) {
							SDL_PollEvent(&e);
                            //go back to menu if mouse click
                            if (e.type == SDL_MOUSEBUTTONDOWN) {
								SDL_DestroyTexture(howtoplayTexture);
								break;
                            }
						}
						SDL_DestroyTexture(howtoplayTexture);
                        //music resume
                        Mix_ResumeMusic();
					}
                    
                }
                //exit button
                else if (y > 600 && y < 700) {

                    texture = menu3Texture;
                    //program quif if mouse click

                    SDL_PollEvent(&e);
                    if (e.type == SDL_MOUSEBUTTONDOWN) {

                        return 0;

                    }

                }
				//if mouse not in button
                else {
                    texture = menuTexture;
                }
            }
			//if mouse not in button
            else {
                texture = menuTexture;
            }
        }
        // Load gameplay music
        Mix_Music* music = Mix_LoadMUS("music/AdhesiveWombat - 8 Bit Adventure.mp3");
        if (music == NULL) {
            printf("Failed to load music! SDL_mixer Error: %s\n", Mix_GetError());
            return 1;
        }
        //setup for gameplay
        if (gameplay == true) {
            //delete menu texture
            SDL_DestroyTexture(menuTexture);
            SDL_DestroyTexture(menu1Texture);
            SDL_DestroyTexture(menu2Texture);
            SDL_DestroyTexture(menu3Texture);
            SDL_Surface* backgroundSurface = IMG_Load("Image/gameplay.png");
            if (backgroundSurface == NULL) {
                printf("SDL could not load image! SDL Error: %s\n", SDL_GetError());
                return 1;
            }
            SDL_Texture* backgroundTexture = SDL_CreateTextureFromSurface(renderer, backgroundSurface);
            SDL_FreeSurface(backgroundSurface);
            texture = backgroundTexture;
            SDL_Surface* goodSurface = IMG_Load("Image/good.png");
            SDL_Texture* goodTexture = SDL_CreateTextureFromSurface(renderer, goodSurface);
            SDL_FreeSurface(goodSurface);
            SDL_Surface* missSurface = IMG_Load("Image/miss.png");
            SDL_Texture* missTexture = SDL_CreateTextureFromSurface(renderer, missSurface);
            SDL_FreeSurface(missSurface);
            SDL_Surface* perfectSurface = IMG_Load("Image/perfect.png");
            SDL_Texture* perfectTexture = SDL_CreateTextureFromSurface(renderer, perfectSurface);
            SDL_FreeSurface(perfectSurface);    
            SDL_Surface* tooearlySurface = IMG_Load("Image/too early.png");
            SDL_Texture* tooearlyTexture = SDL_CreateTextureFromSurface(renderer, tooearlySurface);
            SDL_FreeSurface(tooearlySurface);
            
            //thread to play gameplay music
            t1 = std::thread([&music]() {
                Mix_PlayMusic(music, -1);
                });
            t1.join();
            //variable for gameplay
            time_t startTime = std::time(nullptr);
            int demkey = 0;
            int demperfect = 0;
            int choice;
            int perfect = 0;
            int good = 0;
            int miss = 0;
            int tooearly = 0;
            int waitlongnood = 0;
            speed = 6;
            //gameplay loop
            while (gameplay) {
                // check time after each loop
                time_t currentTime = std::time(nullptr);
                time_t elapsedTime = currentTime - startTime;
                while (SDL_PollEvent(&e) != 0) {
                    if (e.type == SDL_QUIT) {
                        quit = true;
                    }
                }
                destinationRect = { 0,0, 1080, 810 };
                SDL_RenderCopyEx(renderer, texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
                demSpeed += 1;
                //control speed, create wave nood
                if (demSpeed >= 1) {
                    demSpeed = 0;
                    for (Noods*& x : noods) {
                        if (x->check == true) {
                            if (x->y >= 810) {
                                x->check = false;
                                choice = 0;
                                demperfect = 20;
                                miss++;
                            }
                            x->y += speed;//move nood and control speed
                            SDL_Rect noodrect = { x->x,x->y, 100, 100 };
                            //check type of nood to render
                            if (x->type == 1) {
                                //Ã©p kiá»ƒu sang longnood Ä‘á»ƒ váº½
                                Longnoods* y = (Longnoods*)x;
                                renderLongnood(renderer, longnoodTexture, y->length, y->x + 30, y->y);
                            }
                            else {
                                SDL_RenderCopyEx(renderer, x->a, NULL, &noodrect, 0.0, NULL, SDL_FLIP_NONE);
                            }
                        }


                    }
                    demWave += 2;
                    // wave of nood
                    if (demWave >= maxWave && waitlongnood <= 0) {
                        demWave = 0;
                        //create new wave nood
                        vector<int> position = creatpositionofnood(creatnumberofnood());
                        if (elapsedTime <= 268 && !(elapsedTime >= 206 && elapsedTime <= 210)) {
                            int type = generateRandomNumber(1, 8);
                            if (elapsedTime < 10|| type>1) {
                                for (int i = 0; i < position.size(); i++) {
                                    Noods* nood = new Noods;
                                    nood->a = noodTexture;
                                    nood->x = positionnood[position[i] - 1];
                                    nood->y = 0;
                                    nood->check = true;
                                    noods.push_back(nood);
                                }
                            }
                            else {
                                int length = generateRandomNumber(200, 400);
                                for (int i = 0; i < position.size(); i++) {
                                    Longnoods* longnood = new Longnoods;
                                    longnood->a = longnoodTexture;
                                    longnood->x = positionnood[position[i] - 1];
                                    longnood->y = 0 - length;
                                    longnood->check = true;
                                    longnood->length = length;
                                    noods.push_back(longnood);
                                    noods.back()->type = 1;

                                }
                                waitlongnood = length / speed * 2 + maxWave;
                            }
                        }
                        // increase speecd of nood follow time
                        demsp++;
                        if (demsp >= 23) {
                            if (speed < 12) {
                                speed += 1;
                            }
                            if (maxWave > 60) maxWave -= 5;
                            demsp = 0;
                        }
                    }
                    else if (waitlongnood > 0) waitlongnood -= 2;
                }
                if (noods.size() > 50) {
                    //giáº£i phÃ³ng bá»™ nhá»› vÃ  xÃ³a 30 pháº§n tá»­ Ä‘áº§u
                    for (int i = 0; i < 30; i++) {
                        delete noods[i];
                    }
                    noods.erase(noods.begin(), noods.begin() + 30);
                }
                if (demkey == 0) {//demkey to reduce stick key
                    //main gameplay get point and check correct nood be pressed
                    for (Noods*& x : noods) {
                        if (x->check == true && x->y >= 525 && x->y <= 800) {
                            if (x->x == 59 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_S]) {
                                x->check = false;
                                if (x->y >= 525 && x->y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x->y >= 575 && x->y < 630) || (x->y >= 740 && x->y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x->y >= 630 && x->y < 740) { choice = 3; demperfect = 20; perfect++; }
                                demkey = 10;
                            }
                            else if (x->x == 205 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_D]) {
                                x->check = false;

                                if (x->y >= 525 && x->y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x->y >= 575 && x->y < 630) || (x->y >= 740 && x->y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x->y >= 630 && x->y < 740) { choice = 3; demperfect = 20; perfect++; }

                                demkey = 10;
                            }
                            else if (x->x == 331 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_F]) {
                                x->check = false;

                                if (x->y >= 525 && x->y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x->y >= 575 && x->y < 630) || (x->y >= 740 && x->y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x->y >= 630 && x->y < 740) { choice = 3; demperfect = 20; perfect++; }

                                demkey = 10;
                            }
                            else if (x->x == 605 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_J]) {
                                x->check = false;

                                if (x->y >= 525 && x->y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x->y >= 575 && x->y < 630) || (x->y >= 740 && x->y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x->y >= 630 && x->y < 740) { choice = 3; demperfect = 20; perfect++; }



                                demkey = 10;
                            }
                            else if (x->x == 751 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_K]) {
                                x->check = false;

                                if (x->y >= 525 && x->y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x->y >= 575 && x->y < 630) || (x->y >= 740 && x->y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x->y >= 630 && x->y < 740) { choice = 3; demperfect = 20; perfect++; }



                                demkey = 10;
                            }
                            else if (x->x == 876 && SDL_GetKeyboardState(NULL)[SDL_SCANCODE_L]) {
                                x->check = false;

                                if (x->y >= 525 && x->y < 575) { choice = 1; demperfect = 20; tooearly++; }
                                else if ((x->y >= 575 && x->y < 630) || (x->y >= 740 && x->y < 800)) { choice = 2; demperfect = 20; good++; }
                                else if (x->y >= 630 && x->y < 740) { choice = 3; demperfect = 20; perfect++; }

                                demkey = 10;
                            }
                            else continue;
                        }
                        else if (x->check == true && x->y < 575) { break; }
                    }
                }
                else demkey--;
               
              
                    if (SDL_GetKeyboardState(NULL)[SDL_SCANCODE_ESCAPE]) {
                        Mix_PauseMusic();
                        SDL_Surface* pauseSurface = IMG_Load("Image/pause.png");
                        SDL_Texture* pauseTexture = SDL_CreateTextureFromSurface(renderer, pauseSurface);
                        SDL_FreeSurface(pauseSurface);
                        destinationRect = {230,200, 600, 450};
                        SDL_RenderCopyEx(renderer, pauseTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
                        SDL_RenderPresent(renderer);
                        while (true) {
                            //if mouse click
                            SDL_PollEvent(&e);
                            if (e.type == SDL_MOUSEBUTTONDOWN) {
                                int x, y;
                                SDL_GetMouseState(&x, &y);
                                //check button be clicked
                                if (x > 450 && x < 600 && y > 350 && y < 500) {
                                    // Resume button clicked
                                    Mix_ResumeMusic();
                                    break;
                                }
                                else if (x > 320 && x < 440 && y > 510 && y < 580) {
                                    // Quit button clicked
                                    noods.resize(0);
                                    std::thread t1([&music]() {
                                        Mix_PlayMusic(music, -1);
                                        if (music == NULL) Mix_PlayMusic(music, -1);
                                        });
                                    t1.join();
                                    perfect = 0;
                                    good = 0;
                                    miss = 0;
                                    tooearly = 0;
                                    startTime = std::time(nullptr);
                                    break;
                                }
                                else if (y > 510 && y < 580&&x>610&&x<730) {
									gameplay = false;
                                    noods.resize(0);
                                    break;
								}
							}
                        }
                        SDL_DestroyTexture(pauseTexture);
                        demkey = 10;
                    }

                
                else demkey--;
                //code for display result of nood be pressed
                if (demperfect > 0) {
                    demperfect--;
                    //thread to display result
                    thread t2([&renderer, perfectTexture,goodTexture,missTexture,tooearlyTexture,choice]() {
                        SDL_Rect destinationRect = { 430,550,200,250 };
                        if (choice == 0) SDL_RenderCopyEx(renderer, missTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
						else if (choice == 1) SDL_RenderCopyEx(renderer, tooearlyTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
						else if (choice == 2) SDL_RenderCopyEx(renderer, goodTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
						else if (choice == 3)
                        SDL_RenderCopyEx(renderer, perfectTexture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
                        });

                    t2.join();
                }
                //renderer gameplay
                SDL_RenderPresent(renderer);
             
                SDL_Delay(12);
               //check to end game
                if ((size(noods) == 0 || noods.back()->check == false) && elapsedTime >= 271) {
                    Mix_HaltMusic();
                    //end music
                    Mix_Music* end = Mix_LoadMUS("music/end.mp3");
                    if (end == NULL) {
						printf("Failed to load music! SDL_mixer Error: %s\n", Mix_GetError());
						return 1;
					}
                    Mix_PlayMusic(end, 1);
                    SDL_Delay(400);
                    gameplay = false;
                    noods.resize(0);
                    //complete game and caculate point and display
                    SDL_Surface* complete0Surface = IMG_Load("Image/complete0.png");
                    SDL_Texture* complete0Texture = SDL_CreateTextureFromSurface(renderer, complete0Surface);
                    SDL_FreeSurface(complete0Surface);
                    SDL_Surface* complete1Surface = IMG_Load("Image/complete1.png");
                    SDL_Texture* complete1Texture = SDL_CreateTextureFromSurface(renderer, complete1Surface);
                    SDL_FreeSurface(complete1Surface);
                    SDL_Surface* complete2Surface = IMG_Load("Image/complete2.png");
                    SDL_Texture* complete2Texture = SDL_CreateTextureFromSurface(renderer, complete2Surface);
                    SDL_FreeSurface(complete2Surface);
                    SDL_Surface* complete3Surface = IMG_Load("Image/complete3.png");
                    SDL_Texture* complete3Texture = SDL_CreateTextureFromSurface(renderer, complete3Surface);
                    SDL_FreeSurface(complete3Surface);
                   int point=perfect*5+good*3;
                   float completionRate = (perfect*1.0 * 2 + good) / ((perfect + good + miss + tooearly) * 2);
                   destinationRect = {-10,0,1200,810 };
                   if (completionRate>0.8) {
						destinationRect = { -80,0,1200,810 };
						SDL_RenderCopyEx(renderer, complete3Texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
                       
					}
                   else if (completionRate>0.6) {
						
						SDL_RenderCopyEx(renderer, complete2Texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
					}
                   else if (completionRate>0.4) {
						
						SDL_RenderCopyEx(renderer, complete1Texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
					}
                   else {
						
						SDL_RenderCopyEx(renderer, complete0Texture, NULL, &destinationRect, 0.0, NULL, SDL_FLIP_NONE);
					}
                   //use ttf to write completed art
                   thread t3([&renderer, point, perfect, good, miss, tooearly]() {
                   TTF_Init();
                   TTF_Font* font = TTF_OpenFont("Front/font.ttf", 24);
                   SDL_Color color = { 255, 255, 0 };
                   SDL_Surface* surface;
                   SDL_Texture* texture;
                   SDL_Rect textRect;
                   if (miss + tooearly == 0 && good == 0) {
                       surface = TTF_RenderText_Solid(font, "So Amazing, You are perfect", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 210,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                   else if (miss + tooearly<0.05*(perfect+good+miss+tooearly) && good > 0 && good<0.25 * perfect) {
                       surface = TTF_RenderText_Solid(font, "Great,you're almost perfect", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 220,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                   else if ((good + perfect*2) > 0.8* (miss + tooearly + good + perfect)*2) {
                       surface = TTF_RenderText_Solid(font, "Good", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 475,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                   else if ( (good + perfect*2)> 0.6* (miss + tooearly + good + perfect)*2) {
                       surface = TTF_RenderText_Solid(font, "Not bad but you can better", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 240,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                   else {
                       surface = TTF_RenderText_Solid(font, "You need to practice more", color);
                       texture = SDL_CreateTextureFromSurface(renderer, surface);
                       textRect = { 230,350, surface->w, surface->h };
                       SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   }
                    surface = TTF_RenderText_Solid(font, ("Your point is: " + to_string(point)).c_str(), color);
                    texture = SDL_CreateTextureFromSurface(renderer, surface);
                    textRect = { 325,400, surface->w, surface->h };
                   SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   surface = TTF_RenderText_Solid(font, ("Perfect: " + to_string(perfect)).c_str(), color);
                   texture = SDL_CreateTextureFromSurface(renderer, surface);
                   textRect = { 325,450, surface->w, surface->h };
                   SDL_RenderCopy(renderer, texture, NULL, &textRect);
                   surface = TTF_RenderText_Solid(font, ("Good: " + to_string(good)).c_str(), color);
                   texture = SDL_CreateTextureFromSurface(renderer, surface);
                   textRect = { 325,500, surface->w, surface->h };
                   SDL_RenderCopy(renderer, texture, NULL, &textRect);  
                   surface = TTF_RenderText_Solid(font, ("Error: " + to_string(miss+tooearly)).c_str(), color);
                   texture = SDL_CreateTextureFromSurface(renderer, surface);
                    textRect = { 325,550, surface->w, surface->h };
                    SDL_RenderCopy(renderer, texture, NULL, &textRect);
					SDL_DestroyTexture(texture);
					SDL_FreeSurface(surface);
					TTF_CloseFont(font);
					TTF_Quit();
					});
					t3.join();
					SDL_RenderPresent(renderer);
                    //completed loop
                    while (true) {
						//check button be clicked
						SDL_PollEvent(&e);
                        if (e.type == SDL_MOUSEBUTTONDOWN) {
                            int x, y;
							SDL_GetMouseState(&x, &y);
							//replay button
                            if (x > 230&& x <400 && y > 620 && y < 800) {
                                gameplay = true;
                                noods.resize(0);
                                std::thread t1([&music]() {
                                    Mix_PlayMusic(music, -1);
                                    if (music == NULL) Mix_PlayMusic(music, -1);
                                    });
                                t1.join();
                                //time reset
                                startTime = std::time(nullptr);
                                perfect = 0;
                                good = 0;
                                miss = 0;
                                tooearly = 0;
                                break;
							}
                            //quit button
                            else if (x > 680 && x < 860 && y > 610 && y < 780) {
								noods.resize(0);
                                std::thread t1([&music]() {
									Mix_PlayMusic(music, -1);
									if (music == NULL) Mix_PlayMusic(music, -1);
									});
								t1.join();
								perfect = 0;
								good = 0;
								miss = 0;
								tooearly = 0;
                                SDL_DestroyTexture(backgroundTexture);
                                SDL_DestroyTexture(goodTexture);
                                SDL_DestroyTexture(missTexture);
                                SDL_DestroyTexture(perfectTexture);
                                SDL_DestroyTexture(tooearlyTexture);
								break;
							}
                           
						}
					}
                    SDL_DestroyTexture(complete0Texture);
                    SDL_DestroyTexture(complete1Texture);
                    SDL_DestroyTexture(complete2Texture);
                    SDL_DestroyTexture(complete3Texture);
                    Mix_FreeMusic(end);
                    
                }
                //check time
                cout << elapsedTime<< endl;
               
            }
            startTime = std::time(nullptr);
        }
        //close music
        Mix_FreeMusic(music);
       
    }

   
    // endgame
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_DestroyTexture(noodTexture);
    SDL_DestroyTexture(longnoodTexture);
    SDL_Quit();
    return 0;
}
¯OriginalContentÀªSelections¨FilePathÙMC:\Users\ttk08\OneDrive\Documents\GitHub\project\Project2\Project2\Source.cpp¨Language£C++‘’“¥Value Ú
#file:'project\\Project2\\Project2\\Source.cpp' #file:'repos\\Project2\\Project2\\Source.cpp' 
cÃ³ sá»± khÃ¡c biá»‡t gÃ¬ trong viá»‡c lÃ m nood biáº¿n máº¥t giá»¯a 2 file nÃ y file Ä‘áº§u tiá»n cá»§a tÃ´i khÃ´ng bá»‹ xÃ³a trong khi file Ä‘áº§u tiá»n thÃ¬ Ä‘Æ°á»£cÀ¨Response…§ContentÚ»Dá»±a trÃªn Ä‘oáº¡n mÃ£ báº¡n Ä‘Ã£ cung cáº¥p, khÃ´ng thá»ƒ xÃ¡c Ä‘á»‹nh Ä‘Æ°á»£c sá»± khÃ¡c biá»‡t giá»¯a hai file vÃ¬ cáº£ hai Ä‘á»u bá»‹ cáº¯t Ä‘á»©t vÃ  khÃ´ng chá»©a Ä‘áº§y Ä‘á»§ mÃ£ nguá»“n. Tuy nhiÃªn, tÃ´i cÃ³ thá»ƒ giáº£i thÃ­ch cÃ¡ch Ä‘á»ƒ lÃ m cho má»™t "nood" (Ä‘á»‘i tÆ°á»£ng trong game cá»§a báº¡n) biáº¿n máº¥t.

Trong trÃ² chÆ¡i video, khi báº¡n muá»‘n má»™t Ä‘á»‘i tÆ°á»£ng biáº¿n máº¥t, báº¡n thÆ°á»ng cÃ³ má»™t sá»‘ lá»±a chá»n:

1. XÃ³a Ä‘á»‘i tÆ°á»£ng khá»i danh sÃ¡ch cÃ¡c Ä‘á»‘i tÆ°á»£ng Ä‘ang hoáº¡t Ä‘á»™ng. Trong trÆ°á»ng há»£p cá»§a báº¡n, náº¿u `noods` lÃ  má»™t vector chá»©a táº¥t cáº£ cÃ¡c "nood" Ä‘ang hoáº¡t Ä‘á»™ng, báº¡n cÃ³ thá»ƒ xÃ³a má»™t "nood" báº±ng cÃ¡ch sá»­ dá»¥ng phÆ°Æ¡ng thá»©c `erase` cá»§a vector.

```C++
noods.erase(noods.begin() + index);
```

Trong Ä‘Ã³ `index` lÃ  vá»‹ trÃ­ cá»§a "nood" báº¡n muá»‘n xÃ³a trong vector.

2. Äáº·t má»™t cá» Ä‘á»ƒ Ä‘Ã¡nh dáº¥u Ä‘á»‘i tÆ°á»£ng lÃ  khÃ´ng hoáº¡t Ä‘á»™ng hoáº·c khÃ´ng hiá»ƒn thá»‹. Trong trÆ°á»ng há»£p cá»§a báº¡n, báº¡n cÃ³ thá»ƒ sá»­ dá»¥ng trÆ°á»ng `check` trong cáº¥u trÃºc `Noods` Ä‘á»ƒ Ä‘Ã¡nh dáº¥u má»™t "nood" lÃ  khÃ´ng hiá»ƒn thá»‹.

```C++
noods[index].check = false;
```

Trong Ä‘Ã³ `index` lÃ  vá»‹ trÃ­ cá»§a "nood" báº¡n muá»‘n áº©n trong vector.

LÆ°u Ã½ ráº±ng trong cáº£ hai trÆ°á»ng há»£p, báº¡n cáº§n cáº­p nháº­t logic váº½ cá»§a báº¡n Ä‘á»ƒ khÃ´ng váº½ cÃ¡c "nood" Ä‘Ã£ bá»‹ xÃ³a hoáº·c Ä‘Æ°á»£c Ä‘Ã¡nh dáº¥u lÃ  khÃ´ng hiá»ƒn thá»‹.¤Type ¦Status¯FollowUpPrompts’ÙIHow can I determine the right time to make a "nood" disappear in my game?ÙbCan you show me how to update my rendering logic to ignore "noods" that are marked as not visible?³CodeVulnerabilities